import {
  __commonJS,
  __publicField,
  __toESM
} from "./chunk-EQCVQC35.js";

// node_modules/long/src/long.js
var require_long = __commonJS({
  "node_modules/long/src/long.js"(exports2, module2) {
    module2.exports = Long30;
    var wasm = null;
    try {
      wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([
        0,
        97,
        115,
        109,
        1,
        0,
        0,
        0,
        1,
        13,
        2,
        96,
        0,
        1,
        127,
        96,
        4,
        127,
        127,
        127,
        127,
        1,
        127,
        3,
        7,
        6,
        0,
        1,
        1,
        1,
        1,
        1,
        6,
        6,
        1,
        127,
        1,
        65,
        0,
        11,
        7,
        50,
        6,
        3,
        109,
        117,
        108,
        0,
        1,
        5,
        100,
        105,
        118,
        95,
        115,
        0,
        2,
        5,
        100,
        105,
        118,
        95,
        117,
        0,
        3,
        5,
        114,
        101,
        109,
        95,
        115,
        0,
        4,
        5,
        114,
        101,
        109,
        95,
        117,
        0,
        5,
        8,
        103,
        101,
        116,
        95,
        104,
        105,
        103,
        104,
        0,
        0,
        10,
        191,
        1,
        6,
        4,
        0,
        35,
        0,
        11,
        36,
        1,
        1,
        126,
        32,
        0,
        173,
        32,
        1,
        173,
        66,
        32,
        134,
        132,
        32,
        2,
        173,
        32,
        3,
        173,
        66,
        32,
        134,
        132,
        126,
        34,
        4,
        66,
        32,
        135,
        167,
        36,
        0,
        32,
        4,
        167,
        11,
        36,
        1,
        1,
        126,
        32,
        0,
        173,
        32,
        1,
        173,
        66,
        32,
        134,
        132,
        32,
        2,
        173,
        32,
        3,
        173,
        66,
        32,
        134,
        132,
        127,
        34,
        4,
        66,
        32,
        135,
        167,
        36,
        0,
        32,
        4,
        167,
        11,
        36,
        1,
        1,
        126,
        32,
        0,
        173,
        32,
        1,
        173,
        66,
        32,
        134,
        132,
        32,
        2,
        173,
        32,
        3,
        173,
        66,
        32,
        134,
        132,
        128,
        34,
        4,
        66,
        32,
        135,
        167,
        36,
        0,
        32,
        4,
        167,
        11,
        36,
        1,
        1,
        126,
        32,
        0,
        173,
        32,
        1,
        173,
        66,
        32,
        134,
        132,
        32,
        2,
        173,
        32,
        3,
        173,
        66,
        32,
        134,
        132,
        129,
        34,
        4,
        66,
        32,
        135,
        167,
        36,
        0,
        32,
        4,
        167,
        11,
        36,
        1,
        1,
        126,
        32,
        0,
        173,
        32,
        1,
        173,
        66,
        32,
        134,
        132,
        32,
        2,
        173,
        32,
        3,
        173,
        66,
        32,
        134,
        132,
        130,
        34,
        4,
        66,
        32,
        135,
        167,
        36,
        0,
        32,
        4,
        167,
        11
      ])), {}).exports;
    } catch (e2) {
    }
    function Long30(low, high, unsigned) {
      this.low = low | 0;
      this.high = high | 0;
      this.unsigned = !!unsigned;
    }
    Long30.prototype.__isLong__;
    Object.defineProperty(Long30.prototype, "__isLong__", { value: true });
    function isLong(obj) {
      return (obj && obj["__isLong__"]) === true;
    }
    Long30.isLong = isLong;
    var INT_CACHE = {};
    var UINT_CACHE = {};
    function fromInt(value, unsigned) {
      var obj, cachedObj, cache;
      if (unsigned) {
        value >>>= 0;
        if (cache = 0 <= value && value < 256) {
          cachedObj = UINT_CACHE[value];
          if (cachedObj)
            return cachedObj;
        }
        obj = fromBits(value, (value | 0) < 0 ? -1 : 0, true);
        if (cache)
          UINT_CACHE[value] = obj;
        return obj;
      } else {
        value |= 0;
        if (cache = -128 <= value && value < 128) {
          cachedObj = INT_CACHE[value];
          if (cachedObj)
            return cachedObj;
        }
        obj = fromBits(value, value < 0 ? -1 : 0, false);
        if (cache)
          INT_CACHE[value] = obj;
        return obj;
      }
    }
    Long30.fromInt = fromInt;
    function fromNumber(value, unsigned) {
      if (isNaN(value))
        return unsigned ? UZERO : ZERO;
      if (unsigned) {
        if (value < 0)
          return UZERO;
        if (value >= TWO_PWR_64_DBL)
          return MAX_UNSIGNED_VALUE;
      } else {
        if (value <= -TWO_PWR_63_DBL)
          return MIN_VALUE;
        if (value + 1 >= TWO_PWR_63_DBL)
          return MAX_VALUE;
      }
      if (value < 0)
        return fromNumber(-value, unsigned).neg();
      return fromBits(value % TWO_PWR_32_DBL | 0, value / TWO_PWR_32_DBL | 0, unsigned);
    }
    Long30.fromNumber = fromNumber;
    function fromBits(lowBits, highBits, unsigned) {
      return new Long30(lowBits, highBits, unsigned);
    }
    Long30.fromBits = fromBits;
    var pow_dbl = Math.pow;
    function fromString(str, unsigned, radix) {
      if (str.length === 0)
        throw Error("empty string");
      if (str === "NaN" || str === "Infinity" || str === "+Infinity" || str === "-Infinity")
        return ZERO;
      if (typeof unsigned === "number") {
        radix = unsigned, unsigned = false;
      } else {
        unsigned = !!unsigned;
      }
      radix = radix || 10;
      if (radix < 2 || 36 < radix)
        throw RangeError("radix");
      var p2;
      if ((p2 = str.indexOf("-")) > 0)
        throw Error("interior hyphen");
      else if (p2 === 0) {
        return fromString(str.substring(1), unsigned, radix).neg();
      }
      var radixToPower = fromNumber(pow_dbl(radix, 8));
      var result = ZERO;
      for (var i = 0; i < str.length; i += 8) {
        var size = Math.min(8, str.length - i), value = parseInt(str.substring(i, i + size), radix);
        if (size < 8) {
          var power = fromNumber(pow_dbl(radix, size));
          result = result.mul(power).add(fromNumber(value));
        } else {
          result = result.mul(radixToPower);
          result = result.add(fromNumber(value));
        }
      }
      result.unsigned = unsigned;
      return result;
    }
    Long30.fromString = fromString;
    function fromValue(val, unsigned) {
      if (typeof val === "number")
        return fromNumber(val, unsigned);
      if (typeof val === "string")
        return fromString(val, unsigned);
      return fromBits(val.low, val.high, typeof unsigned === "boolean" ? unsigned : val.unsigned);
    }
    Long30.fromValue = fromValue;
    var TWO_PWR_16_DBL = 1 << 16;
    var TWO_PWR_24_DBL = 1 << 24;
    var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;
    var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;
    var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;
    var TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);
    var ZERO = fromInt(0);
    Long30.ZERO = ZERO;
    var UZERO = fromInt(0, true);
    Long30.UZERO = UZERO;
    var ONE = fromInt(1);
    Long30.ONE = ONE;
    var UONE = fromInt(1, true);
    Long30.UONE = UONE;
    var NEG_ONE = fromInt(-1);
    Long30.NEG_ONE = NEG_ONE;
    var MAX_VALUE = fromBits(4294967295 | 0, 2147483647 | 0, false);
    Long30.MAX_VALUE = MAX_VALUE;
    var MAX_UNSIGNED_VALUE = fromBits(4294967295 | 0, 4294967295 | 0, true);
    Long30.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;
    var MIN_VALUE = fromBits(0, 2147483648 | 0, false);
    Long30.MIN_VALUE = MIN_VALUE;
    var LongPrototype = Long30.prototype;
    LongPrototype.toInt = function toInt() {
      return this.unsigned ? this.low >>> 0 : this.low;
    };
    LongPrototype.toNumber = function toNumber() {
      if (this.unsigned)
        return (this.high >>> 0) * TWO_PWR_32_DBL + (this.low >>> 0);
      return this.high * TWO_PWR_32_DBL + (this.low >>> 0);
    };
    LongPrototype.toString = function toString(radix) {
      radix = radix || 10;
      if (radix < 2 || 36 < radix)
        throw RangeError("radix");
      if (this.isZero())
        return "0";
      if (this.isNegative()) {
        if (this.eq(MIN_VALUE)) {
          var radixLong = fromNumber(radix), div = this.div(radixLong), rem1 = div.mul(radixLong).sub(this);
          return div.toString(radix) + rem1.toInt().toString(radix);
        } else
          return "-" + this.neg().toString(radix);
      }
      var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned), rem = this;
      var result = "";
      while (true) {
        var remDiv = rem.div(radixToPower), intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0, digits = intval.toString(radix);
        rem = remDiv;
        if (rem.isZero())
          return digits + result;
        else {
          while (digits.length < 6)
            digits = "0" + digits;
          result = "" + digits + result;
        }
      }
    };
    LongPrototype.getHighBits = function getHighBits() {
      return this.high;
    };
    LongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {
      return this.high >>> 0;
    };
    LongPrototype.getLowBits = function getLowBits() {
      return this.low;
    };
    LongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {
      return this.low >>> 0;
    };
    LongPrototype.getNumBitsAbs = function getNumBitsAbs() {
      if (this.isNegative())
        return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
      var val = this.high != 0 ? this.high : this.low;
      for (var bit = 31; bit > 0; bit--)
        if ((val & 1 << bit) != 0)
          break;
      return this.high != 0 ? bit + 33 : bit + 1;
    };
    LongPrototype.isZero = function isZero() {
      return this.high === 0 && this.low === 0;
    };
    LongPrototype.eqz = LongPrototype.isZero;
    LongPrototype.isNegative = function isNegative() {
      return !this.unsigned && this.high < 0;
    };
    LongPrototype.isPositive = function isPositive() {
      return this.unsigned || this.high >= 0;
    };
    LongPrototype.isOdd = function isOdd() {
      return (this.low & 1) === 1;
    };
    LongPrototype.isEven = function isEven() {
      return (this.low & 1) === 0;
    };
    LongPrototype.equals = function equals(other) {
      if (!isLong(other))
        other = fromValue(other);
      if (this.unsigned !== other.unsigned && this.high >>> 31 === 1 && other.high >>> 31 === 1)
        return false;
      return this.high === other.high && this.low === other.low;
    };
    LongPrototype.eq = LongPrototype.equals;
    LongPrototype.notEquals = function notEquals(other) {
      return !this.eq(
        /* validates */
        other
      );
    };
    LongPrototype.neq = LongPrototype.notEquals;
    LongPrototype.ne = LongPrototype.notEquals;
    LongPrototype.lessThan = function lessThan(other) {
      return this.comp(
        /* validates */
        other
      ) < 0;
    };
    LongPrototype.lt = LongPrototype.lessThan;
    LongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {
      return this.comp(
        /* validates */
        other
      ) <= 0;
    };
    LongPrototype.lte = LongPrototype.lessThanOrEqual;
    LongPrototype.le = LongPrototype.lessThanOrEqual;
    LongPrototype.greaterThan = function greaterThan(other) {
      return this.comp(
        /* validates */
        other
      ) > 0;
    };
    LongPrototype.gt = LongPrototype.greaterThan;
    LongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {
      return this.comp(
        /* validates */
        other
      ) >= 0;
    };
    LongPrototype.gte = LongPrototype.greaterThanOrEqual;
    LongPrototype.ge = LongPrototype.greaterThanOrEqual;
    LongPrototype.compare = function compare(other) {
      if (!isLong(other))
        other = fromValue(other);
      if (this.eq(other))
        return 0;
      var thisNeg = this.isNegative(), otherNeg = other.isNegative();
      if (thisNeg && !otherNeg)
        return -1;
      if (!thisNeg && otherNeg)
        return 1;
      if (!this.unsigned)
        return this.sub(other).isNegative() ? -1 : 1;
      return other.high >>> 0 > this.high >>> 0 || other.high === this.high && other.low >>> 0 > this.low >>> 0 ? -1 : 1;
    };
    LongPrototype.comp = LongPrototype.compare;
    LongPrototype.negate = function negate() {
      if (!this.unsigned && this.eq(MIN_VALUE))
        return MIN_VALUE;
      return this.not().add(ONE);
    };
    LongPrototype.neg = LongPrototype.negate;
    LongPrototype.add = function add(addend) {
      if (!isLong(addend))
        addend = fromValue(addend);
      var a48 = this.high >>> 16;
      var a32 = this.high & 65535;
      var a16 = this.low >>> 16;
      var a00 = this.low & 65535;
      var b48 = addend.high >>> 16;
      var b32 = addend.high & 65535;
      var b16 = addend.low >>> 16;
      var b00 = addend.low & 65535;
      var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
      c00 += a00 + b00;
      c16 += c00 >>> 16;
      c00 &= 65535;
      c16 += a16 + b16;
      c32 += c16 >>> 16;
      c16 &= 65535;
      c32 += a32 + b32;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c48 += a48 + b48;
      c48 &= 65535;
      return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
    };
    LongPrototype.subtract = function subtract(subtrahend) {
      if (!isLong(subtrahend))
        subtrahend = fromValue(subtrahend);
      return this.add(subtrahend.neg());
    };
    LongPrototype.sub = LongPrototype.subtract;
    LongPrototype.multiply = function multiply(multiplier) {
      if (this.isZero())
        return ZERO;
      if (!isLong(multiplier))
        multiplier = fromValue(multiplier);
      if (wasm) {
        var low = wasm.mul(
          this.low,
          this.high,
          multiplier.low,
          multiplier.high
        );
        return fromBits(low, wasm.get_high(), this.unsigned);
      }
      if (multiplier.isZero())
        return ZERO;
      if (this.eq(MIN_VALUE))
        return multiplier.isOdd() ? MIN_VALUE : ZERO;
      if (multiplier.eq(MIN_VALUE))
        return this.isOdd() ? MIN_VALUE : ZERO;
      if (this.isNegative()) {
        if (multiplier.isNegative())
          return this.neg().mul(multiplier.neg());
        else
          return this.neg().mul(multiplier).neg();
      } else if (multiplier.isNegative())
        return this.mul(multiplier.neg()).neg();
      if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24))
        return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);
      var a48 = this.high >>> 16;
      var a32 = this.high & 65535;
      var a16 = this.low >>> 16;
      var a00 = this.low & 65535;
      var b48 = multiplier.high >>> 16;
      var b32 = multiplier.high & 65535;
      var b16 = multiplier.low >>> 16;
      var b00 = multiplier.low & 65535;
      var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
      c00 += a00 * b00;
      c16 += c00 >>> 16;
      c00 &= 65535;
      c16 += a16 * b00;
      c32 += c16 >>> 16;
      c16 &= 65535;
      c16 += a00 * b16;
      c32 += c16 >>> 16;
      c16 &= 65535;
      c32 += a32 * b00;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c32 += a16 * b16;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c32 += a00 * b32;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
      c48 &= 65535;
      return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
    };
    LongPrototype.mul = LongPrototype.multiply;
    LongPrototype.divide = function divide(divisor) {
      if (!isLong(divisor))
        divisor = fromValue(divisor);
      if (divisor.isZero())
        throw Error("division by zero");
      if (wasm) {
        if (!this.unsigned && this.high === -2147483648 && divisor.low === -1 && divisor.high === -1) {
          return this;
        }
        var low = (this.unsigned ? wasm.div_u : wasm.div_s)(
          this.low,
          this.high,
          divisor.low,
          divisor.high
        );
        return fromBits(low, wasm.get_high(), this.unsigned);
      }
      if (this.isZero())
        return this.unsigned ? UZERO : ZERO;
      var approx, rem, res;
      if (!this.unsigned) {
        if (this.eq(MIN_VALUE)) {
          if (divisor.eq(ONE) || divisor.eq(NEG_ONE))
            return MIN_VALUE;
          else if (divisor.eq(MIN_VALUE))
            return ONE;
          else {
            var halfThis = this.shr(1);
            approx = halfThis.div(divisor).shl(1);
            if (approx.eq(ZERO)) {
              return divisor.isNegative() ? ONE : NEG_ONE;
            } else {
              rem = this.sub(divisor.mul(approx));
              res = approx.add(rem.div(divisor));
              return res;
            }
          }
        } else if (divisor.eq(MIN_VALUE))
          return this.unsigned ? UZERO : ZERO;
        if (this.isNegative()) {
          if (divisor.isNegative())
            return this.neg().div(divisor.neg());
          return this.neg().div(divisor).neg();
        } else if (divisor.isNegative())
          return this.div(divisor.neg()).neg();
        res = ZERO;
      } else {
        if (!divisor.unsigned)
          divisor = divisor.toUnsigned();
        if (divisor.gt(this))
          return UZERO;
        if (divisor.gt(this.shru(1)))
          return UONE;
        res = UZERO;
      }
      rem = this;
      while (rem.gte(divisor)) {
        approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));
        var log2 = Math.ceil(Math.log(approx) / Math.LN2), delta = log2 <= 48 ? 1 : pow_dbl(2, log2 - 48), approxRes = fromNumber(approx), approxRem = approxRes.mul(divisor);
        while (approxRem.isNegative() || approxRem.gt(rem)) {
          approx -= delta;
          approxRes = fromNumber(approx, this.unsigned);
          approxRem = approxRes.mul(divisor);
        }
        if (approxRes.isZero())
          approxRes = ONE;
        res = res.add(approxRes);
        rem = rem.sub(approxRem);
      }
      return res;
    };
    LongPrototype.div = LongPrototype.divide;
    LongPrototype.modulo = function modulo(divisor) {
      if (!isLong(divisor))
        divisor = fromValue(divisor);
      if (wasm) {
        var low = (this.unsigned ? wasm.rem_u : wasm.rem_s)(
          this.low,
          this.high,
          divisor.low,
          divisor.high
        );
        return fromBits(low, wasm.get_high(), this.unsigned);
      }
      return this.sub(this.div(divisor).mul(divisor));
    };
    LongPrototype.mod = LongPrototype.modulo;
    LongPrototype.rem = LongPrototype.modulo;
    LongPrototype.not = function not2() {
      return fromBits(~this.low, ~this.high, this.unsigned);
    };
    LongPrototype.and = function and(other) {
      if (!isLong(other))
        other = fromValue(other);
      return fromBits(this.low & other.low, this.high & other.high, this.unsigned);
    };
    LongPrototype.or = function or(other) {
      if (!isLong(other))
        other = fromValue(other);
      return fromBits(this.low | other.low, this.high | other.high, this.unsigned);
    };
    LongPrototype.xor = function xor(other) {
      if (!isLong(other))
        other = fromValue(other);
      return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);
    };
    LongPrototype.shiftLeft = function shiftLeft(numBits) {
      if (isLong(numBits))
        numBits = numBits.toInt();
      if ((numBits &= 63) === 0)
        return this;
      else if (numBits < 32)
        return fromBits(this.low << numBits, this.high << numBits | this.low >>> 32 - numBits, this.unsigned);
      else
        return fromBits(0, this.low << numBits - 32, this.unsigned);
    };
    LongPrototype.shl = LongPrototype.shiftLeft;
    LongPrototype.shiftRight = function shiftRight(numBits) {
      if (isLong(numBits))
        numBits = numBits.toInt();
      if ((numBits &= 63) === 0)
        return this;
      else if (numBits < 32)
        return fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >> numBits, this.unsigned);
      else
        return fromBits(this.high >> numBits - 32, this.high >= 0 ? 0 : -1, this.unsigned);
    };
    LongPrototype.shr = LongPrototype.shiftRight;
    LongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {
      if (isLong(numBits))
        numBits = numBits.toInt();
      numBits &= 63;
      if (numBits === 0)
        return this;
      else {
        var high = this.high;
        if (numBits < 32) {
          var low = this.low;
          return fromBits(low >>> numBits | high << 32 - numBits, high >>> numBits, this.unsigned);
        } else if (numBits === 32)
          return fromBits(high, 0, this.unsigned);
        else
          return fromBits(high >>> numBits - 32, 0, this.unsigned);
      }
    };
    LongPrototype.shru = LongPrototype.shiftRightUnsigned;
    LongPrototype.shr_u = LongPrototype.shiftRightUnsigned;
    LongPrototype.toSigned = function toSigned() {
      if (!this.unsigned)
        return this;
      return fromBits(this.low, this.high, false);
    };
    LongPrototype.toUnsigned = function toUnsigned() {
      if (this.unsigned)
        return this;
      return fromBits(this.low, this.high, true);
    };
    LongPrototype.toBytes = function toBytes(le) {
      return le ? this.toBytesLE() : this.toBytesBE();
    };
    LongPrototype.toBytesLE = function toBytesLE() {
      var hi = this.high, lo = this.low;
      return [
        lo & 255,
        lo >>> 8 & 255,
        lo >>> 16 & 255,
        lo >>> 24,
        hi & 255,
        hi >>> 8 & 255,
        hi >>> 16 & 255,
        hi >>> 24
      ];
    };
    LongPrototype.toBytesBE = function toBytesBE() {
      var hi = this.high, lo = this.low;
      return [
        hi >>> 24,
        hi >>> 16 & 255,
        hi >>> 8 & 255,
        hi & 255,
        lo >>> 24,
        lo >>> 16 & 255,
        lo >>> 8 & 255,
        lo & 255
      ];
    };
    Long30.fromBytes = function fromBytes(bytes, unsigned, le) {
      return le ? Long30.fromBytesLE(bytes, unsigned) : Long30.fromBytesBE(bytes, unsigned);
    };
    Long30.fromBytesLE = function fromBytesLE(bytes, unsigned) {
      return new Long30(
        bytes[0] | bytes[1] << 8 | bytes[2] << 16 | bytes[3] << 24,
        bytes[4] | bytes[5] << 8 | bytes[6] << 16 | bytes[7] << 24,
        unsigned
      );
    };
    Long30.fromBytesBE = function fromBytesBE(bytes, unsigned) {
      return new Long30(
        bytes[4] << 24 | bytes[5] << 16 | bytes[6] << 8 | bytes[7],
        bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3],
        unsigned
      );
    };
  }
});

// node_modules/@protobufjs/aspromise/index.js
var require_aspromise = __commonJS({
  "node_modules/@protobufjs/aspromise/index.js"(exports2, module2) {
    "use strict";
    module2.exports = asPromise;
    function asPromise(fn, ctx) {
      var params = new Array(arguments.length - 1), offset = 0, index = 2, pending = true;
      while (index < arguments.length)
        params[offset++] = arguments[index++];
      return new Promise(function executor(resolve, reject) {
        params[offset] = function callback(err) {
          if (pending) {
            pending = false;
            if (err)
              reject(err);
            else {
              var params2 = new Array(arguments.length - 1), offset2 = 0;
              while (offset2 < params2.length)
                params2[offset2++] = arguments[offset2];
              resolve.apply(null, params2);
            }
          }
        };
        try {
          fn.apply(ctx || null, params);
        } catch (err) {
          if (pending) {
            pending = false;
            reject(err);
          }
        }
      });
    }
  }
});

// node_modules/@protobufjs/base64/index.js
var require_base64 = __commonJS({
  "node_modules/@protobufjs/base64/index.js"(exports2) {
    "use strict";
    var base64 = exports2;
    base64.length = function length(string) {
      var p2 = string.length;
      if (!p2)
        return 0;
      var n2 = 0;
      while (--p2 % 4 > 1 && string.charAt(p2) === "=")
        ++n2;
      return Math.ceil(string.length * 3) / 4 - n2;
    };
    var b64 = new Array(64);
    var s64 = new Array(123);
    for (i = 0; i < 64; )
      s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;
    var i;
    base64.encode = function encode(buffer2, start, end) {
      var parts = null, chunk = [];
      var i2 = 0, j = 0, t2;
      while (start < end) {
        var b2 = buffer2[start++];
        switch (j) {
          case 0:
            chunk[i2++] = b64[b2 >> 2];
            t2 = (b2 & 3) << 4;
            j = 1;
            break;
          case 1:
            chunk[i2++] = b64[t2 | b2 >> 4];
            t2 = (b2 & 15) << 2;
            j = 2;
            break;
          case 2:
            chunk[i2++] = b64[t2 | b2 >> 6];
            chunk[i2++] = b64[b2 & 63];
            j = 0;
            break;
        }
        if (i2 > 8191) {
          (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
          i2 = 0;
        }
      }
      if (j) {
        chunk[i2++] = b64[t2];
        chunk[i2++] = 61;
        if (j === 1)
          chunk[i2++] = 61;
      }
      if (parts) {
        if (i2)
          parts.push(String.fromCharCode.apply(String, chunk.slice(0, i2)));
        return parts.join("");
      }
      return String.fromCharCode.apply(String, chunk.slice(0, i2));
    };
    var invalidEncoding = "invalid encoding";
    base64.decode = function decode(string, buffer2, offset) {
      var start = offset;
      var j = 0, t2;
      for (var i2 = 0; i2 < string.length; ) {
        var c2 = string.charCodeAt(i2++);
        if (c2 === 61 && j > 1)
          break;
        if ((c2 = s64[c2]) === void 0)
          throw Error(invalidEncoding);
        switch (j) {
          case 0:
            t2 = c2;
            j = 1;
            break;
          case 1:
            buffer2[offset++] = t2 << 2 | (c2 & 48) >> 4;
            t2 = c2;
            j = 2;
            break;
          case 2:
            buffer2[offset++] = (t2 & 15) << 4 | (c2 & 60) >> 2;
            t2 = c2;
            j = 3;
            break;
          case 3:
            buffer2[offset++] = (t2 & 3) << 6 | c2;
            j = 0;
            break;
        }
      }
      if (j === 1)
        throw Error(invalidEncoding);
      return offset - start;
    };
    base64.test = function test(string) {
      return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string);
    };
  }
});

// node_modules/@protobufjs/eventemitter/index.js
var require_eventemitter = __commonJS({
  "node_modules/@protobufjs/eventemitter/index.js"(exports2, module2) {
    "use strict";
    module2.exports = EventEmitter;
    function EventEmitter() {
      this._listeners = {};
    }
    EventEmitter.prototype.on = function on(evt, fn, ctx) {
      (this._listeners[evt] || (this._listeners[evt] = [])).push({
        fn,
        ctx: ctx || this
      });
      return this;
    };
    EventEmitter.prototype.off = function off(evt, fn) {
      if (evt === void 0)
        this._listeners = {};
      else {
        if (fn === void 0)
          this._listeners[evt] = [];
        else {
          var listeners = this._listeners[evt];
          for (var i = 0; i < listeners.length; )
            if (listeners[i].fn === fn)
              listeners.splice(i, 1);
            else
              ++i;
        }
      }
      return this;
    };
    EventEmitter.prototype.emit = function emit(evt) {
      var listeners = this._listeners[evt];
      if (listeners) {
        var args = [], i = 1;
        for (; i < arguments.length; )
          args.push(arguments[i++]);
        for (i = 0; i < listeners.length; )
          listeners[i].fn.apply(listeners[i++].ctx, args);
      }
      return this;
    };
  }
});

// node_modules/@protobufjs/float/index.js
var require_float = __commonJS({
  "node_modules/@protobufjs/float/index.js"(exports2, module2) {
    "use strict";
    module2.exports = factory(factory);
    function factory(exports3) {
      if (typeof Float32Array !== "undefined") (function() {
        var f32 = new Float32Array([-0]), f8b = new Uint8Array(f32.buffer), le = f8b[3] === 128;
        function writeFloat_f32_cpy(val, buf, pos) {
          f32[0] = val;
          buf[pos] = f8b[0];
          buf[pos + 1] = f8b[1];
          buf[pos + 2] = f8b[2];
          buf[pos + 3] = f8b[3];
        }
        function writeFloat_f32_rev(val, buf, pos) {
          f32[0] = val;
          buf[pos] = f8b[3];
          buf[pos + 1] = f8b[2];
          buf[pos + 2] = f8b[1];
          buf[pos + 3] = f8b[0];
        }
        exports3.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;
        exports3.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;
        function readFloat_f32_cpy(buf, pos) {
          f8b[0] = buf[pos];
          f8b[1] = buf[pos + 1];
          f8b[2] = buf[pos + 2];
          f8b[3] = buf[pos + 3];
          return f32[0];
        }
        function readFloat_f32_rev(buf, pos) {
          f8b[3] = buf[pos];
          f8b[2] = buf[pos + 1];
          f8b[1] = buf[pos + 2];
          f8b[0] = buf[pos + 3];
          return f32[0];
        }
        exports3.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;
        exports3.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy;
      })();
      else (function() {
        function writeFloat_ieee754(writeUint, val, buf, pos) {
          var sign = val < 0 ? 1 : 0;
          if (sign)
            val = -val;
          if (val === 0)
            writeUint(1 / val > 0 ? (
              /* positive */
              0
            ) : (
              /* negative 0 */
              2147483648
            ), buf, pos);
          else if (isNaN(val))
            writeUint(2143289344, buf, pos);
          else if (val > 34028234663852886e22)
            writeUint((sign << 31 | 2139095040) >>> 0, buf, pos);
          else if (val < 11754943508222875e-54)
            writeUint((sign << 31 | Math.round(val / 1401298464324817e-60)) >>> 0, buf, pos);
          else {
            var exponent = Math.floor(Math.log(val) / Math.LN2), mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;
            writeUint((sign << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf, pos);
          }
        }
        exports3.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);
        exports3.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);
        function readFloat_ieee754(readUint, buf, pos) {
          var uint = readUint(buf, pos), sign = (uint >> 31) * 2 + 1, exponent = uint >>> 23 & 255, mantissa = uint & 8388607;
          return exponent === 255 ? mantissa ? NaN : sign * Infinity : exponent === 0 ? sign * 1401298464324817e-60 * mantissa : sign * Math.pow(2, exponent - 150) * (mantissa + 8388608);
        }
        exports3.readFloatLE = readFloat_ieee754.bind(null, readUintLE);
        exports3.readFloatBE = readFloat_ieee754.bind(null, readUintBE);
      })();
      if (typeof Float64Array !== "undefined") (function() {
        var f64 = new Float64Array([-0]), f8b = new Uint8Array(f64.buffer), le = f8b[7] === 128;
        function writeDouble_f64_cpy(val, buf, pos) {
          f64[0] = val;
          buf[pos] = f8b[0];
          buf[pos + 1] = f8b[1];
          buf[pos + 2] = f8b[2];
          buf[pos + 3] = f8b[3];
          buf[pos + 4] = f8b[4];
          buf[pos + 5] = f8b[5];
          buf[pos + 6] = f8b[6];
          buf[pos + 7] = f8b[7];
        }
        function writeDouble_f64_rev(val, buf, pos) {
          f64[0] = val;
          buf[pos] = f8b[7];
          buf[pos + 1] = f8b[6];
          buf[pos + 2] = f8b[5];
          buf[pos + 3] = f8b[4];
          buf[pos + 4] = f8b[3];
          buf[pos + 5] = f8b[2];
          buf[pos + 6] = f8b[1];
          buf[pos + 7] = f8b[0];
        }
        exports3.writeDoubleLE = le ? writeDouble_f64_cpy : writeDouble_f64_rev;
        exports3.writeDoubleBE = le ? writeDouble_f64_rev : writeDouble_f64_cpy;
        function readDouble_f64_cpy(buf, pos) {
          f8b[0] = buf[pos];
          f8b[1] = buf[pos + 1];
          f8b[2] = buf[pos + 2];
          f8b[3] = buf[pos + 3];
          f8b[4] = buf[pos + 4];
          f8b[5] = buf[pos + 5];
          f8b[6] = buf[pos + 6];
          f8b[7] = buf[pos + 7];
          return f64[0];
        }
        function readDouble_f64_rev(buf, pos) {
          f8b[7] = buf[pos];
          f8b[6] = buf[pos + 1];
          f8b[5] = buf[pos + 2];
          f8b[4] = buf[pos + 3];
          f8b[3] = buf[pos + 4];
          f8b[2] = buf[pos + 5];
          f8b[1] = buf[pos + 6];
          f8b[0] = buf[pos + 7];
          return f64[0];
        }
        exports3.readDoubleLE = le ? readDouble_f64_cpy : readDouble_f64_rev;
        exports3.readDoubleBE = le ? readDouble_f64_rev : readDouble_f64_cpy;
      })();
      else (function() {
        function writeDouble_ieee754(writeUint, off0, off1, val, buf, pos) {
          var sign = val < 0 ? 1 : 0;
          if (sign)
            val = -val;
          if (val === 0) {
            writeUint(0, buf, pos + off0);
            writeUint(1 / val > 0 ? (
              /* positive */
              0
            ) : (
              /* negative 0 */
              2147483648
            ), buf, pos + off1);
          } else if (isNaN(val)) {
            writeUint(0, buf, pos + off0);
            writeUint(2146959360, buf, pos + off1);
          } else if (val > 17976931348623157e292) {
            writeUint(0, buf, pos + off0);
            writeUint((sign << 31 | 2146435072) >>> 0, buf, pos + off1);
          } else {
            var mantissa;
            if (val < 22250738585072014e-324) {
              mantissa = val / 5e-324;
              writeUint(mantissa >>> 0, buf, pos + off0);
              writeUint((sign << 31 | mantissa / 4294967296) >>> 0, buf, pos + off1);
            } else {
              var exponent = Math.floor(Math.log(val) / Math.LN2);
              if (exponent === 1024)
                exponent = 1023;
              mantissa = val * Math.pow(2, -exponent);
              writeUint(mantissa * 4503599627370496 >>> 0, buf, pos + off0);
              writeUint((sign << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf, pos + off1);
            }
          }
        }
        exports3.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);
        exports3.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);
        function readDouble_ieee754(readUint, off0, off1, buf, pos) {
          var lo = readUint(buf, pos + off0), hi = readUint(buf, pos + off1);
          var sign = (hi >> 31) * 2 + 1, exponent = hi >>> 20 & 2047, mantissa = 4294967296 * (hi & 1048575) + lo;
          return exponent === 2047 ? mantissa ? NaN : sign * Infinity : exponent === 0 ? sign * 5e-324 * mantissa : sign * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);
        }
        exports3.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);
        exports3.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);
      })();
      return exports3;
    }
    function writeUintLE(val, buf, pos) {
      buf[pos] = val & 255;
      buf[pos + 1] = val >>> 8 & 255;
      buf[pos + 2] = val >>> 16 & 255;
      buf[pos + 3] = val >>> 24;
    }
    function writeUintBE(val, buf, pos) {
      buf[pos] = val >>> 24;
      buf[pos + 1] = val >>> 16 & 255;
      buf[pos + 2] = val >>> 8 & 255;
      buf[pos + 3] = val & 255;
    }
    function readUintLE(buf, pos) {
      return (buf[pos] | buf[pos + 1] << 8 | buf[pos + 2] << 16 | buf[pos + 3] << 24) >>> 0;
    }
    function readUintBE(buf, pos) {
      return (buf[pos] << 24 | buf[pos + 1] << 16 | buf[pos + 2] << 8 | buf[pos + 3]) >>> 0;
    }
  }
});

// node_modules/@protobufjs/inquire/index.js
var require_inquire = __commonJS({
  "node_modules/@protobufjs/inquire/index.js"(exports, module) {
    "use strict";
    module.exports = inquire;
    function inquire(moduleName) {
      try {
        var mod = eval("quire".replace(/^/, "re"))(moduleName);
        if (mod && (mod.length || Object.keys(mod).length))
          return mod;
      } catch (e2) {
      }
      return null;
    }
  }
});

// node_modules/@protobufjs/utf8/index.js
var require_utf8 = __commonJS({
  "node_modules/@protobufjs/utf8/index.js"(exports2) {
    "use strict";
    var utf8 = exports2;
    utf8.length = function utf8_length(string) {
      var len = 0, c2 = 0;
      for (var i = 0; i < string.length; ++i) {
        c2 = string.charCodeAt(i);
        if (c2 < 128)
          len += 1;
        else if (c2 < 2048)
          len += 2;
        else if ((c2 & 64512) === 55296 && (string.charCodeAt(i + 1) & 64512) === 56320) {
          ++i;
          len += 4;
        } else
          len += 3;
      }
      return len;
    };
    utf8.read = function utf8_read(buffer2, start, end) {
      var len = end - start;
      if (len < 1)
        return "";
      var parts = null, chunk = [], i = 0, t2;
      while (start < end) {
        t2 = buffer2[start++];
        if (t2 < 128)
          chunk[i++] = t2;
        else if (t2 > 191 && t2 < 224)
          chunk[i++] = (t2 & 31) << 6 | buffer2[start++] & 63;
        else if (t2 > 239 && t2 < 365) {
          t2 = ((t2 & 7) << 18 | (buffer2[start++] & 63) << 12 | (buffer2[start++] & 63) << 6 | buffer2[start++] & 63) - 65536;
          chunk[i++] = 55296 + (t2 >> 10);
          chunk[i++] = 56320 + (t2 & 1023);
        } else
          chunk[i++] = (t2 & 15) << 12 | (buffer2[start++] & 63) << 6 | buffer2[start++] & 63;
        if (i > 8191) {
          (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
          i = 0;
        }
      }
      if (parts) {
        if (i)
          parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
        return parts.join("");
      }
      return String.fromCharCode.apply(String, chunk.slice(0, i));
    };
    utf8.write = function utf8_write(string, buffer2, offset) {
      var start = offset, c1, c2;
      for (var i = 0; i < string.length; ++i) {
        c1 = string.charCodeAt(i);
        if (c1 < 128) {
          buffer2[offset++] = c1;
        } else if (c1 < 2048) {
          buffer2[offset++] = c1 >> 6 | 192;
          buffer2[offset++] = c1 & 63 | 128;
        } else if ((c1 & 64512) === 55296 && ((c2 = string.charCodeAt(i + 1)) & 64512) === 56320) {
          c1 = 65536 + ((c1 & 1023) << 10) + (c2 & 1023);
          ++i;
          buffer2[offset++] = c1 >> 18 | 240;
          buffer2[offset++] = c1 >> 12 & 63 | 128;
          buffer2[offset++] = c1 >> 6 & 63 | 128;
          buffer2[offset++] = c1 & 63 | 128;
        } else {
          buffer2[offset++] = c1 >> 12 | 224;
          buffer2[offset++] = c1 >> 6 & 63 | 128;
          buffer2[offset++] = c1 & 63 | 128;
        }
      }
      return offset - start;
    };
  }
});

// node_modules/@protobufjs/pool/index.js
var require_pool = __commonJS({
  "node_modules/@protobufjs/pool/index.js"(exports2, module2) {
    "use strict";
    module2.exports = pool;
    function pool(alloc, slice, size) {
      var SIZE = size || 8192;
      var MAX = SIZE >>> 1;
      var slab = null;
      var offset = SIZE;
      return function pool_alloc(size2) {
        if (size2 < 1 || size2 > MAX)
          return alloc(size2);
        if (offset + size2 > SIZE) {
          slab = alloc(SIZE);
          offset = 0;
        }
        var buf = slice.call(slab, offset, offset += size2);
        if (offset & 7)
          offset = (offset | 7) + 1;
        return buf;
      };
    }
  }
});

// node_modules/protobufjs/src/util/longbits.js
var require_longbits = __commonJS({
  "node_modules/protobufjs/src/util/longbits.js"(exports2, module2) {
    "use strict";
    module2.exports = LongBits;
    var util = require_minimal();
    function LongBits(lo, hi) {
      this.lo = lo >>> 0;
      this.hi = hi >>> 0;
    }
    var zero = LongBits.zero = new LongBits(0, 0);
    zero.toNumber = function() {
      return 0;
    };
    zero.zzEncode = zero.zzDecode = function() {
      return this;
    };
    zero.length = function() {
      return 1;
    };
    var zeroHash = LongBits.zeroHash = "\0\0\0\0\0\0\0\0";
    LongBits.fromNumber = function fromNumber(value) {
      if (value === 0)
        return zero;
      var sign = value < 0;
      if (sign)
        value = -value;
      var lo = value >>> 0, hi = (value - lo) / 4294967296 >>> 0;
      if (sign) {
        hi = ~hi >>> 0;
        lo = ~lo >>> 0;
        if (++lo > 4294967295) {
          lo = 0;
          if (++hi > 4294967295)
            hi = 0;
        }
      }
      return new LongBits(lo, hi);
    };
    LongBits.from = function from2(value) {
      if (typeof value === "number")
        return LongBits.fromNumber(value);
      if (util.isString(value)) {
        if (util.Long)
          value = util.Long.fromString(value);
        else
          return LongBits.fromNumber(parseInt(value, 10));
      }
      return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;
    };
    LongBits.prototype.toNumber = function toNumber(unsigned) {
      if (!unsigned && this.hi >>> 31) {
        var lo = ~this.lo + 1 >>> 0, hi = ~this.hi >>> 0;
        if (!lo)
          hi = hi + 1 >>> 0;
        return -(lo + hi * 4294967296);
      }
      return this.lo + this.hi * 4294967296;
    };
    LongBits.prototype.toLong = function toLong(unsigned) {
      return util.Long ? new util.Long(this.lo | 0, this.hi | 0, Boolean(unsigned)) : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };
    };
    var charCodeAt = String.prototype.charCodeAt;
    LongBits.fromHash = function fromHash(hash) {
      if (hash === zeroHash)
        return zero;
      return new LongBits(
        (charCodeAt.call(hash, 0) | charCodeAt.call(hash, 1) << 8 | charCodeAt.call(hash, 2) << 16 | charCodeAt.call(hash, 3) << 24) >>> 0,
        (charCodeAt.call(hash, 4) | charCodeAt.call(hash, 5) << 8 | charCodeAt.call(hash, 6) << 16 | charCodeAt.call(hash, 7) << 24) >>> 0
      );
    };
    LongBits.prototype.toHash = function toHash() {
      return String.fromCharCode(
        this.lo & 255,
        this.lo >>> 8 & 255,
        this.lo >>> 16 & 255,
        this.lo >>> 24,
        this.hi & 255,
        this.hi >>> 8 & 255,
        this.hi >>> 16 & 255,
        this.hi >>> 24
      );
    };
    LongBits.prototype.zzEncode = function zzEncode() {
      var mask = this.hi >> 31;
      this.hi = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;
      this.lo = (this.lo << 1 ^ mask) >>> 0;
      return this;
    };
    LongBits.prototype.zzDecode = function zzDecode() {
      var mask = -(this.lo & 1);
      this.lo = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;
      this.hi = (this.hi >>> 1 ^ mask) >>> 0;
      return this;
    };
    LongBits.prototype.length = function length() {
      var part0 = this.lo, part1 = (this.lo >>> 28 | this.hi << 4) >>> 0, part2 = this.hi >>> 24;
      return part2 === 0 ? part1 === 0 ? part0 < 16384 ? part0 < 128 ? 1 : 2 : part0 < 2097152 ? 3 : 4 : part1 < 16384 ? part1 < 128 ? 5 : 6 : part1 < 2097152 ? 7 : 8 : part2 < 128 ? 9 : 10;
    };
  }
});

// node_modules/protobufjs/src/util/minimal.js
var require_minimal = __commonJS({
  "node_modules/protobufjs/src/util/minimal.js"(exports2) {
    "use strict";
    var util = exports2;
    util.asPromise = require_aspromise();
    util.base64 = require_base64();
    util.EventEmitter = require_eventemitter();
    util.float = require_float();
    util.inquire = require_inquire();
    util.utf8 = require_utf8();
    util.pool = require_pool();
    util.LongBits = require_longbits();
    util.isNode = Boolean(typeof global !== "undefined" && global && global.process && global.process.versions && global.process.versions.node);
    util.global = util.isNode && global || typeof window !== "undefined" && window || typeof self !== "undefined" && self || exports2;
    util.emptyArray = Object.freeze ? Object.freeze([]) : (
      /* istanbul ignore next */
      []
    );
    util.emptyObject = Object.freeze ? Object.freeze({}) : (
      /* istanbul ignore next */
      {}
    );
    util.isInteger = Number.isInteger || /* istanbul ignore next */
    function isInteger(value) {
      return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
    };
    util.isString = function isString2(value) {
      return typeof value === "string" || value instanceof String;
    };
    util.isObject = function isObject(value) {
      return value && typeof value === "object";
    };
    util.isset = /**
     * Checks if a property on a message is considered to be present.
     * @param {Object} obj Plain object or message instance
     * @param {string} prop Property name
     * @returns {boolean} `true` if considered to be present, otherwise `false`
     */
    util.isSet = function isSet(obj, prop) {
      var value = obj[prop];
      if (value != null && obj.hasOwnProperty(prop))
        return typeof value !== "object" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;
      return false;
    };
    util.Buffer = function() {
      try {
        var Buffer = util.inquire("buffer").Buffer;
        return Buffer.prototype.utf8Write ? Buffer : (
          /* istanbul ignore next */
          null
        );
      } catch (e2) {
        return null;
      }
    }();
    util._Buffer_from = null;
    util._Buffer_allocUnsafe = null;
    util.newBuffer = function newBuffer(sizeOrArray) {
      return typeof sizeOrArray === "number" ? util.Buffer ? util._Buffer_allocUnsafe(sizeOrArray) : new util.Array(sizeOrArray) : util.Buffer ? util._Buffer_from(sizeOrArray) : typeof Uint8Array === "undefined" ? sizeOrArray : new Uint8Array(sizeOrArray);
    };
    util.Array = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    util.Long = /* istanbul ignore next */
    util.global.dcodeIO && /* istanbul ignore next */
    util.global.dcodeIO.Long || /* istanbul ignore next */
    util.global.Long || util.inquire("long");
    util.key2Re = /^true|false|0|1$/;
    util.key32Re = /^-?(?:0|[1-9][0-9]*)$/;
    util.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;
    util.longToHash = function longToHash(value) {
      return value ? util.LongBits.from(value).toHash() : util.LongBits.zeroHash;
    };
    util.longFromHash = function longFromHash(hash, unsigned) {
      var bits = util.LongBits.fromHash(hash);
      if (util.Long)
        return util.Long.fromBits(bits.lo, bits.hi, unsigned);
      return bits.toNumber(Boolean(unsigned));
    };
    function merge3(dst, src, ifNotSet) {
      for (var keys = Object.keys(src), i = 0; i < keys.length; ++i)
        if (dst[keys[i]] === void 0 || !ifNotSet)
          dst[keys[i]] = src[keys[i]];
      return dst;
    }
    util.merge = merge3;
    util.lcFirst = function lcFirst(str) {
      return str.charAt(0).toLowerCase() + str.substring(1);
    };
    function newError(name) {
      function CustomError(message, properties) {
        if (!(this instanceof CustomError))
          return new CustomError(message, properties);
        Object.defineProperty(this, "message", { get: function() {
          return message;
        } });
        if (Error.captureStackTrace)
          Error.captureStackTrace(this, CustomError);
        else
          Object.defineProperty(this, "stack", { value: new Error().stack || "" });
        if (properties)
          merge3(this, properties);
      }
      (CustomError.prototype = Object.create(Error.prototype)).constructor = CustomError;
      Object.defineProperty(CustomError.prototype, "name", { get: function() {
        return name;
      } });
      CustomError.prototype.toString = function toString() {
        return this.name + ": " + this.message;
      };
      return CustomError;
    }
    util.newError = newError;
    util.ProtocolError = newError("ProtocolError");
    util.oneOfGetter = function getOneOf(fieldNames) {
      var fieldMap = {};
      for (var i = 0; i < fieldNames.length; ++i)
        fieldMap[fieldNames[i]] = 1;
      return function() {
        for (var keys = Object.keys(this), i2 = keys.length - 1; i2 > -1; --i2)
          if (fieldMap[keys[i2]] === 1 && this[keys[i2]] !== void 0 && this[keys[i2]] !== null)
            return keys[i2];
      };
    };
    util.oneOfSetter = function setOneOf(fieldNames) {
      return function(name) {
        for (var i = 0; i < fieldNames.length; ++i)
          if (fieldNames[i] !== name)
            delete this[fieldNames[i]];
      };
    };
    util.toJSONOptions = {
      longs: String,
      enums: String,
      bytes: String,
      json: true
    };
    util._configure = function() {
      var Buffer = util.Buffer;
      if (!Buffer) {
        util._Buffer_from = util._Buffer_allocUnsafe = null;
        return;
      }
      util._Buffer_from = Buffer.from !== Uint8Array.from && Buffer.from || /* istanbul ignore next */
      function Buffer_from(value, encoding) {
        return new Buffer(value, encoding);
      };
      util._Buffer_allocUnsafe = Buffer.allocUnsafe || /* istanbul ignore next */
      function Buffer_allocUnsafe(size) {
        return new Buffer(size);
      };
    };
  }
});

// node_modules/protobufjs/src/writer.js
var require_writer = __commonJS({
  "node_modules/protobufjs/src/writer.js"(exports2, module2) {
    "use strict";
    module2.exports = Writer2;
    var util = require_minimal();
    var BufferWriter;
    var LongBits = util.LongBits;
    var base64 = util.base64;
    var utf8 = util.utf8;
    function Op(fn, len, val) {
      this.fn = fn;
      this.len = len;
      this.next = void 0;
      this.val = val;
    }
    function noop2() {
    }
    function State(writer) {
      this.head = writer.head;
      this.tail = writer.tail;
      this.len = writer.len;
      this.next = writer.states;
    }
    function Writer2() {
      this.len = 0;
      this.head = new Op(noop2, 0, 0);
      this.tail = this.head;
      this.states = null;
    }
    var create = function create2() {
      return util.Buffer ? function create_buffer_setup() {
        return (Writer2.create = function create_buffer() {
          return new BufferWriter();
        })();
      } : function create_array() {
        return new Writer2();
      };
    };
    Writer2.create = create();
    Writer2.alloc = function alloc(size) {
      return new util.Array(size);
    };
    if (util.Array !== Array)
      Writer2.alloc = util.pool(Writer2.alloc, util.Array.prototype.subarray);
    Writer2.prototype._push = function push(fn, len, val) {
      this.tail = this.tail.next = new Op(fn, len, val);
      this.len += len;
      return this;
    };
    function writeByte(val, buf, pos) {
      buf[pos] = val & 255;
    }
    function writeVarint32(val, buf, pos) {
      while (val > 127) {
        buf[pos++] = val & 127 | 128;
        val >>>= 7;
      }
      buf[pos] = val;
    }
    function VarintOp(len, val) {
      this.len = len;
      this.next = void 0;
      this.val = val;
    }
    VarintOp.prototype = Object.create(Op.prototype);
    VarintOp.prototype.fn = writeVarint32;
    Writer2.prototype.uint32 = function write_uint32(value) {
      this.len += (this.tail = this.tail.next = new VarintOp(
        (value = value >>> 0) < 128 ? 1 : value < 16384 ? 2 : value < 2097152 ? 3 : value < 268435456 ? 4 : 5,
        value
      )).len;
      return this;
    };
    Writer2.prototype.int32 = function write_int32(value) {
      return value < 0 ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) : this.uint32(value);
    };
    Writer2.prototype.sint32 = function write_sint32(value) {
      return this.uint32((value << 1 ^ value >> 31) >>> 0);
    };
    function writeVarint64(val, buf, pos) {
      while (val.hi) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;
        val.hi >>>= 7;
      }
      while (val.lo > 127) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = val.lo >>> 7;
      }
      buf[pos++] = val.lo;
    }
    Writer2.prototype.uint64 = function write_uint64(value) {
      var bits = LongBits.from(value);
      return this._push(writeVarint64, bits.length(), bits);
    };
    Writer2.prototype.int64 = Writer2.prototype.uint64;
    Writer2.prototype.sint64 = function write_sint64(value) {
      var bits = LongBits.from(value).zzEncode();
      return this._push(writeVarint64, bits.length(), bits);
    };
    Writer2.prototype.bool = function write_bool(value) {
      return this._push(writeByte, 1, value ? 1 : 0);
    };
    function writeFixed32(val, buf, pos) {
      buf[pos] = val & 255;
      buf[pos + 1] = val >>> 8 & 255;
      buf[pos + 2] = val >>> 16 & 255;
      buf[pos + 3] = val >>> 24;
    }
    Writer2.prototype.fixed32 = function write_fixed32(value) {
      return this._push(writeFixed32, 4, value >>> 0);
    };
    Writer2.prototype.sfixed32 = Writer2.prototype.fixed32;
    Writer2.prototype.fixed64 = function write_fixed64(value) {
      var bits = LongBits.from(value);
      return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);
    };
    Writer2.prototype.sfixed64 = Writer2.prototype.fixed64;
    Writer2.prototype.float = function write_float(value) {
      return this._push(util.float.writeFloatLE, 4, value);
    };
    Writer2.prototype.double = function write_double(value) {
      return this._push(util.float.writeDoubleLE, 8, value);
    };
    var writeBytes = util.Array.prototype.set ? function writeBytes_set(val, buf, pos) {
      buf.set(val, pos);
    } : function writeBytes_for(val, buf, pos) {
      for (var i = 0; i < val.length; ++i)
        buf[pos + i] = val[i];
    };
    Writer2.prototype.bytes = function write_bytes(value) {
      var len = value.length >>> 0;
      if (!len)
        return this._push(writeByte, 1, 0);
      if (util.isString(value)) {
        var buf = Writer2.alloc(len = base64.length(value));
        base64.decode(value, buf, 0);
        value = buf;
      }
      return this.uint32(len)._push(writeBytes, len, value);
    };
    Writer2.prototype.string = function write_string(value) {
      var len = utf8.length(value);
      return len ? this.uint32(len)._push(utf8.write, len, value) : this._push(writeByte, 1, 0);
    };
    Writer2.prototype.fork = function fork() {
      this.states = new State(this);
      this.head = this.tail = new Op(noop2, 0, 0);
      this.len = 0;
      return this;
    };
    Writer2.prototype.reset = function reset() {
      if (this.states) {
        this.head = this.states.head;
        this.tail = this.states.tail;
        this.len = this.states.len;
        this.states = this.states.next;
      } else {
        this.head = this.tail = new Op(noop2, 0, 0);
        this.len = 0;
      }
      return this;
    };
    Writer2.prototype.ldelim = function ldelim() {
      var head = this.head, tail = this.tail, len = this.len;
      this.reset().uint32(len);
      if (len) {
        this.tail.next = head.next;
        this.tail = tail;
        this.len += len;
      }
      return this;
    };
    Writer2.prototype.finish = function finish() {
      var head = this.head.next, buf = this.constructor.alloc(this.len), pos = 0;
      while (head) {
        head.fn(head.val, buf, pos);
        pos += head.len;
        head = head.next;
      }
      return buf;
    };
    Writer2._configure = function(BufferWriter_) {
      BufferWriter = BufferWriter_;
      Writer2.create = create();
      BufferWriter._configure();
    };
  }
});

// node_modules/protobufjs/src/writer_buffer.js
var require_writer_buffer = __commonJS({
  "node_modules/protobufjs/src/writer_buffer.js"(exports2, module2) {
    "use strict";
    module2.exports = BufferWriter;
    var Writer2 = require_writer();
    (BufferWriter.prototype = Object.create(Writer2.prototype)).constructor = BufferWriter;
    var util = require_minimal();
    function BufferWriter() {
      Writer2.call(this);
    }
    BufferWriter._configure = function() {
      BufferWriter.alloc = util._Buffer_allocUnsafe;
      BufferWriter.writeBytesBuffer = util.Buffer && util.Buffer.prototype instanceof Uint8Array && util.Buffer.prototype.set.name === "set" ? function writeBytesBuffer_set(val, buf, pos) {
        buf.set(val, pos);
      } : function writeBytesBuffer_copy(val, buf, pos) {
        if (val.copy)
          val.copy(buf, pos, 0, val.length);
        else for (var i = 0; i < val.length; )
          buf[pos++] = val[i++];
      };
    };
    BufferWriter.prototype.bytes = function write_bytes_buffer(value) {
      if (util.isString(value))
        value = util._Buffer_from(value, "base64");
      var len = value.length >>> 0;
      this.uint32(len);
      if (len)
        this._push(BufferWriter.writeBytesBuffer, len, value);
      return this;
    };
    function writeStringBuffer(val, buf, pos) {
      if (val.length < 40)
        util.utf8.write(val, buf, pos);
      else if (buf.utf8Write)
        buf.utf8Write(val, pos);
      else
        buf.write(val, pos);
    }
    BufferWriter.prototype.string = function write_string_buffer(value) {
      var len = util.Buffer.byteLength(value);
      this.uint32(len);
      if (len)
        this._push(writeStringBuffer, len, value);
      return this;
    };
    BufferWriter._configure();
  }
});

// node_modules/protobufjs/src/reader.js
var require_reader = __commonJS({
  "node_modules/protobufjs/src/reader.js"(exports2, module2) {
    "use strict";
    module2.exports = Reader;
    var util = require_minimal();
    var BufferReader;
    var LongBits = util.LongBits;
    var utf8 = util.utf8;
    function indexOutOfRange(reader, writeLength) {
      return RangeError("index out of range: " + reader.pos + " + " + (writeLength || 1) + " > " + reader.len);
    }
    function Reader(buffer2) {
      this.buf = buffer2;
      this.pos = 0;
      this.len = buffer2.length;
    }
    var create_array = typeof Uint8Array !== "undefined" ? function create_typed_array(buffer2) {
      if (buffer2 instanceof Uint8Array || Array.isArray(buffer2))
        return new Reader(buffer2);
      throw Error("illegal buffer");
    } : function create_array2(buffer2) {
      if (Array.isArray(buffer2))
        return new Reader(buffer2);
      throw Error("illegal buffer");
    };
    var create = function create2() {
      return util.Buffer ? function create_buffer_setup(buffer2) {
        return (Reader.create = function create_buffer(buffer3) {
          return util.Buffer.isBuffer(buffer3) ? new BufferReader(buffer3) : create_array(buffer3);
        })(buffer2);
      } : create_array;
    };
    Reader.create = create();
    Reader.prototype._slice = util.Array.prototype.subarray || /* istanbul ignore next */
    util.Array.prototype.slice;
    Reader.prototype.uint32 = /* @__PURE__ */ function read_uint32_setup() {
      var value = 4294967295;
      return function read_uint32() {
        value = (this.buf[this.pos] & 127) >>> 0;
        if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) << 7) >>> 0;
        if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) << 14) >>> 0;
        if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) << 21) >>> 0;
        if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 15) << 28) >>> 0;
        if (this.buf[this.pos++] < 128) return value;
        if ((this.pos += 5) > this.len) {
          this.pos = this.len;
          throw indexOutOfRange(this, 10);
        }
        return value;
      };
    }();
    Reader.prototype.int32 = function read_int32() {
      return this.uint32() | 0;
    };
    Reader.prototype.sint32 = function read_sint32() {
      var value = this.uint32();
      return value >>> 1 ^ -(value & 1) | 0;
    };
    function readLongVarint() {
      var bits = new LongBits(0, 0);
      var i = 0;
      if (this.len - this.pos > 4) {
        for (; i < 4; ++i) {
          bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;
        bits.hi = (bits.hi | (this.buf[this.pos] & 127) >> 4) >>> 0;
        if (this.buf[this.pos++] < 128)
          return bits;
        i = 0;
      } else {
        for (; i < 3; ++i) {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
          bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
        bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;
        return bits;
      }
      if (this.len - this.pos > 4) {
        for (; i < 5; ++i) {
          bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
      } else {
        for (; i < 5; ++i) {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
          bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
      }
      throw Error("invalid varint encoding");
    }
    Reader.prototype.bool = function read_bool() {
      return this.uint32() !== 0;
    };
    function readFixed32_end(buf, end) {
      return (buf[end - 4] | buf[end - 3] << 8 | buf[end - 2] << 16 | buf[end - 1] << 24) >>> 0;
    }
    Reader.prototype.fixed32 = function read_fixed32() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      return readFixed32_end(this.buf, this.pos += 4);
    };
    Reader.prototype.sfixed32 = function read_sfixed32() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      return readFixed32_end(this.buf, this.pos += 4) | 0;
    };
    function readFixed64() {
      if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 8);
      return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));
    }
    Reader.prototype.float = function read_float() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      var value = util.float.readFloatLE(this.buf, this.pos);
      this.pos += 4;
      return value;
    };
    Reader.prototype.double = function read_double() {
      if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 4);
      var value = util.float.readDoubleLE(this.buf, this.pos);
      this.pos += 8;
      return value;
    };
    Reader.prototype.bytes = function read_bytes() {
      var length = this.uint32(), start = this.pos, end = this.pos + length;
      if (end > this.len)
        throw indexOutOfRange(this, length);
      this.pos += length;
      if (Array.isArray(this.buf))
        return this.buf.slice(start, end);
      return start === end ? new this.buf.constructor(0) : this._slice.call(this.buf, start, end);
    };
    Reader.prototype.string = function read_string() {
      var bytes = this.bytes();
      return utf8.read(bytes, 0, bytes.length);
    };
    Reader.prototype.skip = function skip2(length) {
      if (typeof length === "number") {
        if (this.pos + length > this.len)
          throw indexOutOfRange(this, length);
        this.pos += length;
      } else {
        do {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
        } while (this.buf[this.pos++] & 128);
      }
      return this;
    };
    Reader.prototype.skipType = function(wireType) {
      switch (wireType) {
        case 0:
          this.skip();
          break;
        case 1:
          this.skip(8);
          break;
        case 2:
          this.skip(this.uint32());
          break;
        case 3:
          while ((wireType = this.uint32() & 7) !== 4) {
            this.skipType(wireType);
          }
          break;
        case 5:
          this.skip(4);
          break;
        default:
          throw Error("invalid wire type " + wireType + " at offset " + this.pos);
      }
      return this;
    };
    Reader._configure = function(BufferReader_) {
      BufferReader = BufferReader_;
      Reader.create = create();
      BufferReader._configure();
      var fn = util.Long ? "toLong" : (
        /* istanbul ignore next */
        "toNumber"
      );
      util.merge(Reader.prototype, {
        int64: function read_int64() {
          return readLongVarint.call(this)[fn](false);
        },
        uint64: function read_uint64() {
          return readLongVarint.call(this)[fn](true);
        },
        sint64: function read_sint64() {
          return readLongVarint.call(this).zzDecode()[fn](false);
        },
        fixed64: function read_fixed64() {
          return readFixed64.call(this)[fn](true);
        },
        sfixed64: function read_sfixed64() {
          return readFixed64.call(this)[fn](false);
        }
      });
    };
  }
});

// node_modules/protobufjs/src/reader_buffer.js
var require_reader_buffer = __commonJS({
  "node_modules/protobufjs/src/reader_buffer.js"(exports2, module2) {
    "use strict";
    module2.exports = BufferReader;
    var Reader = require_reader();
    (BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;
    var util = require_minimal();
    function BufferReader(buffer2) {
      Reader.call(this, buffer2);
    }
    BufferReader._configure = function() {
      if (util.Buffer)
        BufferReader.prototype._slice = util.Buffer.prototype.slice;
    };
    BufferReader.prototype.string = function read_string_buffer() {
      var len = this.uint32();
      return this.buf.utf8Slice ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len)) : this.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + len, this.len));
    };
    BufferReader._configure();
  }
});

// node_modules/protobufjs/src/rpc/service.js
var require_service = __commonJS({
  "node_modules/protobufjs/src/rpc/service.js"(exports2, module2) {
    "use strict";
    module2.exports = Service;
    var util = require_minimal();
    (Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;
    function Service(rpcImpl, requestDelimited, responseDelimited) {
      if (typeof rpcImpl !== "function")
        throw TypeError("rpcImpl must be a function");
      util.EventEmitter.call(this);
      this.rpcImpl = rpcImpl;
      this.requestDelimited = Boolean(requestDelimited);
      this.responseDelimited = Boolean(responseDelimited);
    }
    Service.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {
      if (!request)
        throw TypeError("request must be specified");
      var self2 = this;
      if (!callback)
        return util.asPromise(rpcCall, self2, method, requestCtor, responseCtor, request);
      if (!self2.rpcImpl) {
        setTimeout(function() {
          callback(Error("already ended"));
        }, 0);
        return void 0;
      }
      try {
        return self2.rpcImpl(
          method,
          requestCtor[self2.requestDelimited ? "encodeDelimited" : "encode"](request).finish(),
          function rpcCallback(err, response) {
            if (err) {
              self2.emit("error", err, method);
              return callback(err);
            }
            if (response === null) {
              self2.end(
                /* endedByRPC */
                true
              );
              return void 0;
            }
            if (!(response instanceof responseCtor)) {
              try {
                response = responseCtor[self2.responseDelimited ? "decodeDelimited" : "decode"](response);
              } catch (err2) {
                self2.emit("error", err2, method);
                return callback(err2);
              }
            }
            self2.emit("data", response, method);
            return callback(null, response);
          }
        );
      } catch (err) {
        self2.emit("error", err, method);
        setTimeout(function() {
          callback(err);
        }, 0);
        return void 0;
      }
    };
    Service.prototype.end = function end(endedByRPC) {
      if (this.rpcImpl) {
        if (!endedByRPC)
          this.rpcImpl(null, null, null);
        this.rpcImpl = null;
        this.emit("end").off();
      }
      return this;
    };
  }
});

// node_modules/protobufjs/src/rpc.js
var require_rpc = __commonJS({
  "node_modules/protobufjs/src/rpc.js"(exports2) {
    "use strict";
    var rpc = exports2;
    rpc.Service = require_service();
  }
});

// node_modules/protobufjs/src/roots.js
var require_roots = __commonJS({
  "node_modules/protobufjs/src/roots.js"(exports2, module2) {
    "use strict";
    module2.exports = {};
  }
});

// node_modules/protobufjs/src/index-minimal.js
var require_index_minimal = __commonJS({
  "node_modules/protobufjs/src/index-minimal.js"(exports2) {
    "use strict";
    var protobuf = exports2;
    protobuf.build = "minimal";
    protobuf.Writer = require_writer();
    protobuf.BufferWriter = require_writer_buffer();
    protobuf.Reader = require_reader();
    protobuf.BufferReader = require_reader_buffer();
    protobuf.util = require_minimal();
    protobuf.rpc = require_rpc();
    protobuf.roots = require_roots();
    protobuf.configure = configure;
    function configure() {
      protobuf.util._configure();
      protobuf.Writer._configure(protobuf.BufferWriter);
      protobuf.Reader._configure(protobuf.BufferReader);
    }
    configure();
  }
});

// node_modules/protobufjs/minimal.js
var require_minimal2 = __commonJS({
  "node_modules/protobufjs/minimal.js"(exports2, module2) {
    "use strict";
    module2.exports = require_index_minimal();
  }
});

// node_modules/@improbable-eng/grpc-web/dist/grpc-web-client.umd.js
var require_grpc_web_client_umd = __commonJS({
  "node_modules/@improbable-eng/grpc-web/dist/grpc-web-client.umd.js"(exports2, module2) {
    !function(e2, t2) {
      if ("object" == typeof exports2 && "object" == typeof module2) module2.exports = t2();
      else if ("function" == typeof define && define.amd) define([], t2);
      else {
        var r2 = t2();
        for (var n2 in r2) ("object" == typeof exports2 ? exports2 : e2)[n2] = r2[n2];
      }
    }(exports2, function() {
      return e2 = { 418: function(e3, t3) {
        !function(e4, t4) {
          for (var r2 in t4) e4[r2] = t4[r2];
        }(t3, function(e4) {
          var t4 = {};
          function r2(n2) {
            if (t4[n2]) return t4[n2].exports;
            var o = t4[n2] = { i: n2, l: false, exports: {} };
            return e4[n2].call(o.exports, o, o.exports, r2), o.l = true, o.exports;
          }
          return r2.m = e4, r2.c = t4, r2.i = function(e5) {
            return e5;
          }, r2.d = function(e5, t5, n2) {
            r2.o(e5, t5) || Object.defineProperty(e5, t5, { configurable: false, enumerable: true, get: n2 });
          }, r2.n = function(e5) {
            var t5 = e5 && e5.__esModule ? function() {
              return e5.default;
            } : function() {
              return e5;
            };
            return r2.d(t5, "a", t5), t5;
          }, r2.o = function(e5, t5) {
            return Object.prototype.hasOwnProperty.call(e5, t5);
          }, r2.p = "", r2(r2.s = 1);
        }([function(e4, t4, r2) {
          "use strict";
          Object.defineProperty(t4, "__esModule", { value: true });
          var n2 = r2(3), o = function() {
            function e5(e6, t5) {
              void 0 === e6 && (e6 = {}), void 0 === t5 && (t5 = { splitValues: false });
              var r3, o2 = this;
              this.headersMap = {}, e6 && ("undefined" != typeof Headers && e6 instanceof Headers ? n2.getHeaderKeys(e6).forEach(function(r4) {
                n2.getHeaderValues(e6, r4).forEach(function(e7) {
                  t5.splitValues ? o2.append(r4, n2.splitHeaderValue(e7)) : o2.append(r4, e7);
                });
              }) : "object" == typeof (r3 = e6) && "object" == typeof r3.headersMap && "function" == typeof r3.forEach ? e6.forEach(function(e7, t6) {
                o2.append(e7, t6);
              }) : "undefined" != typeof Map && e6 instanceof Map ? e6.forEach(function(e7, t6) {
                o2.append(t6, e7);
              }) : "string" == typeof e6 ? this.appendFromString(e6) : "object" == typeof e6 && Object.getOwnPropertyNames(e6).forEach(function(t6) {
                var r4 = e6[t6];
                Array.isArray(r4) ? r4.forEach(function(e7) {
                  o2.append(t6, e7);
                }) : o2.append(t6, r4);
              }));
            }
            return e5.prototype.appendFromString = function(e6) {
              for (var t5 = e6.split("\r\n"), r3 = 0; r3 < t5.length; r3++) {
                var n3 = t5[r3], o2 = n3.indexOf(":");
                if (o2 > 0) {
                  var s2 = n3.substring(0, o2).trim(), i = n3.substring(o2 + 1).trim();
                  this.append(s2, i);
                }
              }
            }, e5.prototype.delete = function(e6, t5) {
              var r3 = n2.normalizeName(e6);
              if (void 0 === t5) delete this.headersMap[r3];
              else {
                var o2 = this.headersMap[r3];
                if (o2) {
                  var s2 = o2.indexOf(t5);
                  s2 >= 0 && o2.splice(s2, 1), 0 === o2.length && delete this.headersMap[r3];
                }
              }
            }, e5.prototype.append = function(e6, t5) {
              var r3 = this, o2 = n2.normalizeName(e6);
              Array.isArray(this.headersMap[o2]) || (this.headersMap[o2] = []), Array.isArray(t5) ? t5.forEach(function(e7) {
                r3.headersMap[o2].push(n2.normalizeValue(e7));
              }) : this.headersMap[o2].push(n2.normalizeValue(t5));
            }, e5.prototype.set = function(e6, t5) {
              var r3 = n2.normalizeName(e6);
              if (Array.isArray(t5)) {
                var o2 = [];
                t5.forEach(function(e7) {
                  o2.push(n2.normalizeValue(e7));
                }), this.headersMap[r3] = o2;
              } else this.headersMap[r3] = [n2.normalizeValue(t5)];
            }, e5.prototype.has = function(e6, t5) {
              var r3 = this.headersMap[n2.normalizeName(e6)];
              if (!Array.isArray(r3)) return false;
              if (void 0 !== t5) {
                var o2 = n2.normalizeValue(t5);
                return r3.indexOf(o2) >= 0;
              }
              return true;
            }, e5.prototype.get = function(e6) {
              var t5 = this.headersMap[n2.normalizeName(e6)];
              return void 0 !== t5 ? t5.concat() : [];
            }, e5.prototype.forEach = function(e6) {
              var t5 = this;
              Object.getOwnPropertyNames(this.headersMap).forEach(function(r3) {
                e6(r3, t5.headersMap[r3]);
              }, this);
            }, e5.prototype.toHeaders = function() {
              if ("undefined" != typeof Headers) {
                var e6 = new Headers();
                return this.forEach(function(t5, r3) {
                  r3.forEach(function(r4) {
                    e6.append(t5, r4);
                  });
                }), e6;
              }
              throw new Error("Headers class is not defined");
            }, e5;
          }();
          t4.BrowserHeaders = o;
        }, function(e4, t4, r2) {
          "use strict";
          Object.defineProperty(t4, "__esModule", { value: true });
          var n2 = r2(0);
          t4.BrowserHeaders = n2.BrowserHeaders;
        }, function(e4, t4, r2) {
          "use strict";
          Object.defineProperty(t4, "__esModule", { value: true }), t4.iterateHeaders = function(e5, t5) {
            for (var r3 = e5[Symbol.iterator](), n2 = r3.next(); !n2.done; ) t5(n2.value[0]), n2 = r3.next();
          }, t4.iterateHeadersKeys = function(e5, t5) {
            for (var r3 = e5.keys(), n2 = r3.next(); !n2.done; ) t5(n2.value), n2 = r3.next();
          };
        }, function(e4, t4, r2) {
          "use strict";
          Object.defineProperty(t4, "__esModule", { value: true });
          var n2 = r2(2);
          t4.normalizeName = function(e5) {
            if ("string" != typeof e5 && (e5 = String(e5)), /[^a-z0-9\-#$%&'*+.\^_`|~]/i.test(e5)) throw new TypeError("Invalid character in header field name");
            return e5.toLowerCase();
          }, t4.normalizeValue = function(e5) {
            return "string" != typeof e5 && (e5 = String(e5)), e5;
          }, t4.getHeaderValues = function(e5, t5) {
            var r3 = e5;
            if (r3 instanceof Headers && r3.getAll) return r3.getAll(t5);
            var n3 = r3.get(t5);
            return n3 && "string" == typeof n3 ? [n3] : n3;
          }, t4.getHeaderKeys = function(e5) {
            var t5 = e5, r3 = {}, o = [];
            return t5.keys ? n2.iterateHeadersKeys(t5, function(e6) {
              r3[e6] || (r3[e6] = true, o.push(e6));
            }) : t5.forEach ? t5.forEach(function(e6, t6) {
              r3[t6] || (r3[t6] = true, o.push(t6));
            }) : n2.iterateHeaders(t5, function(e6) {
              var t6 = e6[0];
              r3[t6] || (r3[t6] = true, o.push(t6));
            }), o;
          }, t4.splitHeaderValue = function(e5) {
            var t5 = [];
            return e5.split(", ").forEach(function(e6) {
              e6.split(",").forEach(function(e7) {
                t5.push(e7);
              });
            }), t5;
          };
        }]));
      }, 617: function(e3, t3, r2) {
        "use strict";
        Object.defineProperty(t3, "__esModule", { value: true }), t3.ChunkParser = t3.ChunkType = t3.encodeASCII = t3.decodeASCII = void 0;
        var n2, o = r2(65);
        function s2(e4) {
          return 9 === (t4 = e4) || 10 === t4 || 13 === t4 || e4 >= 32 && e4 <= 126;
          var t4;
        }
        function i(e4) {
          for (var t4 = 0; t4 !== e4.length; ++t4) if (!s2(e4[t4])) throw new Error("Metadata is not valid (printable) ASCII");
          return String.fromCharCode.apply(String, Array.prototype.slice.call(e4));
        }
        function a2(e4) {
          return 128 == (128 & e4.getUint8(0));
        }
        function u2(e4) {
          return e4.getUint32(1, false);
        }
        function d2(e4, t4, r3) {
          return e4.byteLength - t4 >= r3;
        }
        function c2(e4, t4, r3) {
          if (e4.slice) return e4.slice(t4, r3);
          var n3 = e4.length;
          void 0 !== r3 && (n3 = r3);
          for (var o2 = new Uint8Array(n3 - t4), s3 = 0, i2 = t4; i2 < n3; i2++) o2[s3++] = e4[i2];
          return o2;
        }
        t3.decodeASCII = i, t3.encodeASCII = function(e4) {
          for (var t4 = new Uint8Array(e4.length), r3 = 0; r3 !== e4.length; ++r3) {
            var n3 = e4.charCodeAt(r3);
            if (!s2(n3)) throw new Error("Metadata contains invalid ASCII");
            t4[r3] = n3;
          }
          return t4;
        }, function(e4) {
          e4[e4.MESSAGE = 1] = "MESSAGE", e4[e4.TRAILERS = 2] = "TRAILERS";
        }(n2 = t3.ChunkType || (t3.ChunkType = {}));
        var p2 = function() {
          function e4() {
            this.buffer = null, this.position = 0;
          }
          return e4.prototype.parse = function(e5, t4) {
            if (0 === e5.length && t4) return [];
            var r3, s3 = [];
            if (null == this.buffer) this.buffer = e5, this.position = 0;
            else if (this.position === this.buffer.byteLength) this.buffer = e5, this.position = 0;
            else {
              var p3 = this.buffer.byteLength - this.position, h2 = new Uint8Array(p3 + e5.byteLength), f3 = c2(this.buffer, this.position);
              h2.set(f3, 0);
              var l2 = new Uint8Array(e5);
              h2.set(l2, p3), this.buffer = h2, this.position = 0;
            }
            for (; ; ) {
              if (!d2(this.buffer, this.position, 5)) return s3;
              var g = c2(this.buffer, this.position, this.position + 5), b2 = new DataView(g.buffer, g.byteOffset, g.byteLength), y2 = u2(b2);
              if (!d2(this.buffer, this.position, 5 + y2)) return s3;
              var v2 = c2(this.buffer, this.position + 5, this.position + 5 + y2);
              if (this.position += 5 + y2, a2(b2)) return s3.push({ chunkType: n2.TRAILERS, trailers: (r3 = v2, new o.Metadata(i(r3))) }), s3;
              s3.push({ chunkType: n2.MESSAGE, data: v2 });
            }
          }, e4;
        }();
        t3.ChunkParser = p2;
      }, 8: function(e3, t3) {
        "use strict";
        var r2;
        Object.defineProperty(t3, "__esModule", { value: true }), t3.httpStatusToCode = t3.Code = void 0, function(e4) {
          e4[e4.OK = 0] = "OK", e4[e4.Canceled = 1] = "Canceled", e4[e4.Unknown = 2] = "Unknown", e4[e4.InvalidArgument = 3] = "InvalidArgument", e4[e4.DeadlineExceeded = 4] = "DeadlineExceeded", e4[e4.NotFound = 5] = "NotFound", e4[e4.AlreadyExists = 6] = "AlreadyExists", e4[e4.PermissionDenied = 7] = "PermissionDenied", e4[e4.ResourceExhausted = 8] = "ResourceExhausted", e4[e4.FailedPrecondition = 9] = "FailedPrecondition", e4[e4.Aborted = 10] = "Aborted", e4[e4.OutOfRange = 11] = "OutOfRange", e4[e4.Unimplemented = 12] = "Unimplemented", e4[e4.Internal = 13] = "Internal", e4[e4.Unavailable = 14] = "Unavailable", e4[e4.DataLoss = 15] = "DataLoss", e4[e4.Unauthenticated = 16] = "Unauthenticated";
        }(r2 = t3.Code || (t3.Code = {})), t3.httpStatusToCode = function(e4) {
          switch (e4) {
            case 0:
              return r2.Internal;
            case 200:
              return r2.OK;
            case 400:
              return r2.InvalidArgument;
            case 401:
              return r2.Unauthenticated;
            case 403:
              return r2.PermissionDenied;
            case 404:
              return r2.NotFound;
            case 409:
              return r2.Aborted;
            case 412:
              return r2.FailedPrecondition;
            case 429:
              return r2.ResourceExhausted;
            case 499:
              return r2.Canceled;
            case 500:
              return r2.Unknown;
            case 501:
              return r2.Unimplemented;
            case 503:
              return r2.Unavailable;
            case 504:
              return r2.DeadlineExceeded;
            default:
              return r2.Unknown;
          }
        };
      }, 934: function(e3, t3, r2) {
        "use strict";
        Object.defineProperty(t3, "__esModule", { value: true }), t3.client = void 0;
        var n2 = r2(65), o = r2(617), s2 = r2(8), i = r2(346), a2 = r2(57), u2 = r2(882);
        t3.client = function(e4, t4) {
          return new d2(e4, t4);
        };
        var d2 = function() {
          function e4(e5, t4) {
            this.started = false, this.sentFirstMessage = false, this.completed = false, this.closed = false, this.finishedSending = false, this.onHeadersCallbacks = [], this.onMessageCallbacks = [], this.onEndCallbacks = [], this.parser = new o.ChunkParser(), this.methodDefinition = e5, this.props = t4, this.createTransport();
          }
          return e4.prototype.createTransport = function() {
            var e5 = this.props.host + "/" + this.methodDefinition.service.serviceName + "/" + this.methodDefinition.methodName, t4 = { methodDefinition: this.methodDefinition, debug: this.props.debug || false, url: e5, onHeaders: this.onTransportHeaders.bind(this), onChunk: this.onTransportChunk.bind(this), onEnd: this.onTransportEnd.bind(this) };
            this.props.transport ? this.transport = this.props.transport(t4) : this.transport = a2.makeDefaultTransport(t4);
          }, e4.prototype.onTransportHeaders = function(e5, t4) {
            if (this.props.debug && i.debug("onHeaders", e5, t4), this.closed) this.props.debug && i.debug("grpc.onHeaders received after request was closed - ignoring");
            else if (0 === t4) ;
            else {
              this.responseHeaders = e5, this.props.debug && i.debug("onHeaders.responseHeaders", JSON.stringify(this.responseHeaders, null, 2));
              var r3 = c2(e5);
              this.props.debug && i.debug("onHeaders.gRPCStatus", r3);
              var n3 = r3 && r3 >= 0 ? r3 : s2.httpStatusToCode(t4);
              this.props.debug && i.debug("onHeaders.code", n3);
              var o2 = e5.get("grpc-message") || [];
              if (this.props.debug && i.debug("onHeaders.gRPCMessage", o2), this.rawOnHeaders(e5), n3 !== s2.Code.OK) {
                var a3 = this.decodeGRPCStatus(o2[0]);
                this.rawOnError(n3, a3, e5);
              }
            }
          }, e4.prototype.onTransportChunk = function(e5) {
            var t4 = this;
            if (this.closed) this.props.debug && i.debug("grpc.onChunk received after request was closed - ignoring");
            else {
              var r3 = [];
              try {
                r3 = this.parser.parse(e5);
              } catch (e6) {
                return this.props.debug && i.debug("onChunk.parsing error", e6, e6.message), void this.rawOnError(s2.Code.Internal, "parsing error: " + e6.message);
              }
              r3.forEach(function(e6) {
                if (e6.chunkType === o.ChunkType.MESSAGE) {
                  var r4 = t4.methodDefinition.responseType.deserializeBinary(e6.data);
                  t4.rawOnMessage(r4);
                } else e6.chunkType === o.ChunkType.TRAILERS && (t4.responseHeaders ? (t4.responseTrailers = new n2.Metadata(e6.trailers), t4.props.debug && i.debug("onChunk.trailers", t4.responseTrailers)) : (t4.responseHeaders = new n2.Metadata(e6.trailers), t4.rawOnHeaders(t4.responseHeaders)));
              });
            }
          }, e4.prototype.onTransportEnd = function() {
            if (this.props.debug && i.debug("grpc.onEnd"), this.closed) this.props.debug && i.debug("grpc.onEnd received after request was closed - ignoring");
            else if (void 0 !== this.responseTrailers) {
              var e5 = c2(this.responseTrailers);
              if (null !== e5) {
                var t4 = this.responseTrailers.get("grpc-message"), r3 = this.decodeGRPCStatus(t4[0]);
                this.rawOnEnd(e5, r3, this.responseTrailers);
              } else this.rawOnError(s2.Code.Internal, "Response closed without grpc-status (Trailers provided)");
            } else {
              if (void 0 === this.responseHeaders) return void this.rawOnError(s2.Code.Unknown, "Response closed without headers");
              var n3 = c2(this.responseHeaders), o2 = this.responseHeaders.get("grpc-message");
              if (this.props.debug && i.debug("grpc.headers only response ", n3, o2), null === n3) return void this.rawOnEnd(s2.Code.Unknown, "Response closed without grpc-status (Headers only)", this.responseHeaders);
              var a3 = this.decodeGRPCStatus(o2[0]);
              this.rawOnEnd(n3, a3, this.responseHeaders);
            }
          }, e4.prototype.decodeGRPCStatus = function(e5) {
            if (!e5) return "";
            try {
              return decodeURIComponent(e5);
            } catch (t4) {
              return e5;
            }
          }, e4.prototype.rawOnEnd = function(e5, t4, r3) {
            var n3 = this;
            this.props.debug && i.debug("rawOnEnd", e5, t4, r3), this.completed || (this.completed = true, this.onEndCallbacks.forEach(function(o2) {
              if (!n3.closed) try {
                o2(e5, t4, r3);
              } catch (e6) {
                setTimeout(function() {
                  throw e6;
                }, 0);
              }
            }));
          }, e4.prototype.rawOnHeaders = function(e5) {
            this.props.debug && i.debug("rawOnHeaders", e5), this.completed || this.onHeadersCallbacks.forEach(function(t4) {
              try {
                t4(e5);
              } catch (e6) {
                setTimeout(function() {
                  throw e6;
                }, 0);
              }
            });
          }, e4.prototype.rawOnError = function(e5, t4, r3) {
            var o2 = this;
            void 0 === r3 && (r3 = new n2.Metadata()), this.props.debug && i.debug("rawOnError", e5, t4), this.completed || (this.completed = true, this.onEndCallbacks.forEach(function(n3) {
              if (!o2.closed) try {
                n3(e5, t4, r3);
              } catch (e6) {
                setTimeout(function() {
                  throw e6;
                }, 0);
              }
            }));
          }, e4.prototype.rawOnMessage = function(e5) {
            var t4 = this;
            this.props.debug && i.debug("rawOnMessage", e5.toObject()), this.completed || this.closed || this.onMessageCallbacks.forEach(function(r3) {
              if (!t4.closed) try {
                r3(e5);
              } catch (e6) {
                setTimeout(function() {
                  throw e6;
                }, 0);
              }
            });
          }, e4.prototype.onHeaders = function(e5) {
            this.onHeadersCallbacks.push(e5);
          }, e4.prototype.onMessage = function(e5) {
            this.onMessageCallbacks.push(e5);
          }, e4.prototype.onEnd = function(e5) {
            this.onEndCallbacks.push(e5);
          }, e4.prototype.start = function(e5) {
            if (this.started) throw new Error("Client already started - cannot .start()");
            this.started = true;
            var t4 = new n2.Metadata(e5 || {});
            t4.set("content-type", "application/grpc-web+proto"), t4.set("x-grpc-web", "1"), this.transport.start(t4);
          }, e4.prototype.send = function(e5) {
            if (!this.started) throw new Error("Client not started - .start() must be called before .send()");
            if (this.closed) throw new Error("Client already closed - cannot .send()");
            if (this.finishedSending) throw new Error("Client already finished sending - cannot .send()");
            if (!this.methodDefinition.requestStream && this.sentFirstMessage) throw new Error("Message already sent for non-client-streaming method - cannot .send()");
            this.sentFirstMessage = true;
            var t4 = u2.frameRequest(e5);
            this.transport.sendMessage(t4);
          }, e4.prototype.finishSend = function() {
            if (!this.started) throw new Error("Client not started - .finishSend() must be called before .close()");
            if (this.closed) throw new Error("Client already closed - cannot .send()");
            if (this.finishedSending) throw new Error("Client already finished sending - cannot .finishSend()");
            this.finishedSending = true, this.transport.finishSend();
          }, e4.prototype.close = function() {
            if (!this.started) throw new Error("Client not started - .start() must be called before .close()");
            if (this.closed) throw new Error("Client already closed - cannot .close()");
            this.closed = true, this.props.debug && i.debug("request.abort aborting request"), this.transport.cancel();
          }, e4;
        }();
        function c2(e4) {
          var t4 = e4.get("grpc-status") || [];
          if (t4.length > 0) try {
            var r3 = t4[0];
            return parseInt(r3, 10);
          } catch (e5) {
            return null;
          }
          return null;
        }
      }, 346: function(e3, t3) {
        "use strict";
        Object.defineProperty(t3, "__esModule", { value: true }), t3.debug = void 0, t3.debug = function() {
          for (var e4 = [], t4 = 0; t4 < arguments.length; t4++) e4[t4] = arguments[t4];
          console.debug ? console.debug.apply(null, e4) : console.log.apply(null, e4);
        };
      }, 607: function(e3, t3, r2) {
        "use strict";
        Object.defineProperty(t3, "__esModule", { value: true }), t3.grpc = void 0;
        var n2, o = r2(418), s2 = r2(57), i = r2(229), a2 = r2(540), u2 = r2(210), d2 = r2(859), c2 = r2(8), p2 = r2(938), h2 = r2(35), f3 = r2(934);
        (n2 = t3.grpc || (t3.grpc = {})).setDefaultTransport = s2.setDefaultTransportFactory, n2.CrossBrowserHttpTransport = d2.CrossBrowserHttpTransport, n2.FetchReadableStreamTransport = i.FetchReadableStreamTransport, n2.XhrTransport = u2.XhrTransport, n2.WebsocketTransport = a2.WebsocketTransport, n2.Code = c2.Code, n2.Metadata = o.BrowserHeaders, n2.client = function(e4, t4) {
          return f3.client(e4, t4);
        }, n2.invoke = p2.invoke, n2.unary = h2.unary;
      }, 938: function(e3, t3, r2) {
        "use strict";
        Object.defineProperty(t3, "__esModule", { value: true }), t3.invoke = void 0;
        var n2 = r2(934);
        t3.invoke = function(e4, t4) {
          if (e4.requestStream) throw new Error(".invoke cannot be used with client-streaming methods. Use .client instead.");
          var r3 = n2.client(e4, { host: t4.host, transport: t4.transport, debug: t4.debug });
          return t4.onHeaders && r3.onHeaders(t4.onHeaders), t4.onMessage && r3.onMessage(t4.onMessage), t4.onEnd && r3.onEnd(t4.onEnd), r3.start(t4.metadata), r3.send(t4.request), r3.finishSend(), { close: function() {
            r3.close();
          } };
        };
      }, 65: function(e3, t3, r2) {
        "use strict";
        Object.defineProperty(t3, "__esModule", { value: true }), t3.Metadata = void 0;
        var n2 = r2(418);
        Object.defineProperty(t3, "Metadata", { enumerable: true, get: function() {
          return n2.BrowserHeaders;
        } });
      }, 57: function(e3, t3, r2) {
        "use strict";
        Object.defineProperty(t3, "__esModule", { value: true }), t3.makeDefaultTransport = t3.setDefaultTransportFactory = void 0;
        var n2 = r2(859), o = function(e4) {
          return n2.CrossBrowserHttpTransport({ withCredentials: false })(e4);
        };
        t3.setDefaultTransportFactory = function(e4) {
          o = e4;
        }, t3.makeDefaultTransport = function(e4) {
          return o(e4);
        };
      }, 229: function(e3, t3, r2) {
        "use strict";
        var n2 = this && this.__assign || function() {
          return (n2 = Object.assign || function(e4) {
            for (var t4, r3 = 1, n3 = arguments.length; r3 < n3; r3++) for (var o2 in t4 = arguments[r3]) Object.prototype.hasOwnProperty.call(t4, o2) && (e4[o2] = t4[o2]);
            return e4;
          }).apply(this, arguments);
        };
        Object.defineProperty(t3, "__esModule", { value: true }), t3.detectFetchSupport = t3.FetchReadableStreamTransport = void 0;
        var o = r2(65), s2 = r2(346);
        t3.FetchReadableStreamTransport = function(e4) {
          return function(t4) {
            return function(e5, t5) {
              return e5.debug && s2.debug("fetchRequest", e5), new i(e5, t5);
            }(t4, e4);
          };
        };
        var i = function() {
          function e4(e5, t4) {
            this.cancelled = false, this.controller = self.AbortController && new AbortController(), this.options = e5, this.init = t4;
          }
          return e4.prototype.pump = function(e5, t4) {
            var r3 = this;
            if (this.reader = e5, this.cancelled) return this.options.debug && s2.debug("Fetch.pump.cancel at first pump"), void this.reader.cancel().catch(function(e6) {
              r3.options.debug && s2.debug("Fetch.pump.reader.cancel exception", e6);
            });
            this.reader.read().then(function(e6) {
              if (e6.done) return r3.options.onEnd(), t4;
              r3.options.onChunk(e6.value), r3.pump(r3.reader, t4);
            }).catch(function(e6) {
              r3.cancelled ? r3.options.debug && s2.debug("Fetch.catch - request cancelled") : (r3.cancelled = true, r3.options.debug && s2.debug("Fetch.catch", e6.message), r3.options.onEnd(e6));
            });
          }, e4.prototype.send = function(e5) {
            var t4 = this;
            fetch(this.options.url, n2(n2({}, this.init), { headers: this.metadata.toHeaders(), method: "POST", body: e5, signal: this.controller && this.controller.signal })).then(function(e6) {
              if (t4.options.debug && s2.debug("Fetch.response", e6), t4.options.onHeaders(new o.Metadata(e6.headers), e6.status), !e6.body) return e6;
              t4.pump(e6.body.getReader(), e6);
            }).catch(function(e6) {
              t4.cancelled ? t4.options.debug && s2.debug("Fetch.catch - request cancelled") : (t4.cancelled = true, t4.options.debug && s2.debug("Fetch.catch", e6.message), t4.options.onEnd(e6));
            });
          }, e4.prototype.sendMessage = function(e5) {
            this.send(e5);
          }, e4.prototype.finishSend = function() {
          }, e4.prototype.start = function(e5) {
            this.metadata = e5;
          }, e4.prototype.cancel = function() {
            var e5 = this;
            this.cancelled ? this.options.debug && s2.debug("Fetch.cancel already cancelled") : (this.cancelled = true, this.controller ? (this.options.debug && s2.debug("Fetch.cancel.controller.abort"), this.controller.abort()) : this.options.debug && s2.debug("Fetch.cancel.missing abort controller"), this.reader ? (this.options.debug && s2.debug("Fetch.cancel.reader.cancel"), this.reader.cancel().catch(function(t4) {
              e5.options.debug && s2.debug("Fetch.cancel.reader.cancel exception", t4);
            })) : this.options.debug && s2.debug("Fetch.cancel before reader"));
          }, e4;
        }();
        t3.detectFetchSupport = function() {
          return "undefined" != typeof Response && Response.prototype.hasOwnProperty("body") && "function" == typeof Headers;
        };
      }, 859: function(e3, t3, r2) {
        "use strict";
        Object.defineProperty(t3, "__esModule", { value: true }), t3.CrossBrowserHttpTransport = void 0;
        var n2 = r2(229), o = r2(210);
        t3.CrossBrowserHttpTransport = function(e4) {
          if (n2.detectFetchSupport()) {
            var t4 = { credentials: e4.withCredentials ? "include" : "same-origin" };
            return n2.FetchReadableStreamTransport(t4);
          }
          return o.XhrTransport({ withCredentials: e4.withCredentials });
        };
      }, 210: function(e3, t3, r2) {
        "use strict";
        var n2, o = this && this.__extends || (n2 = function(e4, t4) {
          return (n2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e5, t5) {
            e5.__proto__ = t5;
          } || function(e5, t5) {
            for (var r3 in t5) Object.prototype.hasOwnProperty.call(t5, r3) && (e5[r3] = t5[r3]);
          })(e4, t4);
        }, function(e4, t4) {
          function r3() {
            this.constructor = e4;
          }
          n2(e4, t4), e4.prototype = null === t4 ? Object.create(t4) : (r3.prototype = t4.prototype, new r3());
        });
        Object.defineProperty(t3, "__esModule", { value: true }), t3.stringToArrayBuffer = t3.MozChunkedArrayBufferXHR = t3.XHR = t3.XhrTransport = void 0;
        var s2 = r2(65), i = r2(346), a2 = r2(849);
        t3.XhrTransport = function(e4) {
          return function(t4) {
            if (a2.detectMozXHRSupport()) return new d2(t4, e4);
            if (a2.detectXHROverrideMimeTypeSupport()) return new u2(t4, e4);
            throw new Error("This environment's XHR implementation cannot support binary transfer.");
          };
        };
        var u2 = function() {
          function e4(e5, t4) {
            this.options = e5, this.init = t4;
          }
          return e4.prototype.onProgressEvent = function() {
            this.options.debug && i.debug("XHR.onProgressEvent.length: ", this.xhr.response.length);
            var e5 = this.xhr.response.substr(this.index);
            this.index = this.xhr.response.length;
            var t4 = p2(e5);
            this.options.onChunk(t4);
          }, e4.prototype.onLoadEvent = function() {
            this.options.debug && i.debug("XHR.onLoadEvent"), this.options.onEnd();
          }, e4.prototype.onStateChange = function() {
            this.options.debug && i.debug("XHR.onStateChange", this.xhr.readyState), this.xhr.readyState === XMLHttpRequest.HEADERS_RECEIVED && this.options.onHeaders(new s2.Metadata(this.xhr.getAllResponseHeaders()), this.xhr.status);
          }, e4.prototype.sendMessage = function(e5) {
            this.xhr.send(e5);
          }, e4.prototype.finishSend = function() {
          }, e4.prototype.start = function(e5) {
            var t4 = this;
            this.metadata = e5;
            var r3 = new XMLHttpRequest();
            this.xhr = r3, r3.open("POST", this.options.url), this.configureXhr(), this.metadata.forEach(function(e6, t5) {
              r3.setRequestHeader(e6, t5.join(", "));
            }), r3.withCredentials = Boolean(this.init.withCredentials), r3.addEventListener("readystatechange", this.onStateChange.bind(this)), r3.addEventListener("progress", this.onProgressEvent.bind(this)), r3.addEventListener("loadend", this.onLoadEvent.bind(this)), r3.addEventListener("error", function(e6) {
              t4.options.debug && i.debug("XHR.error", e6), t4.options.onEnd(e6.error);
            });
          }, e4.prototype.configureXhr = function() {
            this.xhr.responseType = "text", this.xhr.overrideMimeType("text/plain; charset=x-user-defined");
          }, e4.prototype.cancel = function() {
            this.options.debug && i.debug("XHR.abort"), this.xhr.abort();
          }, e4;
        }();
        t3.XHR = u2;
        var d2 = function(e4) {
          function t4() {
            return null !== e4 && e4.apply(this, arguments) || this;
          }
          return o(t4, e4), t4.prototype.configureXhr = function() {
            this.options.debug && i.debug("MozXHR.configureXhr: setting responseType to 'moz-chunked-arraybuffer'"), this.xhr.responseType = "moz-chunked-arraybuffer";
          }, t4.prototype.onProgressEvent = function() {
            var e5 = this.xhr.response;
            this.options.debug && i.debug("MozXHR.onProgressEvent: ", new Uint8Array(e5)), this.options.onChunk(new Uint8Array(e5));
          }, t4;
        }(u2);
        function c2(e4, t4) {
          var r3 = e4.charCodeAt(t4);
          if (r3 >= 55296 && r3 <= 56319) {
            var n3 = e4.charCodeAt(t4 + 1);
            n3 >= 56320 && n3 <= 57343 && (r3 = 65536 + (r3 - 55296 << 10) + (n3 - 56320));
          }
          return r3;
        }
        function p2(e4) {
          for (var t4 = new Uint8Array(e4.length), r3 = 0, n3 = 0; n3 < e4.length; n3++) {
            var o2 = String.prototype.codePointAt ? e4.codePointAt(n3) : c2(e4, n3);
            t4[r3++] = 255 & o2;
          }
          return t4;
        }
        t3.MozChunkedArrayBufferXHR = d2, t3.stringToArrayBuffer = p2;
      }, 849: function(e3, t3) {
        "use strict";
        var r2;
        function n2() {
          if (void 0 !== r2) return r2;
          if (XMLHttpRequest) {
            r2 = new XMLHttpRequest();
            try {
              r2.open("GET", "https://localhost");
            } catch (e4) {
            }
          }
          return r2;
        }
        function o(e4) {
          var t4 = n2();
          if (!t4) return false;
          try {
            return t4.responseType = e4, t4.responseType === e4;
          } catch (e5) {
          }
          return false;
        }
        Object.defineProperty(t3, "__esModule", { value: true }), t3.detectXHROverrideMimeTypeSupport = t3.detectMozXHRSupport = t3.xhrSupportsResponseType = void 0, t3.xhrSupportsResponseType = o, t3.detectMozXHRSupport = function() {
          return "undefined" != typeof XMLHttpRequest && o("moz-chunked-arraybuffer");
        }, t3.detectXHROverrideMimeTypeSupport = function() {
          return "undefined" != typeof XMLHttpRequest && XMLHttpRequest.prototype.hasOwnProperty("overrideMimeType");
        };
      }, 540: function(e3, t3, r2) {
        "use strict";
        Object.defineProperty(t3, "__esModule", { value: true }), t3.WebsocketTransport = void 0;
        var n2, o = r2(346), s2 = r2(617);
        !function(e4) {
          e4[e4.FINISH_SEND = 1] = "FINISH_SEND";
        }(n2 || (n2 = {}));
        var i = new Uint8Array([1]);
        t3.WebsocketTransport = function() {
          return function(e4) {
            return function(e5) {
              e5.debug && o.debug("websocketRequest", e5);
              var t4, r3 = function(e6) {
                if ("https://" === e6.substr(0, 8)) return "wss://" + e6.substr(8);
                if ("http://" === e6.substr(0, 7)) return "ws://" + e6.substr(7);
                throw new Error("Websocket transport constructed with non-https:// or http:// host.");
              }(e5.url), a2 = [];
              function u2(e6) {
                if (e6 === n2.FINISH_SEND) t4.send(i);
                else {
                  var r4 = e6, o2 = new Int8Array(r4.byteLength + 1);
                  o2.set(new Uint8Array([0])), o2.set(r4, 1), t4.send(o2);
                }
              }
              return { sendMessage: function(e6) {
                t4 && t4.readyState !== t4.CONNECTING ? u2(e6) : a2.push(e6);
              }, finishSend: function() {
                t4 && t4.readyState !== t4.CONNECTING ? u2(n2.FINISH_SEND) : a2.push(n2.FINISH_SEND);
              }, start: function(n3) {
                (t4 = new WebSocket(r3, ["grpc-websockets"])).binaryType = "arraybuffer", t4.onopen = function() {
                  var r4;
                  e5.debug && o.debug("websocketRequest.onopen"), t4.send((r4 = "", n3.forEach(function(e6, t5) {
                    r4 += e6 + ": " + t5.join(", ") + "\r\n";
                  }), s2.encodeASCII(r4))), a2.forEach(function(e6) {
                    u2(e6);
                  });
                }, t4.onclose = function(t5) {
                  e5.debug && o.debug("websocketRequest.onclose", t5), e5.onEnd();
                }, t4.onerror = function(t5) {
                  e5.debug && o.debug("websocketRequest.onerror", t5);
                }, t4.onmessage = function(t5) {
                  e5.onChunk(new Uint8Array(t5.data));
                };
              }, cancel: function() {
                e5.debug && o.debug("websocket.abort"), t4.close();
              } };
            }(e4);
          };
        };
      }, 35: function(e3, t3, r2) {
        "use strict";
        Object.defineProperty(t3, "__esModule", { value: true }), t3.unary = void 0;
        var n2 = r2(65), o = r2(934);
        t3.unary = function(e4, t4) {
          if (e4.responseStream) throw new Error(".unary cannot be used with server-streaming methods. Use .invoke or .client instead.");
          if (e4.requestStream) throw new Error(".unary cannot be used with client-streaming methods. Use .client instead.");
          var r3 = null, s2 = null, i = o.client(e4, { host: t4.host, transport: t4.transport, debug: t4.debug });
          return i.onHeaders(function(e5) {
            r3 = e5;
          }), i.onMessage(function(e5) {
            s2 = e5;
          }), i.onEnd(function(e5, o2, i2) {
            t4.onEnd({ status: e5, statusMessage: o2, headers: r3 || new n2.Metadata(), message: s2, trailers: i2 });
          }), i.start(t4.metadata), i.send(t4.request), i.finishSend(), { close: function() {
            i.close();
          } };
        };
      }, 882: function(e3, t3) {
        "use strict";
        Object.defineProperty(t3, "__esModule", { value: true }), t3.frameRequest = void 0, t3.frameRequest = function(e4) {
          var t4 = e4.serializeBinary(), r2 = new ArrayBuffer(t4.byteLength + 5);
          return new DataView(r2, 1, 4).setUint32(0, t4.length, false), new Uint8Array(r2, 5).set(t4), new Uint8Array(r2);
        };
      } }, t2 = {}, function r2(n2) {
        if (t2[n2]) return t2[n2].exports;
        var o = t2[n2] = { exports: {} };
        return e2[n2].call(o.exports, o, o.exports, r2), o.exports;
      }(607);
      var e2, t2;
    });
  }
});

// node_modules/browser-headers/dist/browser-headers.umd.js
var require_browser_headers_umd = __commonJS({
  "node_modules/browser-headers/dist/browser-headers.umd.js"(exports2, module2) {
    (function webpackUniversalModuleDefinition(root, factory) {
      if (typeof exports2 === "object" && typeof module2 === "object")
        module2.exports = factory();
      else if (typeof define === "function" && define.amd)
        define([], factory);
      else {
        var a2 = factory();
        for (var i in a2) (typeof exports2 === "object" ? exports2 : root)[i] = a2[i];
      }
    })(exports2, function() {
      return (
        /******/
        function(modules) {
          var installedModules = {};
          function __webpack_require__(moduleId) {
            if (installedModules[moduleId]) {
              return installedModules[moduleId].exports;
            }
            var module3 = installedModules[moduleId] = {
              /******/
              i: moduleId,
              /******/
              l: false,
              /******/
              exports: {}
              /******/
            };
            modules[moduleId].call(module3.exports, module3, module3.exports, __webpack_require__);
            module3.l = true;
            return module3.exports;
          }
          __webpack_require__.m = modules;
          __webpack_require__.c = installedModules;
          __webpack_require__.i = function(value) {
            return value;
          };
          __webpack_require__.d = function(exports3, name, getter) {
            if (!__webpack_require__.o(exports3, name)) {
              Object.defineProperty(exports3, name, {
                /******/
                configurable: false,
                /******/
                enumerable: true,
                /******/
                get: getter
                /******/
              });
            }
          };
          __webpack_require__.n = function(module3) {
            var getter = module3 && module3.__esModule ? (
              /******/
              function getDefault() {
                return module3["default"];
              }
            ) : (
              /******/
              function getModuleExports() {
                return module3;
              }
            );
            __webpack_require__.d(getter, "a", getter);
            return getter;
          };
          __webpack_require__.o = function(object, property) {
            return Object.prototype.hasOwnProperty.call(object, property);
          };
          __webpack_require__.p = "";
          return __webpack_require__(__webpack_require__.s = 1);
        }([
          /* 0 */
          /***/
          function(module3, exports3, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports3, "__esModule", { value: true });
            var util_1 = __webpack_require__(3);
            function isBrowserHeaders(arg) {
              return typeof arg === "object" && typeof arg.headersMap === "object" && typeof arg.forEach === "function";
            }
            var BrowserHeaders3 = function() {
              function BrowserHeaders4(init, options) {
                if (init === void 0) {
                  init = {};
                }
                if (options === void 0) {
                  options = { splitValues: false };
                }
                var _this = this;
                this.headersMap = {};
                if (init) {
                  if (typeof Headers !== "undefined" && init instanceof Headers) {
                    var keys = util_1.getHeaderKeys(init);
                    keys.forEach(function(key) {
                      var values = util_1.getHeaderValues(init, key);
                      values.forEach(function(value) {
                        if (options.splitValues) {
                          _this.append(key, util_1.splitHeaderValue(value));
                        } else {
                          _this.append(key, value);
                        }
                      });
                    });
                  } else if (isBrowserHeaders(init)) {
                    init.forEach(function(key, values) {
                      _this.append(key, values);
                    });
                  } else if (typeof Map !== "undefined" && init instanceof Map) {
                    var asMap = init;
                    asMap.forEach(function(value, key) {
                      _this.append(key, value);
                    });
                  } else if (typeof init === "string") {
                    this.appendFromString(init);
                  } else if (typeof init === "object") {
                    Object.getOwnPropertyNames(init).forEach(function(key) {
                      var asObject = init;
                      var values = asObject[key];
                      if (Array.isArray(values)) {
                        values.forEach(function(value) {
                          _this.append(key, value);
                        });
                      } else {
                        _this.append(key, values);
                      }
                    });
                  }
                }
              }
              BrowserHeaders4.prototype.appendFromString = function(str) {
                var pairs2 = str.split("\r\n");
                for (var i = 0; i < pairs2.length; i++) {
                  var p2 = pairs2[i];
                  var index = p2.indexOf(":");
                  if (index > 0) {
                    var key = p2.substring(0, index).trim();
                    var value = p2.substring(index + 1).trim();
                    this.append(key, value);
                  }
                }
              };
              BrowserHeaders4.prototype.delete = function(key, value) {
                var normalizedKey = util_1.normalizeName(key);
                if (value === void 0) {
                  delete this.headersMap[normalizedKey];
                } else {
                  var existing = this.headersMap[normalizedKey];
                  if (existing) {
                    var index = existing.indexOf(value);
                    if (index >= 0) {
                      existing.splice(index, 1);
                    }
                    if (existing.length === 0) {
                      delete this.headersMap[normalizedKey];
                    }
                  }
                }
              };
              BrowserHeaders4.prototype.append = function(key, value) {
                var _this = this;
                var normalizedKey = util_1.normalizeName(key);
                if (!Array.isArray(this.headersMap[normalizedKey])) {
                  this.headersMap[normalizedKey] = [];
                }
                if (Array.isArray(value)) {
                  value.forEach(function(arrayValue) {
                    _this.headersMap[normalizedKey].push(util_1.normalizeValue(arrayValue));
                  });
                } else {
                  this.headersMap[normalizedKey].push(util_1.normalizeValue(value));
                }
              };
              BrowserHeaders4.prototype.set = function(key, value) {
                var normalizedKey = util_1.normalizeName(key);
                if (Array.isArray(value)) {
                  var normalized_1 = [];
                  value.forEach(function(arrayValue) {
                    normalized_1.push(util_1.normalizeValue(arrayValue));
                  });
                  this.headersMap[normalizedKey] = normalized_1;
                } else {
                  this.headersMap[normalizedKey] = [util_1.normalizeValue(value)];
                }
              };
              BrowserHeaders4.prototype.has = function(key, value) {
                var keyArray = this.headersMap[util_1.normalizeName(key)];
                var keyExists = Array.isArray(keyArray);
                if (!keyExists) {
                  return false;
                }
                if (value !== void 0) {
                  var normalizedValue = util_1.normalizeValue(value);
                  return keyArray.indexOf(normalizedValue) >= 0;
                } else {
                  return true;
                }
              };
              BrowserHeaders4.prototype.get = function(key) {
                var values = this.headersMap[util_1.normalizeName(key)];
                if (values !== void 0) {
                  return values.concat();
                }
                return [];
              };
              BrowserHeaders4.prototype.forEach = function(callback) {
                var _this = this;
                Object.getOwnPropertyNames(this.headersMap).forEach(function(key) {
                  callback(key, _this.headersMap[key]);
                }, this);
              };
              BrowserHeaders4.prototype.toHeaders = function() {
                if (typeof Headers !== "undefined") {
                  var headers_1 = new Headers();
                  this.forEach(function(key, values) {
                    values.forEach(function(value) {
                      headers_1.append(key, value);
                    });
                  });
                  return headers_1;
                } else {
                  throw new Error("Headers class is not defined");
                }
              };
              return BrowserHeaders4;
            }();
            exports3.BrowserHeaders = BrowserHeaders3;
          },
          /* 1 */
          /***/
          function(module3, exports3, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports3, "__esModule", { value: true });
            var BrowserHeaders_1 = __webpack_require__(0);
            exports3.BrowserHeaders = BrowserHeaders_1.BrowserHeaders;
          },
          /* 2 */
          /***/
          function(module3, exports3, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports3, "__esModule", { value: true });
            function iterateHeaders(headers, callback) {
              var iterator2 = headers[Symbol.iterator]();
              var entry = iterator2.next();
              while (!entry.done) {
                callback(entry.value[0]);
                entry = iterator2.next();
              }
            }
            exports3.iterateHeaders = iterateHeaders;
            function iterateHeadersKeys(headers, callback) {
              var iterator2 = headers.keys();
              var entry = iterator2.next();
              while (!entry.done) {
                callback(entry.value);
                entry = iterator2.next();
              }
            }
            exports3.iterateHeadersKeys = iterateHeadersKeys;
          },
          /* 3 */
          /***/
          function(module3, exports3, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports3, "__esModule", { value: true });
            var iterateHeaders_1 = __webpack_require__(2);
            function normalizeName(name) {
              if (typeof name !== "string") {
                name = String(name);
              }
              if (/[^a-z0-9\-#$%&'*+.\^_`|~]/i.test(name)) {
                throw new TypeError("Invalid character in header field name");
              }
              return name.toLowerCase();
            }
            exports3.normalizeName = normalizeName;
            function normalizeValue(value) {
              if (typeof value !== "string") {
                value = String(value);
              }
              return value;
            }
            exports3.normalizeValue = normalizeValue;
            function getHeaderValues(headersAsNative, key) {
              var headers = toWindowHeaders(headersAsNative);
              if (headers instanceof Headers && headers.getAll) {
                return headers.getAll(key);
              }
              var getValue = headers.get(key);
              if (getValue && typeof getValue === "string") {
                return [getValue];
              }
              return getValue;
            }
            exports3.getHeaderValues = getHeaderValues;
            function toWindowHeaders(headersAsNative) {
              return headersAsNative;
            }
            function getHeaderKeys(headersAsNative) {
              var headers = toWindowHeaders(headersAsNative);
              var asMap = {};
              var keys = [];
              if (headers.keys) {
                iterateHeaders_1.iterateHeadersKeys(headers, function(key) {
                  if (!asMap[key]) {
                    asMap[key] = true;
                    keys.push(key);
                  }
                });
              } else if (headers.forEach) {
                headers.forEach(function(_, key) {
                  if (!asMap[key]) {
                    asMap[key] = true;
                    keys.push(key);
                  }
                });
              } else {
                iterateHeaders_1.iterateHeaders(headers, function(entry) {
                  var key = entry[0];
                  if (!asMap[key]) {
                    asMap[key] = true;
                    keys.push(key);
                  }
                });
              }
              return keys;
            }
            exports3.getHeaderKeys = getHeaderKeys;
            function splitHeaderValue(str) {
              var values = [];
              var commaSpaceValues = str.split(", ");
              commaSpaceValues.forEach(function(commaSpaceValue) {
                commaSpaceValue.split(",").forEach(function(commaValue) {
                  values.push(commaValue);
                });
              });
              return values;
            }
            exports3.splitHeaderValue = splitHeaderValue;
          }
          /******/
        ])
      );
    });
  }
});

// node_modules/@protobufjs/codegen/index.js
var require_codegen = __commonJS({
  "node_modules/@protobufjs/codegen/index.js"(exports2, module2) {
    "use strict";
    module2.exports = codegen;
    function codegen(functionParams, functionName) {
      if (typeof functionParams === "string") {
        functionName = functionParams;
        functionParams = void 0;
      }
      var body = [];
      function Codegen(formatStringOrScope) {
        if (typeof formatStringOrScope !== "string") {
          var source = toString();
          if (codegen.verbose)
            console.log("codegen: " + source);
          source = "return " + source;
          if (formatStringOrScope) {
            var scopeKeys = Object.keys(formatStringOrScope), scopeParams = new Array(scopeKeys.length + 1), scopeValues = new Array(scopeKeys.length), scopeOffset = 0;
            while (scopeOffset < scopeKeys.length) {
              scopeParams[scopeOffset] = scopeKeys[scopeOffset];
              scopeValues[scopeOffset] = formatStringOrScope[scopeKeys[scopeOffset++]];
            }
            scopeParams[scopeOffset] = source;
            return Function.apply(null, scopeParams).apply(null, scopeValues);
          }
          return Function(source)();
        }
        var formatParams = new Array(arguments.length - 1), formatOffset = 0;
        while (formatOffset < formatParams.length)
          formatParams[formatOffset] = arguments[++formatOffset];
        formatOffset = 0;
        formatStringOrScope = formatStringOrScope.replace(/%([%dfijs])/g, function replace($0, $1) {
          var value = formatParams[formatOffset++];
          switch ($1) {
            case "d":
            case "f":
              return String(Number(value));
            case "i":
              return String(Math.floor(value));
            case "j":
              return JSON.stringify(value);
            case "s":
              return String(value);
          }
          return "%";
        });
        if (formatOffset !== formatParams.length)
          throw Error("parameter count mismatch");
        body.push(formatStringOrScope);
        return Codegen;
      }
      function toString(functionNameOverride) {
        return "function " + (functionNameOverride || functionName || "") + "(" + (functionParams && functionParams.join(",") || "") + "){\n  " + body.join("\n  ") + "\n}";
      }
      Codegen.toString = toString;
      return Codegen;
    }
    codegen.verbose = false;
  }
});

// node_modules/@protobufjs/fetch/index.js
var require_fetch = __commonJS({
  "node_modules/@protobufjs/fetch/index.js"(exports2, module2) {
    "use strict";
    module2.exports = fetch2;
    var asPromise = require_aspromise();
    var inquire2 = require_inquire();
    var fs = inquire2("fs");
    function fetch2(filename, options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = {};
      } else if (!options)
        options = {};
      if (!callback)
        return asPromise(fetch2, this, filename, options);
      if (!options.xhr && fs && fs.readFile)
        return fs.readFile(filename, function fetchReadFileCallback(err, contents) {
          return err && typeof XMLHttpRequest !== "undefined" ? fetch2.xhr(filename, options, callback) : err ? callback(err) : callback(null, options.binary ? contents : contents.toString("utf8"));
        });
      return fetch2.xhr(filename, options, callback);
    }
    fetch2.xhr = function fetch_xhr(filename, options, callback) {
      var xhr = new XMLHttpRequest();
      xhr.onreadystatechange = function fetchOnReadyStateChange() {
        if (xhr.readyState !== 4)
          return void 0;
        if (xhr.status !== 0 && xhr.status !== 200)
          return callback(Error("status " + xhr.status));
        if (options.binary) {
          var buffer2 = xhr.response;
          if (!buffer2) {
            buffer2 = [];
            for (var i = 0; i < xhr.responseText.length; ++i)
              buffer2.push(xhr.responseText.charCodeAt(i) & 255);
          }
          return callback(null, typeof Uint8Array !== "undefined" ? new Uint8Array(buffer2) : buffer2);
        }
        return callback(null, xhr.responseText);
      };
      if (options.binary) {
        if ("overrideMimeType" in xhr)
          xhr.overrideMimeType("text/plain; charset=x-user-defined");
        xhr.responseType = "arraybuffer";
      }
      xhr.open("GET", filename);
      xhr.send();
    };
  }
});

// node_modules/@protobufjs/path/index.js
var require_path = __commonJS({
  "node_modules/@protobufjs/path/index.js"(exports2) {
    "use strict";
    var path = exports2;
    var isAbsolute = (
      /**
       * Tests if the specified path is absolute.
       * @param {string} path Path to test
       * @returns {boolean} `true` if path is absolute
       */
      path.isAbsolute = function isAbsolute2(path2) {
        return /^(?:\/|\w+:)/.test(path2);
      }
    );
    var normalize = (
      /**
       * Normalizes the specified path.
       * @param {string} path Path to normalize
       * @returns {string} Normalized path
       */
      path.normalize = function normalize2(path2) {
        path2 = path2.replace(/\\/g, "/").replace(/\/{2,}/g, "/");
        var parts = path2.split("/"), absolute = isAbsolute(path2), prefix = "";
        if (absolute)
          prefix = parts.shift() + "/";
        for (var i = 0; i < parts.length; ) {
          if (parts[i] === "..") {
            if (i > 0 && parts[i - 1] !== "..")
              parts.splice(--i, 2);
            else if (absolute)
              parts.splice(i, 1);
            else
              ++i;
          } else if (parts[i] === ".")
            parts.splice(i, 1);
          else
            ++i;
        }
        return prefix + parts.join("/");
      }
    );
    path.resolve = function resolve(originPath, includePath, alreadyNormalized) {
      if (!alreadyNormalized)
        includePath = normalize(includePath);
      if (isAbsolute(includePath))
        return includePath;
      if (!alreadyNormalized)
        originPath = normalize(originPath);
      return (originPath = originPath.replace(/(?:\/|^)[^/]+$/, "")).length ? normalize(originPath + "/" + includePath) : includePath;
    };
  }
});

// node_modules/protobufjs/src/types.js
var require_types = __commonJS({
  "node_modules/protobufjs/src/types.js"(exports2) {
    "use strict";
    var types = exports2;
    var util = require_util();
    var s2 = [
      "double",
      // 0
      "float",
      // 1
      "int32",
      // 2
      "uint32",
      // 3
      "sint32",
      // 4
      "fixed32",
      // 5
      "sfixed32",
      // 6
      "int64",
      // 7
      "uint64",
      // 8
      "sint64",
      // 9
      "fixed64",
      // 10
      "sfixed64",
      // 11
      "bool",
      // 12
      "string",
      // 13
      "bytes"
      // 14
    ];
    function bake(values, offset) {
      var i = 0, o = {};
      offset |= 0;
      while (i < values.length) o[s2[i + offset]] = values[i++];
      return o;
    }
    types.basic = bake([
      /* double   */
      1,
      /* float    */
      5,
      /* int32    */
      0,
      /* uint32   */
      0,
      /* sint32   */
      0,
      /* fixed32  */
      5,
      /* sfixed32 */
      5,
      /* int64    */
      0,
      /* uint64   */
      0,
      /* sint64   */
      0,
      /* fixed64  */
      1,
      /* sfixed64 */
      1,
      /* bool     */
      0,
      /* string   */
      2,
      /* bytes    */
      2
    ]);
    types.defaults = bake([
      /* double   */
      0,
      /* float    */
      0,
      /* int32    */
      0,
      /* uint32   */
      0,
      /* sint32   */
      0,
      /* fixed32  */
      0,
      /* sfixed32 */
      0,
      /* int64    */
      0,
      /* uint64   */
      0,
      /* sint64   */
      0,
      /* fixed64  */
      0,
      /* sfixed64 */
      0,
      /* bool     */
      false,
      /* string   */
      "",
      /* bytes    */
      util.emptyArray,
      /* message  */
      null
    ]);
    types.long = bake([
      /* int64    */
      0,
      /* uint64   */
      0,
      /* sint64   */
      0,
      /* fixed64  */
      1,
      /* sfixed64 */
      1
    ], 7);
    types.mapKey = bake([
      /* int32    */
      0,
      /* uint32   */
      0,
      /* sint32   */
      0,
      /* fixed32  */
      5,
      /* sfixed32 */
      5,
      /* int64    */
      0,
      /* uint64   */
      0,
      /* sint64   */
      0,
      /* fixed64  */
      1,
      /* sfixed64 */
      1,
      /* bool     */
      0,
      /* string   */
      2
    ], 2);
    types.packed = bake([
      /* double   */
      1,
      /* float    */
      5,
      /* int32    */
      0,
      /* uint32   */
      0,
      /* sint32   */
      0,
      /* fixed32  */
      5,
      /* sfixed32 */
      5,
      /* int64    */
      0,
      /* uint64   */
      0,
      /* sint64   */
      0,
      /* fixed64  */
      1,
      /* sfixed64 */
      1,
      /* bool     */
      0
    ]);
  }
});

// node_modules/protobufjs/src/field.js
var require_field = __commonJS({
  "node_modules/protobufjs/src/field.js"(exports2, module2) {
    "use strict";
    module2.exports = Field;
    var ReflectionObject = require_object();
    ((Field.prototype = Object.create(ReflectionObject.prototype)).constructor = Field).className = "Field";
    var Enum = require_enum();
    var types = require_types();
    var util = require_util();
    var Type;
    var ruleRe = /^required|optional|repeated$/;
    Field.fromJSON = function fromJSON(name, json) {
      return new Field(name, json.id, json.type, json.rule, json.extend, json.options, json.comment);
    };
    function Field(name, id, type, rule, extend, options, comment) {
      if (util.isObject(rule)) {
        comment = extend;
        options = rule;
        rule = extend = void 0;
      } else if (util.isObject(extend)) {
        comment = options;
        options = extend;
        extend = void 0;
      }
      ReflectionObject.call(this, name, options);
      if (!util.isInteger(id) || id < 0)
        throw TypeError("id must be a non-negative integer");
      if (!util.isString(type))
        throw TypeError("type must be a string");
      if (rule !== void 0 && !ruleRe.test(rule = rule.toString().toLowerCase()))
        throw TypeError("rule must be a string rule");
      if (extend !== void 0 && !util.isString(extend))
        throw TypeError("extend must be a string");
      if (rule === "proto3_optional") {
        rule = "optional";
      }
      this.rule = rule && rule !== "optional" ? rule : void 0;
      this.type = type;
      this.id = id;
      this.extend = extend || void 0;
      this.required = rule === "required";
      this.optional = !this.required;
      this.repeated = rule === "repeated";
      this.map = false;
      this.message = null;
      this.partOf = null;
      this.typeDefault = null;
      this.defaultValue = null;
      this.long = util.Long ? types.long[type] !== void 0 : (
        /* istanbul ignore next */
        false
      );
      this.bytes = type === "bytes";
      this.resolvedType = null;
      this.extensionField = null;
      this.declaringField = null;
      this._packed = null;
      this.comment = comment;
    }
    Object.defineProperty(Field.prototype, "packed", {
      get: function() {
        if (this._packed === null)
          this._packed = this.getOption("packed") !== false;
        return this._packed;
      }
    });
    Field.prototype.setOption = function setOption(name, value, ifNotSet) {
      if (name === "packed")
        this._packed = null;
      return ReflectionObject.prototype.setOption.call(this, name, value, ifNotSet);
    };
    Field.prototype.toJSON = function toJSON(toJSONOptions) {
      var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
      return util.toObject([
        "rule",
        this.rule !== "optional" && this.rule || void 0,
        "type",
        this.type,
        "id",
        this.id,
        "extend",
        this.extend,
        "options",
        this.options,
        "comment",
        keepComments ? this.comment : void 0
      ]);
    };
    Field.prototype.resolve = function resolve() {
      if (this.resolved)
        return this;
      if ((this.typeDefault = types.defaults[this.type]) === void 0) {
        this.resolvedType = (this.declaringField ? this.declaringField.parent : this.parent).lookupTypeOrEnum(this.type);
        if (this.resolvedType instanceof Type)
          this.typeDefault = null;
        else
          this.typeDefault = this.resolvedType.values[Object.keys(this.resolvedType.values)[0]];
      }
      if (this.options && this.options["default"] != null) {
        this.typeDefault = this.options["default"];
        if (this.resolvedType instanceof Enum && typeof this.typeDefault === "string")
          this.typeDefault = this.resolvedType.values[this.typeDefault];
      }
      if (this.options) {
        if (this.options.packed === true || this.options.packed !== void 0 && this.resolvedType && !(this.resolvedType instanceof Enum))
          delete this.options.packed;
        if (!Object.keys(this.options).length)
          this.options = void 0;
      }
      if (this.long) {
        this.typeDefault = util.Long.fromNumber(this.typeDefault, this.type.charAt(0) === "u");
        if (Object.freeze)
          Object.freeze(this.typeDefault);
      } else if (this.bytes && typeof this.typeDefault === "string") {
        var buf;
        if (util.base64.test(this.typeDefault))
          util.base64.decode(this.typeDefault, buf = util.newBuffer(util.base64.length(this.typeDefault)), 0);
        else
          util.utf8.write(this.typeDefault, buf = util.newBuffer(util.utf8.length(this.typeDefault)), 0);
        this.typeDefault = buf;
      }
      if (this.map)
        this.defaultValue = util.emptyObject;
      else if (this.repeated)
        this.defaultValue = util.emptyArray;
      else
        this.defaultValue = this.typeDefault;
      if (this.parent instanceof Type)
        this.parent.ctor.prototype[this.name] = this.defaultValue;
      return ReflectionObject.prototype.resolve.call(this);
    };
    Field.d = function decorateField(fieldId, fieldType, fieldRule, defaultValue) {
      if (typeof fieldType === "function")
        fieldType = util.decorateType(fieldType).name;
      else if (fieldType && typeof fieldType === "object")
        fieldType = util.decorateEnum(fieldType).name;
      return function fieldDecorator(prototype, fieldName) {
        util.decorateType(prototype.constructor).add(new Field(fieldName, fieldId, fieldType, fieldRule, { "default": defaultValue }));
      };
    };
    Field._configure = function configure(Type_) {
      Type = Type_;
    };
  }
});

// node_modules/protobufjs/src/oneof.js
var require_oneof = __commonJS({
  "node_modules/protobufjs/src/oneof.js"(exports2, module2) {
    "use strict";
    module2.exports = OneOf;
    var ReflectionObject = require_object();
    ((OneOf.prototype = Object.create(ReflectionObject.prototype)).constructor = OneOf).className = "OneOf";
    var Field = require_field();
    var util = require_util();
    function OneOf(name, fieldNames, options, comment) {
      if (!Array.isArray(fieldNames)) {
        options = fieldNames;
        fieldNames = void 0;
      }
      ReflectionObject.call(this, name, options);
      if (!(fieldNames === void 0 || Array.isArray(fieldNames)))
        throw TypeError("fieldNames must be an Array");
      this.oneof = fieldNames || [];
      this.fieldsArray = [];
      this.comment = comment;
    }
    OneOf.fromJSON = function fromJSON(name, json) {
      return new OneOf(name, json.oneof, json.options, json.comment);
    };
    OneOf.prototype.toJSON = function toJSON(toJSONOptions) {
      var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
      return util.toObject([
        "options",
        this.options,
        "oneof",
        this.oneof,
        "comment",
        keepComments ? this.comment : void 0
      ]);
    };
    function addFieldsToParent(oneof) {
      if (oneof.parent) {
        for (var i = 0; i < oneof.fieldsArray.length; ++i)
          if (!oneof.fieldsArray[i].parent)
            oneof.parent.add(oneof.fieldsArray[i]);
      }
    }
    OneOf.prototype.add = function add(field) {
      if (!(field instanceof Field))
        throw TypeError("field must be a Field");
      if (field.parent && field.parent !== this.parent)
        field.parent.remove(field);
      this.oneof.push(field.name);
      this.fieldsArray.push(field);
      field.partOf = this;
      addFieldsToParent(this);
      return this;
    };
    OneOf.prototype.remove = function remove(field) {
      if (!(field instanceof Field))
        throw TypeError("field must be a Field");
      var index = this.fieldsArray.indexOf(field);
      if (index < 0)
        throw Error(field + " is not a member of " + this);
      this.fieldsArray.splice(index, 1);
      index = this.oneof.indexOf(field.name);
      if (index > -1)
        this.oneof.splice(index, 1);
      field.partOf = null;
      return this;
    };
    OneOf.prototype.onAdd = function onAdd(parent) {
      ReflectionObject.prototype.onAdd.call(this, parent);
      var self2 = this;
      for (var i = 0; i < this.oneof.length; ++i) {
        var field = parent.get(this.oneof[i]);
        if (field && !field.partOf) {
          field.partOf = self2;
          self2.fieldsArray.push(field);
        }
      }
      addFieldsToParent(this);
    };
    OneOf.prototype.onRemove = function onRemove(parent) {
      for (var i = 0, field; i < this.fieldsArray.length; ++i)
        if ((field = this.fieldsArray[i]).parent)
          field.parent.remove(field);
      ReflectionObject.prototype.onRemove.call(this, parent);
    };
    OneOf.d = function decorateOneOf() {
      var fieldNames = new Array(arguments.length), index = 0;
      while (index < arguments.length)
        fieldNames[index] = arguments[index++];
      return function oneOfDecorator(prototype, oneofName) {
        util.decorateType(prototype.constructor).add(new OneOf(oneofName, fieldNames));
        Object.defineProperty(prototype, oneofName, {
          get: util.oneOfGetter(fieldNames),
          set: util.oneOfSetter(fieldNames)
        });
      };
    };
  }
});

// node_modules/protobufjs/src/namespace.js
var require_namespace = __commonJS({
  "node_modules/protobufjs/src/namespace.js"(exports2, module2) {
    "use strict";
    module2.exports = Namespace2;
    var ReflectionObject = require_object();
    ((Namespace2.prototype = Object.create(ReflectionObject.prototype)).constructor = Namespace2).className = "Namespace";
    var Field = require_field();
    var OneOf = require_oneof();
    var util = require_util();
    var Type;
    var Service;
    var Enum;
    Namespace2.fromJSON = function fromJSON(name, json) {
      return new Namespace2(name, json.options).addJSON(json.nested);
    };
    function arrayToJSON(array, toJSONOptions) {
      if (!(array && array.length))
        return void 0;
      var obj = {};
      for (var i = 0; i < array.length; ++i)
        obj[array[i].name] = array[i].toJSON(toJSONOptions);
      return obj;
    }
    Namespace2.arrayToJSON = arrayToJSON;
    Namespace2.isReservedId = function isReservedId(reserved, id) {
      if (reserved) {
        for (var i = 0; i < reserved.length; ++i)
          if (typeof reserved[i] !== "string" && reserved[i][0] <= id && reserved[i][1] > id)
            return true;
      }
      return false;
    };
    Namespace2.isReservedName = function isReservedName(reserved, name) {
      if (reserved) {
        for (var i = 0; i < reserved.length; ++i)
          if (reserved[i] === name)
            return true;
      }
      return false;
    };
    function Namespace2(name, options) {
      ReflectionObject.call(this, name, options);
      this.nested = void 0;
      this._nestedArray = null;
    }
    function clearCache(namespace) {
      namespace._nestedArray = null;
      return namespace;
    }
    Object.defineProperty(Namespace2.prototype, "nestedArray", {
      get: function() {
        return this._nestedArray || (this._nestedArray = util.toArray(this.nested));
      }
    });
    Namespace2.prototype.toJSON = function toJSON(toJSONOptions) {
      return util.toObject([
        "options",
        this.options,
        "nested",
        arrayToJSON(this.nestedArray, toJSONOptions)
      ]);
    };
    Namespace2.prototype.addJSON = function addJSON(nestedJson) {
      var ns = this;
      if (nestedJson) {
        for (var names = Object.keys(nestedJson), i = 0, nested; i < names.length; ++i) {
          nested = nestedJson[names[i]];
          ns.add(
            // most to least likely
            (nested.fields !== void 0 ? Type.fromJSON : nested.values !== void 0 ? Enum.fromJSON : nested.methods !== void 0 ? Service.fromJSON : nested.id !== void 0 ? Field.fromJSON : Namespace2.fromJSON)(names[i], nested)
          );
        }
      }
      return this;
    };
    Namespace2.prototype.get = function get(name) {
      return this.nested && this.nested[name] || null;
    };
    Namespace2.prototype.getEnum = function getEnum(name) {
      if (this.nested && this.nested[name] instanceof Enum)
        return this.nested[name].values;
      throw Error("no such enum: " + name);
    };
    Namespace2.prototype.add = function add(object) {
      if (!(object instanceof Field && object.extend !== void 0 || object instanceof Type || object instanceof Enum || object instanceof Service || object instanceof Namespace2 || object instanceof OneOf))
        throw TypeError("object must be a valid nested object");
      if (!this.nested)
        this.nested = {};
      else {
        var prev = this.get(object.name);
        if (prev) {
          if (prev instanceof Namespace2 && object instanceof Namespace2 && !(prev instanceof Type || prev instanceof Service)) {
            var nested = prev.nestedArray;
            for (var i = 0; i < nested.length; ++i)
              object.add(nested[i]);
            this.remove(prev);
            if (!this.nested)
              this.nested = {};
            object.setOptions(prev.options, true);
          } else
            throw Error("duplicate name '" + object.name + "' in " + this);
        }
      }
      this.nested[object.name] = object;
      object.onAdd(this);
      return clearCache(this);
    };
    Namespace2.prototype.remove = function remove(object) {
      if (!(object instanceof ReflectionObject))
        throw TypeError("object must be a ReflectionObject");
      if (object.parent !== this)
        throw Error(object + " is not a member of " + this);
      delete this.nested[object.name];
      if (!Object.keys(this.nested).length)
        this.nested = void 0;
      object.onRemove(this);
      return clearCache(this);
    };
    Namespace2.prototype.define = function define2(path, json) {
      if (util.isString(path))
        path = path.split(".");
      else if (!Array.isArray(path))
        throw TypeError("illegal path");
      if (path && path.length && path[0] === "")
        throw Error("path must be relative");
      var ptr = this;
      while (path.length > 0) {
        var part = path.shift();
        if (ptr.nested && ptr.nested[part]) {
          ptr = ptr.nested[part];
          if (!(ptr instanceof Namespace2))
            throw Error("path conflicts with non-namespace objects");
        } else
          ptr.add(ptr = new Namespace2(part));
      }
      if (json)
        ptr.addJSON(json);
      return ptr;
    };
    Namespace2.prototype.resolveAll = function resolveAll() {
      var nested = this.nestedArray, i = 0;
      while (i < nested.length)
        if (nested[i] instanceof Namespace2)
          nested[i++].resolveAll();
        else
          nested[i++].resolve();
      return this.resolve();
    };
    Namespace2.prototype.lookup = function lookup(path, filterTypes, parentAlreadyChecked) {
      if (typeof filterTypes === "boolean") {
        parentAlreadyChecked = filterTypes;
        filterTypes = void 0;
      } else if (filterTypes && !Array.isArray(filterTypes))
        filterTypes = [filterTypes];
      if (util.isString(path) && path.length) {
        if (path === ".")
          return this.root;
        path = path.split(".");
      } else if (!path.length)
        return this;
      if (path[0] === "")
        return this.root.lookup(path.slice(1), filterTypes);
      var found = this.get(path[0]);
      if (found) {
        if (path.length === 1) {
          if (!filterTypes || filterTypes.indexOf(found.constructor) > -1)
            return found;
        } else if (found instanceof Namespace2 && (found = found.lookup(path.slice(1), filterTypes, true)))
          return found;
      } else
        for (var i = 0; i < this.nestedArray.length; ++i)
          if (this._nestedArray[i] instanceof Namespace2 && (found = this._nestedArray[i].lookup(path, filterTypes, true)))
            return found;
      if (this.parent === null || parentAlreadyChecked)
        return null;
      return this.parent.lookup(path, filterTypes);
    };
    Namespace2.prototype.lookupType = function lookupType(path) {
      var found = this.lookup(path, [Type]);
      if (!found)
        throw Error("no such type: " + path);
      return found;
    };
    Namespace2.prototype.lookupEnum = function lookupEnum(path) {
      var found = this.lookup(path, [Enum]);
      if (!found)
        throw Error("no such Enum '" + path + "' in " + this);
      return found;
    };
    Namespace2.prototype.lookupTypeOrEnum = function lookupTypeOrEnum(path) {
      var found = this.lookup(path, [Type, Enum]);
      if (!found)
        throw Error("no such Type or Enum '" + path + "' in " + this);
      return found;
    };
    Namespace2.prototype.lookupService = function lookupService(path) {
      var found = this.lookup(path, [Service]);
      if (!found)
        throw Error("no such Service '" + path + "' in " + this);
      return found;
    };
    Namespace2._configure = function(Type_, Service_, Enum_) {
      Type = Type_;
      Service = Service_;
      Enum = Enum_;
    };
  }
});

// node_modules/protobufjs/src/mapfield.js
var require_mapfield = __commonJS({
  "node_modules/protobufjs/src/mapfield.js"(exports2, module2) {
    "use strict";
    module2.exports = MapField;
    var Field = require_field();
    ((MapField.prototype = Object.create(Field.prototype)).constructor = MapField).className = "MapField";
    var types = require_types();
    var util = require_util();
    function MapField(name, id, keyType, type, options, comment) {
      Field.call(this, name, id, type, void 0, void 0, options, comment);
      if (!util.isString(keyType))
        throw TypeError("keyType must be a string");
      this.keyType = keyType;
      this.resolvedKeyType = null;
      this.map = true;
    }
    MapField.fromJSON = function fromJSON(name, json) {
      return new MapField(name, json.id, json.keyType, json.type, json.options, json.comment);
    };
    MapField.prototype.toJSON = function toJSON(toJSONOptions) {
      var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
      return util.toObject([
        "keyType",
        this.keyType,
        "type",
        this.type,
        "id",
        this.id,
        "extend",
        this.extend,
        "options",
        this.options,
        "comment",
        keepComments ? this.comment : void 0
      ]);
    };
    MapField.prototype.resolve = function resolve() {
      if (this.resolved)
        return this;
      if (types.mapKey[this.keyType] === void 0)
        throw Error("invalid key type: " + this.keyType);
      return Field.prototype.resolve.call(this);
    };
    MapField.d = function decorateMapField(fieldId, fieldKeyType, fieldValueType) {
      if (typeof fieldValueType === "function")
        fieldValueType = util.decorateType(fieldValueType).name;
      else if (fieldValueType && typeof fieldValueType === "object")
        fieldValueType = util.decorateEnum(fieldValueType).name;
      return function mapFieldDecorator(prototype, fieldName) {
        util.decorateType(prototype.constructor).add(new MapField(fieldName, fieldId, fieldKeyType, fieldValueType));
      };
    };
  }
});

// node_modules/protobufjs/src/method.js
var require_method = __commonJS({
  "node_modules/protobufjs/src/method.js"(exports2, module2) {
    "use strict";
    module2.exports = Method;
    var ReflectionObject = require_object();
    ((Method.prototype = Object.create(ReflectionObject.prototype)).constructor = Method).className = "Method";
    var util = require_util();
    function Method(name, type, requestType, responseType, requestStream, responseStream, options, comment, parsedOptions) {
      if (util.isObject(requestStream)) {
        options = requestStream;
        requestStream = responseStream = void 0;
      } else if (util.isObject(responseStream)) {
        options = responseStream;
        responseStream = void 0;
      }
      if (!(type === void 0 || util.isString(type)))
        throw TypeError("type must be a string");
      if (!util.isString(requestType))
        throw TypeError("requestType must be a string");
      if (!util.isString(responseType))
        throw TypeError("responseType must be a string");
      ReflectionObject.call(this, name, options);
      this.type = type || "rpc";
      this.requestType = requestType;
      this.requestStream = requestStream ? true : void 0;
      this.responseType = responseType;
      this.responseStream = responseStream ? true : void 0;
      this.resolvedRequestType = null;
      this.resolvedResponseType = null;
      this.comment = comment;
      this.parsedOptions = parsedOptions;
    }
    Method.fromJSON = function fromJSON(name, json) {
      return new Method(name, json.type, json.requestType, json.responseType, json.requestStream, json.responseStream, json.options, json.comment, json.parsedOptions);
    };
    Method.prototype.toJSON = function toJSON(toJSONOptions) {
      var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
      return util.toObject([
        "type",
        this.type !== "rpc" && /* istanbul ignore next */
        this.type || void 0,
        "requestType",
        this.requestType,
        "requestStream",
        this.requestStream,
        "responseType",
        this.responseType,
        "responseStream",
        this.responseStream,
        "options",
        this.options,
        "comment",
        keepComments ? this.comment : void 0,
        "parsedOptions",
        this.parsedOptions
      ]);
    };
    Method.prototype.resolve = function resolve() {
      if (this.resolved)
        return this;
      this.resolvedRequestType = this.parent.lookupType(this.requestType);
      this.resolvedResponseType = this.parent.lookupType(this.responseType);
      return ReflectionObject.prototype.resolve.call(this);
    };
  }
});

// node_modules/protobufjs/src/service.js
var require_service2 = __commonJS({
  "node_modules/protobufjs/src/service.js"(exports2, module2) {
    "use strict";
    module2.exports = Service;
    var Namespace2 = require_namespace();
    ((Service.prototype = Object.create(Namespace2.prototype)).constructor = Service).className = "Service";
    var Method = require_method();
    var util = require_util();
    var rpc = require_rpc();
    function Service(name, options) {
      Namespace2.call(this, name, options);
      this.methods = {};
      this._methodsArray = null;
    }
    Service.fromJSON = function fromJSON(name, json) {
      var service = new Service(name, json.options);
      if (json.methods)
        for (var names = Object.keys(json.methods), i = 0; i < names.length; ++i)
          service.add(Method.fromJSON(names[i], json.methods[names[i]]));
      if (json.nested)
        service.addJSON(json.nested);
      service.comment = json.comment;
      return service;
    };
    Service.prototype.toJSON = function toJSON(toJSONOptions) {
      var inherited = Namespace2.prototype.toJSON.call(this, toJSONOptions);
      var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
      return util.toObject([
        "options",
        inherited && inherited.options || void 0,
        "methods",
        Namespace2.arrayToJSON(this.methodsArray, toJSONOptions) || /* istanbul ignore next */
        {},
        "nested",
        inherited && inherited.nested || void 0,
        "comment",
        keepComments ? this.comment : void 0
      ]);
    };
    Object.defineProperty(Service.prototype, "methodsArray", {
      get: function() {
        return this._methodsArray || (this._methodsArray = util.toArray(this.methods));
      }
    });
    function clearCache(service) {
      service._methodsArray = null;
      return service;
    }
    Service.prototype.get = function get(name) {
      return this.methods[name] || Namespace2.prototype.get.call(this, name);
    };
    Service.prototype.resolveAll = function resolveAll() {
      var methods = this.methodsArray;
      for (var i = 0; i < methods.length; ++i)
        methods[i].resolve();
      return Namespace2.prototype.resolve.call(this);
    };
    Service.prototype.add = function add(object) {
      if (this.get(object.name))
        throw Error("duplicate name '" + object.name + "' in " + this);
      if (object instanceof Method) {
        this.methods[object.name] = object;
        object.parent = this;
        return clearCache(this);
      }
      return Namespace2.prototype.add.call(this, object);
    };
    Service.prototype.remove = function remove(object) {
      if (object instanceof Method) {
        if (this.methods[object.name] !== object)
          throw Error(object + " is not a member of " + this);
        delete this.methods[object.name];
        object.parent = null;
        return clearCache(this);
      }
      return Namespace2.prototype.remove.call(this, object);
    };
    Service.prototype.create = function create(rpcImpl, requestDelimited, responseDelimited) {
      var rpcService = new rpc.Service(rpcImpl, requestDelimited, responseDelimited);
      for (var i = 0, method; i < /* initializes */
      this.methodsArray.length; ++i) {
        var methodName = util.lcFirst((method = this._methodsArray[i]).resolve().name).replace(/[^$\w_]/g, "");
        rpcService[methodName] = util.codegen(["r", "c"], util.isReserved(methodName) ? methodName + "_" : methodName)("return this.rpcCall(m,q,s,r,c)")({
          m: method,
          q: method.resolvedRequestType.ctor,
          s: method.resolvedResponseType.ctor
        });
      }
      return rpcService;
    };
  }
});

// node_modules/protobufjs/src/message.js
var require_message = __commonJS({
  "node_modules/protobufjs/src/message.js"(exports2, module2) {
    "use strict";
    module2.exports = Message;
    var util = require_minimal();
    function Message(properties) {
      if (properties)
        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          this[keys[i]] = properties[keys[i]];
    }
    Message.create = function create(properties) {
      return this.$type.create(properties);
    };
    Message.encode = function encode(message, writer) {
      return this.$type.encode(message, writer);
    };
    Message.encodeDelimited = function encodeDelimited(message, writer) {
      return this.$type.encodeDelimited(message, writer);
    };
    Message.decode = function decode(reader) {
      return this.$type.decode(reader);
    };
    Message.decodeDelimited = function decodeDelimited(reader) {
      return this.$type.decodeDelimited(reader);
    };
    Message.verify = function verify(message) {
      return this.$type.verify(message);
    };
    Message.fromObject = function fromObject(object) {
      return this.$type.fromObject(object);
    };
    Message.toObject = function toObject(message, options) {
      return this.$type.toObject(message, options);
    };
    Message.prototype.toJSON = function toJSON() {
      return this.$type.toObject(this, util.toJSONOptions);
    };
  }
});

// node_modules/protobufjs/src/decoder.js
var require_decoder = __commonJS({
  "node_modules/protobufjs/src/decoder.js"(exports2, module2) {
    "use strict";
    module2.exports = decoder;
    var Enum = require_enum();
    var types = require_types();
    var util = require_util();
    function missing(field) {
      return "missing required '" + field.name + "'";
    }
    function decoder(mtype) {
      var gen = util.codegen(["r", "l"], mtype.name + "$decode")("if(!(r instanceof Reader))")("r=Reader.create(r)")("var c=l===undefined?r.len:r.pos+l,m=new this.ctor" + (mtype.fieldsArray.filter(function(field2) {
        return field2.map;
      }).length ? ",k,value" : ""))("while(r.pos<c){")("var t=r.uint32()");
      if (mtype.group) gen("if((t&7)===4)")("break");
      gen("switch(t>>>3){");
      var i = 0;
      for (; i < /* initializes */
      mtype.fieldsArray.length; ++i) {
        var field = mtype._fieldsArray[i].resolve(), type = field.resolvedType instanceof Enum ? "int32" : field.type, ref = "m" + util.safeProp(field.name);
        gen("case %i:", field.id);
        if (field.map) {
          gen("if(%s===util.emptyObject)", ref)("%s={}", ref)("var c2 = r.uint32()+r.pos");
          if (types.defaults[field.keyType] !== void 0) gen("k=%j", types.defaults[field.keyType]);
          else gen("k=null");
          if (types.defaults[type] !== void 0) gen("value=%j", types.defaults[type]);
          else gen("value=null");
          gen("while(r.pos<c2){")("var tag2=r.uint32()")("switch(tag2>>>3){")("case 1: k=r.%s(); break", field.keyType)("case 2:");
          if (types.basic[type] === void 0) gen("value=types[%i].decode(r,r.uint32())", i);
          else gen("value=r.%s()", type);
          gen("break")("default:")("r.skipType(tag2&7)")("break")("}")("}");
          if (types.long[field.keyType] !== void 0) gen('%s[typeof k==="object"?util.longToHash(k):k]=value', ref);
          else gen("%s[k]=value", ref);
        } else if (field.repeated) {
          gen("if(!(%s&&%s.length))", ref, ref)("%s=[]", ref);
          if (types.packed[type] !== void 0) gen("if((t&7)===2){")("var c2=r.uint32()+r.pos")("while(r.pos<c2)")("%s.push(r.%s())", ref, type)("}else");
          if (types.basic[type] === void 0) gen(field.resolvedType.group ? "%s.push(types[%i].decode(r))" : "%s.push(types[%i].decode(r,r.uint32()))", ref, i);
          else gen("%s.push(r.%s())", ref, type);
        } else if (types.basic[type] === void 0) gen(field.resolvedType.group ? "%s=types[%i].decode(r)" : "%s=types[%i].decode(r,r.uint32())", ref, i);
        else gen("%s=r.%s()", ref, type);
        gen("break");
      }
      gen("default:")("r.skipType(t&7)")("break")("}")("}");
      for (i = 0; i < mtype._fieldsArray.length; ++i) {
        var rfield = mtype._fieldsArray[i];
        if (rfield.required) gen("if(!m.hasOwnProperty(%j))", rfield.name)("throw util.ProtocolError(%j,{instance:m})", missing(rfield));
      }
      return gen("return m");
    }
  }
});

// node_modules/protobufjs/src/verifier.js
var require_verifier = __commonJS({
  "node_modules/protobufjs/src/verifier.js"(exports2, module2) {
    "use strict";
    module2.exports = verifier;
    var Enum = require_enum();
    var util = require_util();
    function invalid(field, expected) {
      return field.name + ": " + expected + (field.repeated && expected !== "array" ? "[]" : field.map && expected !== "object" ? "{k:" + field.keyType + "}" : "") + " expected";
    }
    function genVerifyValue(gen, field, fieldIndex, ref) {
      if (field.resolvedType) {
        if (field.resolvedType instanceof Enum) {
          gen("switch(%s){", ref)("default:")("return%j", invalid(field, "enum value"));
          for (var keys = Object.keys(field.resolvedType.values), j = 0; j < keys.length; ++j) gen("case %i:", field.resolvedType.values[keys[j]]);
          gen("break")("}");
        } else {
          gen("{")("var e=types[%i].verify(%s);", fieldIndex, ref)("if(e)")("return%j+e", field.name + ".")("}");
        }
      } else {
        switch (field.type) {
          case "int32":
          case "uint32":
          case "sint32":
          case "fixed32":
          case "sfixed32":
            gen("if(!util.isInteger(%s))", ref)("return%j", invalid(field, "integer"));
            break;
          case "int64":
          case "uint64":
          case "sint64":
          case "fixed64":
          case "sfixed64":
            gen("if(!util.isInteger(%s)&&!(%s&&util.isInteger(%s.low)&&util.isInteger(%s.high)))", ref, ref, ref, ref)("return%j", invalid(field, "integer|Long"));
            break;
          case "float":
          case "double":
            gen('if(typeof %s!=="number")', ref)("return%j", invalid(field, "number"));
            break;
          case "bool":
            gen('if(typeof %s!=="boolean")', ref)("return%j", invalid(field, "boolean"));
            break;
          case "string":
            gen("if(!util.isString(%s))", ref)("return%j", invalid(field, "string"));
            break;
          case "bytes":
            gen('if(!(%s&&typeof %s.length==="number"||util.isString(%s)))', ref, ref, ref)("return%j", invalid(field, "buffer"));
            break;
        }
      }
      return gen;
    }
    function genVerifyKey(gen, field, ref) {
      switch (field.keyType) {
        case "int32":
        case "uint32":
        case "sint32":
        case "fixed32":
        case "sfixed32":
          gen("if(!util.key32Re.test(%s))", ref)("return%j", invalid(field, "integer key"));
          break;
        case "int64":
        case "uint64":
        case "sint64":
        case "fixed64":
        case "sfixed64":
          gen("if(!util.key64Re.test(%s))", ref)("return%j", invalid(field, "integer|Long key"));
          break;
        case "bool":
          gen("if(!util.key2Re.test(%s))", ref)("return%j", invalid(field, "boolean key"));
          break;
      }
      return gen;
    }
    function verifier(mtype) {
      var gen = util.codegen(["m"], mtype.name + "$verify")('if(typeof m!=="object"||m===null)')("return%j", "object expected");
      var oneofs = mtype.oneofsArray, seenFirstField = {};
      if (oneofs.length) gen("var p={}");
      for (var i = 0; i < /* initializes */
      mtype.fieldsArray.length; ++i) {
        var field = mtype._fieldsArray[i].resolve(), ref = "m" + util.safeProp(field.name);
        if (field.optional) gen("if(%s!=null&&m.hasOwnProperty(%j)){", ref, field.name);
        if (field.map) {
          gen("if(!util.isObject(%s))", ref)("return%j", invalid(field, "object"))("var k=Object.keys(%s)", ref)("for(var i=0;i<k.length;++i){");
          genVerifyKey(gen, field, "k[i]");
          genVerifyValue(gen, field, i, ref + "[k[i]]")("}");
        } else if (field.repeated) {
          gen("if(!Array.isArray(%s))", ref)("return%j", invalid(field, "array"))("for(var i=0;i<%s.length;++i){", ref);
          genVerifyValue(gen, field, i, ref + "[i]")("}");
        } else {
          if (field.partOf) {
            var oneofProp = util.safeProp(field.partOf.name);
            if (seenFirstField[field.partOf.name] === 1) gen("if(p%s===1)", oneofProp)("return%j", field.partOf.name + ": multiple values");
            seenFirstField[field.partOf.name] = 1;
            gen("p%s=1", oneofProp);
          }
          genVerifyValue(gen, field, i, ref);
        }
        if (field.optional) gen("}");
      }
      return gen("return null");
    }
  }
});

// node_modules/protobufjs/src/converter.js
var require_converter = __commonJS({
  "node_modules/protobufjs/src/converter.js"(exports2) {
    "use strict";
    var converter = exports2;
    var Enum = require_enum();
    var util = require_util();
    function genValuePartial_fromObject(gen, field, fieldIndex, prop) {
      if (field.resolvedType) {
        if (field.resolvedType instanceof Enum) {
          gen("switch(d%s){", prop);
          for (var values = field.resolvedType.values, keys = Object.keys(values), i = 0; i < keys.length; ++i) {
            if (field.repeated && values[keys[i]] === field.typeDefault) gen("default:");
            gen("case%j:", keys[i])("case %i:", values[keys[i]])("m%s=%j", prop, values[keys[i]])("break");
          }
          gen("}");
        } else gen('if(typeof d%s!=="object")', prop)("throw TypeError(%j)", field.fullName + ": object expected")("m%s=types[%i].fromObject(d%s)", prop, fieldIndex, prop);
      } else {
        var isUnsigned = false;
        switch (field.type) {
          case "double":
          case "float":
            gen("m%s=Number(d%s)", prop, prop);
            break;
          case "uint32":
          case "fixed32":
            gen("m%s=d%s>>>0", prop, prop);
            break;
          case "int32":
          case "sint32":
          case "sfixed32":
            gen("m%s=d%s|0", prop, prop);
            break;
          case "uint64":
            isUnsigned = true;
          case "int64":
          case "sint64":
          case "fixed64":
          case "sfixed64":
            gen("if(util.Long)")("(m%s=util.Long.fromValue(d%s)).unsigned=%j", prop, prop, isUnsigned)('else if(typeof d%s==="string")', prop)("m%s=parseInt(d%s,10)", prop, prop)('else if(typeof d%s==="number")', prop)("m%s=d%s", prop, prop)('else if(typeof d%s==="object")', prop)("m%s=new util.LongBits(d%s.low>>>0,d%s.high>>>0).toNumber(%s)", prop, prop, prop, isUnsigned ? "true" : "");
            break;
          case "bytes":
            gen('if(typeof d%s==="string")', prop)("util.base64.decode(d%s,m%s=util.newBuffer(util.base64.length(d%s)),0)", prop, prop, prop)("else if(d%s.length)", prop)("m%s=d%s", prop, prop);
            break;
          case "string":
            gen("m%s=String(d%s)", prop, prop);
            break;
          case "bool":
            gen("m%s=Boolean(d%s)", prop, prop);
            break;
        }
      }
      return gen;
    }
    converter.fromObject = function fromObject(mtype) {
      var fields = mtype.fieldsArray;
      var gen = util.codegen(["d"], mtype.name + "$fromObject")("if(d instanceof this.ctor)")("return d");
      if (!fields.length) return gen("return new this.ctor");
      gen("var m=new this.ctor");
      for (var i = 0; i < fields.length; ++i) {
        var field = fields[i].resolve(), prop = util.safeProp(field.name);
        if (field.map) {
          gen("if(d%s){", prop)('if(typeof d%s!=="object")', prop)("throw TypeError(%j)", field.fullName + ": object expected")("m%s={}", prop)("for(var ks=Object.keys(d%s),i=0;i<ks.length;++i){", prop);
          genValuePartial_fromObject(
            gen,
            field,
            /* not sorted */
            i,
            prop + "[ks[i]]"
          )("}")("}");
        } else if (field.repeated) {
          gen("if(d%s){", prop)("if(!Array.isArray(d%s))", prop)("throw TypeError(%j)", field.fullName + ": array expected")("m%s=[]", prop)("for(var i=0;i<d%s.length;++i){", prop);
          genValuePartial_fromObject(
            gen,
            field,
            /* not sorted */
            i,
            prop + "[i]"
          )("}")("}");
        } else {
          if (!(field.resolvedType instanceof Enum)) gen("if(d%s!=null){", prop);
          genValuePartial_fromObject(
            gen,
            field,
            /* not sorted */
            i,
            prop
          );
          if (!(field.resolvedType instanceof Enum)) gen("}");
        }
      }
      return gen("return m");
    };
    function genValuePartial_toObject(gen, field, fieldIndex, prop) {
      if (field.resolvedType) {
        if (field.resolvedType instanceof Enum) gen("d%s=o.enums===String?types[%i].values[m%s]:m%s", prop, fieldIndex, prop, prop);
        else gen("d%s=types[%i].toObject(m%s,o)", prop, fieldIndex, prop);
      } else {
        var isUnsigned = false;
        switch (field.type) {
          case "double":
          case "float":
            gen("d%s=o.json&&!isFinite(m%s)?String(m%s):m%s", prop, prop, prop, prop);
            break;
          case "uint64":
            isUnsigned = true;
          case "int64":
          case "sint64":
          case "fixed64":
          case "sfixed64":
            gen('if(typeof m%s==="number")', prop)("d%s=o.longs===String?String(m%s):m%s", prop, prop, prop)("else")("d%s=o.longs===String?util.Long.prototype.toString.call(m%s):o.longs===Number?new util.LongBits(m%s.low>>>0,m%s.high>>>0).toNumber(%s):m%s", prop, prop, prop, prop, isUnsigned ? "true" : "", prop);
            break;
          case "bytes":
            gen("d%s=o.bytes===String?util.base64.encode(m%s,0,m%s.length):o.bytes===Array?Array.prototype.slice.call(m%s):m%s", prop, prop, prop, prop, prop);
            break;
          default:
            gen("d%s=m%s", prop, prop);
            break;
        }
      }
      return gen;
    }
    converter.toObject = function toObject(mtype) {
      var fields = mtype.fieldsArray.slice().sort(util.compareFieldsById);
      if (!fields.length)
        return util.codegen()("return {}");
      var gen = util.codegen(["m", "o"], mtype.name + "$toObject")("if(!o)")("o={}")("var d={}");
      var repeatedFields = [], mapFields = [], normalFields = [], i = 0;
      for (; i < fields.length; ++i)
        if (!fields[i].partOf)
          (fields[i].resolve().repeated ? repeatedFields : fields[i].map ? mapFields : normalFields).push(fields[i]);
      if (repeatedFields.length) {
        gen("if(o.arrays||o.defaults){");
        for (i = 0; i < repeatedFields.length; ++i) gen("d%s=[]", util.safeProp(repeatedFields[i].name));
        gen("}");
      }
      if (mapFields.length) {
        gen("if(o.objects||o.defaults){");
        for (i = 0; i < mapFields.length; ++i) gen("d%s={}", util.safeProp(mapFields[i].name));
        gen("}");
      }
      if (normalFields.length) {
        gen("if(o.defaults){");
        for (i = 0; i < normalFields.length; ++i) {
          var field = normalFields[i], prop = util.safeProp(field.name);
          if (field.resolvedType instanceof Enum) gen("d%s=o.enums===String?%j:%j", prop, field.resolvedType.valuesById[field.typeDefault], field.typeDefault);
          else if (field.long) gen("if(util.Long){")("var n=new util.Long(%i,%i,%j)", field.typeDefault.low, field.typeDefault.high, field.typeDefault.unsigned)("d%s=o.longs===String?n.toString():o.longs===Number?n.toNumber():n", prop)("}else")("d%s=o.longs===String?%j:%i", prop, field.typeDefault.toString(), field.typeDefault.toNumber());
          else if (field.bytes) {
            var arrayDefault = "[" + Array.prototype.slice.call(field.typeDefault).join(",") + "]";
            gen("if(o.bytes===String)d%s=%j", prop, String.fromCharCode.apply(String, field.typeDefault))("else{")("d%s=%s", prop, arrayDefault)("if(o.bytes!==Array)d%s=util.newBuffer(d%s)", prop, prop)("}");
          } else gen("d%s=%j", prop, field.typeDefault);
        }
        gen("}");
      }
      var hasKs2 = false;
      for (i = 0; i < fields.length; ++i) {
        var field = fields[i], index = mtype._fieldsArray.indexOf(field), prop = util.safeProp(field.name);
        if (field.map) {
          if (!hasKs2) {
            hasKs2 = true;
            gen("var ks2");
          }
          gen("if(m%s&&(ks2=Object.keys(m%s)).length){", prop, prop)("d%s={}", prop)("for(var j=0;j<ks2.length;++j){");
          genValuePartial_toObject(
            gen,
            field,
            /* sorted */
            index,
            prop + "[ks2[j]]"
          )("}");
        } else if (field.repeated) {
          gen("if(m%s&&m%s.length){", prop, prop)("d%s=[]", prop)("for(var j=0;j<m%s.length;++j){", prop);
          genValuePartial_toObject(
            gen,
            field,
            /* sorted */
            index,
            prop + "[j]"
          )("}");
        } else {
          gen("if(m%s!=null&&m.hasOwnProperty(%j)){", prop, field.name);
          genValuePartial_toObject(
            gen,
            field,
            /* sorted */
            index,
            prop
          );
          if (field.partOf) gen("if(o.oneofs)")("d%s=%j", util.safeProp(field.partOf.name), field.name);
        }
        gen("}");
      }
      return gen("return d");
    };
  }
});

// node_modules/protobufjs/src/wrappers.js
var require_wrappers = __commonJS({
  "node_modules/protobufjs/src/wrappers.js"(exports2) {
    "use strict";
    var wrappers = exports2;
    var Message = require_message();
    wrappers[".google.protobuf.Any"] = {
      fromObject: function(object) {
        if (object && object["@type"]) {
          var name = object["@type"].substring(object["@type"].lastIndexOf("/") + 1);
          var type = this.lookup(name);
          if (type) {
            var type_url = object["@type"].charAt(0) === "." ? object["@type"].substr(1) : object["@type"];
            if (type_url.indexOf("/") === -1) {
              type_url = "/" + type_url;
            }
            return this.create({
              type_url,
              value: type.encode(type.fromObject(object)).finish()
            });
          }
        }
        return this.fromObject(object);
      },
      toObject: function(message, options) {
        var googleApi = "type.googleapis.com/";
        var prefix = "";
        var name = "";
        if (options && options.json && message.type_url && message.value) {
          name = message.type_url.substring(message.type_url.lastIndexOf("/") + 1);
          prefix = message.type_url.substring(0, message.type_url.lastIndexOf("/") + 1);
          var type = this.lookup(name);
          if (type)
            message = type.decode(message.value);
        }
        if (!(message instanceof this.ctor) && message instanceof Message) {
          var object = message.$type.toObject(message, options);
          var messageName = message.$type.fullName[0] === "." ? message.$type.fullName.substr(1) : message.$type.fullName;
          if (prefix === "") {
            prefix = googleApi;
          }
          name = prefix + messageName;
          object["@type"] = name;
          return object;
        }
        return this.toObject(message, options);
      }
    };
  }
});

// node_modules/protobufjs/src/type.js
var require_type = __commonJS({
  "node_modules/protobufjs/src/type.js"(exports2, module2) {
    "use strict";
    module2.exports = Type;
    var Namespace2 = require_namespace();
    ((Type.prototype = Object.create(Namespace2.prototype)).constructor = Type).className = "Type";
    var Enum = require_enum();
    var OneOf = require_oneof();
    var Field = require_field();
    var MapField = require_mapfield();
    var Service = require_service2();
    var Message = require_message();
    var Reader = require_reader();
    var Writer2 = require_writer();
    var util = require_util();
    var encoder = require_encoder();
    var decoder = require_decoder();
    var verifier = require_verifier();
    var converter = require_converter();
    var wrappers = require_wrappers();
    function Type(name, options) {
      Namespace2.call(this, name, options);
      this.fields = {};
      this.oneofs = void 0;
      this.extensions = void 0;
      this.reserved = void 0;
      this.group = void 0;
      this._fieldsById = null;
      this._fieldsArray = null;
      this._oneofsArray = null;
      this._ctor = null;
    }
    Object.defineProperties(Type.prototype, {
      /**
       * Message fields by id.
       * @name Type#fieldsById
       * @type {Object.<number,Field>}
       * @readonly
       */
      fieldsById: {
        get: function() {
          if (this._fieldsById)
            return this._fieldsById;
          this._fieldsById = {};
          for (var names = Object.keys(this.fields), i = 0; i < names.length; ++i) {
            var field = this.fields[names[i]], id = field.id;
            if (this._fieldsById[id])
              throw Error("duplicate id " + id + " in " + this);
            this._fieldsById[id] = field;
          }
          return this._fieldsById;
        }
      },
      /**
       * Fields of this message as an array for iteration.
       * @name Type#fieldsArray
       * @type {Field[]}
       * @readonly
       */
      fieldsArray: {
        get: function() {
          return this._fieldsArray || (this._fieldsArray = util.toArray(this.fields));
        }
      },
      /**
       * Oneofs of this message as an array for iteration.
       * @name Type#oneofsArray
       * @type {OneOf[]}
       * @readonly
       */
      oneofsArray: {
        get: function() {
          return this._oneofsArray || (this._oneofsArray = util.toArray(this.oneofs));
        }
      },
      /**
       * The registered constructor, if any registered, otherwise a generic constructor.
       * Assigning a function replaces the internal constructor. If the function does not extend {@link Message} yet, its prototype will be setup accordingly and static methods will be populated. If it already extends {@link Message}, it will just replace the internal constructor.
       * @name Type#ctor
       * @type {Constructor<{}>}
       */
      ctor: {
        get: function() {
          return this._ctor || (this.ctor = Type.generateConstructor(this)());
        },
        set: function(ctor) {
          var prototype = ctor.prototype;
          if (!(prototype instanceof Message)) {
            (ctor.prototype = new Message()).constructor = ctor;
            util.merge(ctor.prototype, prototype);
          }
          ctor.$type = ctor.prototype.$type = this;
          util.merge(ctor, Message, true);
          this._ctor = ctor;
          var i = 0;
          for (; i < /* initializes */
          this.fieldsArray.length; ++i)
            this._fieldsArray[i].resolve();
          var ctorProperties = {};
          for (i = 0; i < /* initializes */
          this.oneofsArray.length; ++i)
            ctorProperties[this._oneofsArray[i].resolve().name] = {
              get: util.oneOfGetter(this._oneofsArray[i].oneof),
              set: util.oneOfSetter(this._oneofsArray[i].oneof)
            };
          if (i)
            Object.defineProperties(ctor.prototype, ctorProperties);
        }
      }
    });
    Type.generateConstructor = function generateConstructor(mtype) {
      var gen = util.codegen(["p"], mtype.name);
      for (var i = 0, field; i < mtype.fieldsArray.length; ++i)
        if ((field = mtype._fieldsArray[i]).map) gen("this%s={}", util.safeProp(field.name));
        else if (field.repeated) gen("this%s=[]", util.safeProp(field.name));
      return gen("if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)")("this[ks[i]]=p[ks[i]]");
    };
    function clearCache(type) {
      type._fieldsById = type._fieldsArray = type._oneofsArray = null;
      delete type.encode;
      delete type.decode;
      delete type.verify;
      return type;
    }
    Type.fromJSON = function fromJSON(name, json) {
      var type = new Type(name, json.options);
      type.extensions = json.extensions;
      type.reserved = json.reserved;
      var names = Object.keys(json.fields), i = 0;
      for (; i < names.length; ++i)
        type.add(
          (typeof json.fields[names[i]].keyType !== "undefined" ? MapField.fromJSON : Field.fromJSON)(names[i], json.fields[names[i]])
        );
      if (json.oneofs)
        for (names = Object.keys(json.oneofs), i = 0; i < names.length; ++i)
          type.add(OneOf.fromJSON(names[i], json.oneofs[names[i]]));
      if (json.nested)
        for (names = Object.keys(json.nested), i = 0; i < names.length; ++i) {
          var nested = json.nested[names[i]];
          type.add(
            // most to least likely
            (nested.id !== void 0 ? Field.fromJSON : nested.fields !== void 0 ? Type.fromJSON : nested.values !== void 0 ? Enum.fromJSON : nested.methods !== void 0 ? Service.fromJSON : Namespace2.fromJSON)(names[i], nested)
          );
        }
      if (json.extensions && json.extensions.length)
        type.extensions = json.extensions;
      if (json.reserved && json.reserved.length)
        type.reserved = json.reserved;
      if (json.group)
        type.group = true;
      if (json.comment)
        type.comment = json.comment;
      return type;
    };
    Type.prototype.toJSON = function toJSON(toJSONOptions) {
      var inherited = Namespace2.prototype.toJSON.call(this, toJSONOptions);
      var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
      return util.toObject([
        "options",
        inherited && inherited.options || void 0,
        "oneofs",
        Namespace2.arrayToJSON(this.oneofsArray, toJSONOptions),
        "fields",
        Namespace2.arrayToJSON(this.fieldsArray.filter(function(obj) {
          return !obj.declaringField;
        }), toJSONOptions) || {},
        "extensions",
        this.extensions && this.extensions.length ? this.extensions : void 0,
        "reserved",
        this.reserved && this.reserved.length ? this.reserved : void 0,
        "group",
        this.group || void 0,
        "nested",
        inherited && inherited.nested || void 0,
        "comment",
        keepComments ? this.comment : void 0
      ]);
    };
    Type.prototype.resolveAll = function resolveAll() {
      var fields = this.fieldsArray, i = 0;
      while (i < fields.length)
        fields[i++].resolve();
      var oneofs = this.oneofsArray;
      i = 0;
      while (i < oneofs.length)
        oneofs[i++].resolve();
      return Namespace2.prototype.resolveAll.call(this);
    };
    Type.prototype.get = function get(name) {
      return this.fields[name] || this.oneofs && this.oneofs[name] || this.nested && this.nested[name] || null;
    };
    Type.prototype.add = function add(object) {
      if (this.get(object.name))
        throw Error("duplicate name '" + object.name + "' in " + this);
      if (object instanceof Field && object.extend === void 0) {
        if (this._fieldsById ? (
          /* istanbul ignore next */
          this._fieldsById[object.id]
        ) : this.fieldsById[object.id])
          throw Error("duplicate id " + object.id + " in " + this);
        if (this.isReservedId(object.id))
          throw Error("id " + object.id + " is reserved in " + this);
        if (this.isReservedName(object.name))
          throw Error("name '" + object.name + "' is reserved in " + this);
        if (object.parent)
          object.parent.remove(object);
        this.fields[object.name] = object;
        object.message = this;
        object.onAdd(this);
        return clearCache(this);
      }
      if (object instanceof OneOf) {
        if (!this.oneofs)
          this.oneofs = {};
        this.oneofs[object.name] = object;
        object.onAdd(this);
        return clearCache(this);
      }
      return Namespace2.prototype.add.call(this, object);
    };
    Type.prototype.remove = function remove(object) {
      if (object instanceof Field && object.extend === void 0) {
        if (!this.fields || this.fields[object.name] !== object)
          throw Error(object + " is not a member of " + this);
        delete this.fields[object.name];
        object.parent = null;
        object.onRemove(this);
        return clearCache(this);
      }
      if (object instanceof OneOf) {
        if (!this.oneofs || this.oneofs[object.name] !== object)
          throw Error(object + " is not a member of " + this);
        delete this.oneofs[object.name];
        object.parent = null;
        object.onRemove(this);
        return clearCache(this);
      }
      return Namespace2.prototype.remove.call(this, object);
    };
    Type.prototype.isReservedId = function isReservedId(id) {
      return Namespace2.isReservedId(this.reserved, id);
    };
    Type.prototype.isReservedName = function isReservedName(name) {
      return Namespace2.isReservedName(this.reserved, name);
    };
    Type.prototype.create = function create(properties) {
      return new this.ctor(properties);
    };
    Type.prototype.setup = function setup() {
      var fullName = this.fullName, types = [];
      for (var i = 0; i < /* initializes */
      this.fieldsArray.length; ++i)
        types.push(this._fieldsArray[i].resolve().resolvedType);
      this.encode = encoder(this)({
        Writer: Writer2,
        types,
        util
      });
      this.decode = decoder(this)({
        Reader,
        types,
        util
      });
      this.verify = verifier(this)({
        types,
        util
      });
      this.fromObject = converter.fromObject(this)({
        types,
        util
      });
      this.toObject = converter.toObject(this)({
        types,
        util
      });
      var wrapper = wrappers[fullName];
      if (wrapper) {
        var originalThis = Object.create(this);
        originalThis.fromObject = this.fromObject;
        this.fromObject = wrapper.fromObject.bind(originalThis);
        originalThis.toObject = this.toObject;
        this.toObject = wrapper.toObject.bind(originalThis);
      }
      return this;
    };
    Type.prototype.encode = function encode_setup(message, writer) {
      return this.setup().encode(message, writer);
    };
    Type.prototype.encodeDelimited = function encodeDelimited(message, writer) {
      return this.encode(message, writer && writer.len ? writer.fork() : writer).ldelim();
    };
    Type.prototype.decode = function decode_setup(reader, length) {
      return this.setup().decode(reader, length);
    };
    Type.prototype.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof Reader))
        reader = Reader.create(reader);
      return this.decode(reader, reader.uint32());
    };
    Type.prototype.verify = function verify_setup(message) {
      return this.setup().verify(message);
    };
    Type.prototype.fromObject = function fromObject(object) {
      return this.setup().fromObject(object);
    };
    Type.prototype.toObject = function toObject(message, options) {
      return this.setup().toObject(message, options);
    };
    Type.d = function decorateType(typeName) {
      return function typeDecorator(target) {
        util.decorateType(target, typeName);
      };
    };
  }
});

// node_modules/protobufjs/src/root.js
var require_root = __commonJS({
  "node_modules/protobufjs/src/root.js"(exports2, module2) {
    "use strict";
    module2.exports = Root;
    var Namespace2 = require_namespace();
    ((Root.prototype = Object.create(Namespace2.prototype)).constructor = Root).className = "Root";
    var Field = require_field();
    var Enum = require_enum();
    var OneOf = require_oneof();
    var util = require_util();
    var Type;
    var parse2;
    var common;
    function Root(options) {
      Namespace2.call(this, "", options);
      this.deferred = [];
      this.files = [];
    }
    Root.fromJSON = function fromJSON(json, root) {
      if (!root)
        root = new Root();
      if (json.options)
        root.setOptions(json.options);
      return root.addJSON(json.nested);
    };
    Root.prototype.resolvePath = util.path.resolve;
    Root.prototype.fetch = util.fetch;
    function SYNC() {
    }
    Root.prototype.load = function load(filename, options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = void 0;
      }
      var self2 = this;
      if (!callback)
        return util.asPromise(load, self2, filename, options);
      var sync = callback === SYNC;
      function finish(err, root) {
        if (!callback)
          return;
        var cb = callback;
        callback = null;
        if (sync)
          throw err;
        cb(err, root);
      }
      function getBundledFileName(filename2) {
        var idx = filename2.lastIndexOf("google/protobuf/");
        if (idx > -1) {
          var altname = filename2.substring(idx);
          if (altname in common) return altname;
        }
        return null;
      }
      function process2(filename2, source) {
        try {
          if (util.isString(source) && source.charAt(0) === "{")
            source = JSON.parse(source);
          if (!util.isString(source))
            self2.setOptions(source.options).addJSON(source.nested);
          else {
            parse2.filename = filename2;
            var parsed = parse2(source, self2, options), resolved3, i2 = 0;
            if (parsed.imports) {
              for (; i2 < parsed.imports.length; ++i2)
                if (resolved3 = getBundledFileName(parsed.imports[i2]) || self2.resolvePath(filename2, parsed.imports[i2]))
                  fetch2(resolved3);
            }
            if (parsed.weakImports) {
              for (i2 = 0; i2 < parsed.weakImports.length; ++i2)
                if (resolved3 = getBundledFileName(parsed.weakImports[i2]) || self2.resolvePath(filename2, parsed.weakImports[i2]))
                  fetch2(resolved3, true);
            }
          }
        } catch (err) {
          finish(err);
        }
        if (!sync && !queued)
          finish(null, self2);
      }
      function fetch2(filename2, weak) {
        if (self2.files.indexOf(filename2) > -1)
          return;
        self2.files.push(filename2);
        if (filename2 in common) {
          if (sync)
            process2(filename2, common[filename2]);
          else {
            ++queued;
            setTimeout(function() {
              --queued;
              process2(filename2, common[filename2]);
            });
          }
          return;
        }
        if (sync) {
          var source;
          try {
            source = util.fs.readFileSync(filename2).toString("utf8");
          } catch (err) {
            if (!weak)
              finish(err);
            return;
          }
          process2(filename2, source);
        } else {
          ++queued;
          self2.fetch(filename2, function(err, source2) {
            --queued;
            if (!callback)
              return;
            if (err) {
              if (!weak)
                finish(err);
              else if (!queued)
                finish(null, self2);
              return;
            }
            process2(filename2, source2);
          });
        }
      }
      var queued = 0;
      if (util.isString(filename))
        filename = [filename];
      for (var i = 0, resolved2; i < filename.length; ++i)
        if (resolved2 = self2.resolvePath("", filename[i]))
          fetch2(resolved2);
      if (sync)
        return self2;
      if (!queued)
        finish(null, self2);
      return void 0;
    };
    Root.prototype.loadSync = function loadSync(filename, options) {
      if (!util.isNode)
        throw Error("not supported");
      return this.load(filename, options, SYNC);
    };
    Root.prototype.resolveAll = function resolveAll() {
      if (this.deferred.length)
        throw Error("unresolvable extensions: " + this.deferred.map(function(field) {
          return "'extend " + field.extend + "' in " + field.parent.fullName;
        }).join(", "));
      return Namespace2.prototype.resolveAll.call(this);
    };
    var exposeRe = /^[A-Z]/;
    function tryHandleExtension(root, field) {
      var extendedType = field.parent.lookup(field.extend);
      if (extendedType) {
        var sisterField = new Field(field.fullName, field.id, field.type, field.rule, void 0, field.options);
        sisterField.declaringField = field;
        field.extensionField = sisterField;
        extendedType.add(sisterField);
        return true;
      }
      return false;
    }
    Root.prototype._handleAdd = function _handleAdd(object) {
      if (object instanceof Field) {
        if (
          /* an extension field (implies not part of a oneof) */
          object.extend !== void 0 && /* not already handled */
          !object.extensionField
        ) {
          if (!tryHandleExtension(this, object))
            this.deferred.push(object);
        }
      } else if (object instanceof Enum) {
        if (exposeRe.test(object.name))
          object.parent[object.name] = object.values;
      } else if (!(object instanceof OneOf)) {
        if (object instanceof Type)
          for (var i = 0; i < this.deferred.length; )
            if (tryHandleExtension(this, this.deferred[i]))
              this.deferred.splice(i, 1);
            else
              ++i;
        for (var j = 0; j < /* initializes */
        object.nestedArray.length; ++j)
          this._handleAdd(object._nestedArray[j]);
        if (exposeRe.test(object.name))
          object.parent[object.name] = object;
      }
    };
    Root.prototype._handleRemove = function _handleRemove(object) {
      if (object instanceof Field) {
        if (
          /* an extension field */
          object.extend !== void 0
        ) {
          if (
            /* already handled */
            object.extensionField
          ) {
            object.extensionField.parent.remove(object.extensionField);
            object.extensionField = null;
          } else {
            var index = this.deferred.indexOf(object);
            if (index > -1)
              this.deferred.splice(index, 1);
          }
        }
      } else if (object instanceof Enum) {
        if (exposeRe.test(object.name))
          delete object.parent[object.name];
      } else if (object instanceof Namespace2) {
        for (var i = 0; i < /* initializes */
        object.nestedArray.length; ++i)
          this._handleRemove(object._nestedArray[i]);
        if (exposeRe.test(object.name))
          delete object.parent[object.name];
      }
    };
    Root._configure = function(Type_, parse_, common_) {
      Type = Type_;
      parse2 = parse_;
      common = common_;
    };
  }
});

// node_modules/protobufjs/src/util.js
var require_util = __commonJS({
  "node_modules/protobufjs/src/util.js"(exports2, module2) {
    "use strict";
    var util = module2.exports = require_minimal();
    var roots = require_roots();
    var Type;
    var Enum;
    util.codegen = require_codegen();
    util.fetch = require_fetch();
    util.path = require_path();
    util.fs = util.inquire("fs");
    util.toArray = function toArray2(object) {
      if (object) {
        var keys = Object.keys(object), array = new Array(keys.length), index = 0;
        while (index < keys.length)
          array[index] = object[keys[index++]];
        return array;
      }
      return [];
    };
    util.toObject = function toObject(array) {
      var object = {}, index = 0;
      while (index < array.length) {
        var key = array[index++], val = array[index++];
        if (val !== void 0)
          object[key] = val;
      }
      return object;
    };
    var safePropBackslashRe = /\\/g;
    var safePropQuoteRe = /"/g;
    util.isReserved = function isReserved(name) {
      return /^(?:do|if|in|for|let|new|try|var|case|else|enum|eval|false|null|this|true|void|with|break|catch|class|const|super|throw|while|yield|delete|export|import|public|return|static|switch|typeof|default|extends|finally|package|private|continue|debugger|function|arguments|interface|protected|implements|instanceof)$/.test(name);
    };
    util.safeProp = function safeProp(prop) {
      if (!/^[$\w_]+$/.test(prop) || util.isReserved(prop))
        return '["' + prop.replace(safePropBackslashRe, "\\\\").replace(safePropQuoteRe, '\\"') + '"]';
      return "." + prop;
    };
    util.ucFirst = function ucFirst(str) {
      return str.charAt(0).toUpperCase() + str.substring(1);
    };
    var camelCaseRe = /_([a-z])/g;
    util.camelCase = function camelCase(str) {
      return str.substring(0, 1) + str.substring(1).replace(camelCaseRe, function($0, $1) {
        return $1.toUpperCase();
      });
    };
    util.compareFieldsById = function compareFieldsById(a2, b2) {
      return a2.id - b2.id;
    };
    util.decorateType = function decorateType(ctor, typeName) {
      if (ctor.$type) {
        if (typeName && ctor.$type.name !== typeName) {
          util.decorateRoot.remove(ctor.$type);
          ctor.$type.name = typeName;
          util.decorateRoot.add(ctor.$type);
        }
        return ctor.$type;
      }
      if (!Type)
        Type = require_type();
      var type = new Type(typeName || ctor.name);
      util.decorateRoot.add(type);
      type.ctor = ctor;
      Object.defineProperty(ctor, "$type", { value: type, enumerable: false });
      Object.defineProperty(ctor.prototype, "$type", { value: type, enumerable: false });
      return type;
    };
    var decorateEnumIndex = 0;
    util.decorateEnum = function decorateEnum(object) {
      if (object.$type)
        return object.$type;
      if (!Enum)
        Enum = require_enum();
      var enm = new Enum("Enum" + decorateEnumIndex++, object);
      util.decorateRoot.add(enm);
      Object.defineProperty(object, "$type", { value: enm, enumerable: false });
      return enm;
    };
    util.setProperty = function setProperty(dst, path, value) {
      function setProp(dst2, path2, value2) {
        var part = path2.shift();
        if (part === "__proto__" || part === "prototype") {
          return dst2;
        }
        if (path2.length > 0) {
          dst2[part] = setProp(dst2[part] || {}, path2, value2);
        } else {
          var prevValue = dst2[part];
          if (prevValue)
            value2 = [].concat(prevValue).concat(value2);
          dst2[part] = value2;
        }
        return dst2;
      }
      if (typeof dst !== "object")
        throw TypeError("dst must be an object");
      if (!path)
        throw TypeError("path must be specified");
      path = path.split(".");
      return setProp(dst, path, value);
    };
    Object.defineProperty(util, "decorateRoot", {
      get: function() {
        return roots["decorated"] || (roots["decorated"] = new (require_root())());
      }
    });
  }
});

// node_modules/protobufjs/src/object.js
var require_object = __commonJS({
  "node_modules/protobufjs/src/object.js"(exports2, module2) {
    "use strict";
    module2.exports = ReflectionObject;
    ReflectionObject.className = "ReflectionObject";
    var util = require_util();
    var Root;
    function ReflectionObject(name, options) {
      if (!util.isString(name))
        throw TypeError("name must be a string");
      if (options && !util.isObject(options))
        throw TypeError("options must be an object");
      this.options = options;
      this.parsedOptions = null;
      this.name = name;
      this.parent = null;
      this.resolved = false;
      this.comment = null;
      this.filename = null;
    }
    Object.defineProperties(ReflectionObject.prototype, {
      /**
       * Reference to the root namespace.
       * @name ReflectionObject#root
       * @type {Root}
       * @readonly
       */
      root: {
        get: function() {
          var ptr = this;
          while (ptr.parent !== null)
            ptr = ptr.parent;
          return ptr;
        }
      },
      /**
       * Full name including leading dot.
       * @name ReflectionObject#fullName
       * @type {string}
       * @readonly
       */
      fullName: {
        get: function() {
          var path = [this.name], ptr = this.parent;
          while (ptr) {
            path.unshift(ptr.name);
            ptr = ptr.parent;
          }
          return path.join(".");
        }
      }
    });
    ReflectionObject.prototype.toJSON = /* istanbul ignore next */
    function toJSON() {
      throw Error();
    };
    ReflectionObject.prototype.onAdd = function onAdd(parent) {
      if (this.parent && this.parent !== parent)
        this.parent.remove(this);
      this.parent = parent;
      this.resolved = false;
      var root = parent.root;
      if (root instanceof Root)
        root._handleAdd(this);
    };
    ReflectionObject.prototype.onRemove = function onRemove(parent) {
      var root = parent.root;
      if (root instanceof Root)
        root._handleRemove(this);
      this.parent = null;
      this.resolved = false;
    };
    ReflectionObject.prototype.resolve = function resolve() {
      if (this.resolved)
        return this;
      if (this.root instanceof Root)
        this.resolved = true;
      return this;
    };
    ReflectionObject.prototype.getOption = function getOption(name) {
      if (this.options)
        return this.options[name];
      return void 0;
    };
    ReflectionObject.prototype.setOption = function setOption(name, value, ifNotSet) {
      if (!ifNotSet || !this.options || this.options[name] === void 0)
        (this.options || (this.options = {}))[name] = value;
      return this;
    };
    ReflectionObject.prototype.setParsedOption = function setParsedOption(name, value, propName) {
      if (!this.parsedOptions) {
        this.parsedOptions = [];
      }
      var parsedOptions = this.parsedOptions;
      if (propName) {
        var opt = parsedOptions.find(function(opt2) {
          return Object.prototype.hasOwnProperty.call(opt2, name);
        });
        if (opt) {
          var newValue = opt[name];
          util.setProperty(newValue, propName, value);
        } else {
          opt = {};
          opt[name] = util.setProperty({}, propName, value);
          parsedOptions.push(opt);
        }
      } else {
        var newOpt = {};
        newOpt[name] = value;
        parsedOptions.push(newOpt);
      }
      return this;
    };
    ReflectionObject.prototype.setOptions = function setOptions(options, ifNotSet) {
      if (options)
        for (var keys = Object.keys(options), i = 0; i < keys.length; ++i)
          this.setOption(keys[i], options[keys[i]], ifNotSet);
      return this;
    };
    ReflectionObject.prototype.toString = function toString() {
      var className = this.constructor.className, fullName = this.fullName;
      if (fullName.length)
        return className + " " + fullName;
      return className;
    };
    ReflectionObject._configure = function(Root_) {
      Root = Root_;
    };
  }
});

// node_modules/protobufjs/src/enum.js
var require_enum = __commonJS({
  "node_modules/protobufjs/src/enum.js"(exports2, module2) {
    "use strict";
    module2.exports = Enum;
    var ReflectionObject = require_object();
    ((Enum.prototype = Object.create(ReflectionObject.prototype)).constructor = Enum).className = "Enum";
    var Namespace2 = require_namespace();
    var util = require_util();
    function Enum(name, values, options, comment, comments) {
      ReflectionObject.call(this, name, options);
      if (values && typeof values !== "object")
        throw TypeError("values must be an object");
      this.valuesById = {};
      this.values = Object.create(this.valuesById);
      this.comment = comment;
      this.comments = comments || {};
      this.reserved = void 0;
      if (values) {
        for (var keys = Object.keys(values), i = 0; i < keys.length; ++i)
          if (typeof values[keys[i]] === "number")
            this.valuesById[this.values[keys[i]] = values[keys[i]]] = keys[i];
      }
    }
    Enum.fromJSON = function fromJSON(name, json) {
      var enm = new Enum(name, json.values, json.options, json.comment, json.comments);
      enm.reserved = json.reserved;
      return enm;
    };
    Enum.prototype.toJSON = function toJSON(toJSONOptions) {
      var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
      return util.toObject([
        "options",
        this.options,
        "values",
        this.values,
        "reserved",
        this.reserved && this.reserved.length ? this.reserved : void 0,
        "comment",
        keepComments ? this.comment : void 0,
        "comments",
        keepComments ? this.comments : void 0
      ]);
    };
    Enum.prototype.add = function add(name, id, comment) {
      if (!util.isString(name))
        throw TypeError("name must be a string");
      if (!util.isInteger(id))
        throw TypeError("id must be an integer");
      if (this.values[name] !== void 0)
        throw Error("duplicate name '" + name + "' in " + this);
      if (this.isReservedId(id))
        throw Error("id " + id + " is reserved in " + this);
      if (this.isReservedName(name))
        throw Error("name '" + name + "' is reserved in " + this);
      if (this.valuesById[id] !== void 0) {
        if (!(this.options && this.options.allow_alias))
          throw Error("duplicate id " + id + " in " + this);
        this.values[name] = id;
      } else
        this.valuesById[this.values[name] = id] = name;
      this.comments[name] = comment || null;
      return this;
    };
    Enum.prototype.remove = function remove(name) {
      if (!util.isString(name))
        throw TypeError("name must be a string");
      var val = this.values[name];
      if (val == null)
        throw Error("name '" + name + "' does not exist in " + this);
      delete this.valuesById[val];
      delete this.values[name];
      delete this.comments[name];
      return this;
    };
    Enum.prototype.isReservedId = function isReservedId(id) {
      return Namespace2.isReservedId(this.reserved, id);
    };
    Enum.prototype.isReservedName = function isReservedName(name) {
      return Namespace2.isReservedName(this.reserved, name);
    };
  }
});

// node_modules/protobufjs/src/encoder.js
var require_encoder = __commonJS({
  "node_modules/protobufjs/src/encoder.js"(exports2, module2) {
    "use strict";
    module2.exports = encoder;
    var Enum = require_enum();
    var types = require_types();
    var util = require_util();
    function genTypePartial(gen, field, fieldIndex, ref) {
      return field.resolvedType.group ? gen("types[%i].encode(%s,w.uint32(%i)).uint32(%i)", fieldIndex, ref, (field.id << 3 | 3) >>> 0, (field.id << 3 | 4) >>> 0) : gen("types[%i].encode(%s,w.uint32(%i).fork()).ldelim()", fieldIndex, ref, (field.id << 3 | 2) >>> 0);
    }
    function encoder(mtype) {
      var gen = util.codegen(["m", "w"], mtype.name + "$encode")("if(!w)")("w=Writer.create()");
      var i, ref;
      var fields = (
        /* initializes */
        mtype.fieldsArray.slice().sort(util.compareFieldsById)
      );
      for (var i = 0; i < fields.length; ++i) {
        var field = fields[i].resolve(), index = mtype._fieldsArray.indexOf(field), type = field.resolvedType instanceof Enum ? "int32" : field.type, wireType = types.basic[type];
        ref = "m" + util.safeProp(field.name);
        if (field.map) {
          gen("if(%s!=null&&Object.hasOwnProperty.call(m,%j)){", ref, field.name)("for(var ks=Object.keys(%s),i=0;i<ks.length;++i){", ref)("w.uint32(%i).fork().uint32(%i).%s(ks[i])", (field.id << 3 | 2) >>> 0, 8 | types.mapKey[field.keyType], field.keyType);
          if (wireType === void 0) gen("types[%i].encode(%s[ks[i]],w.uint32(18).fork()).ldelim().ldelim()", index, ref);
          else gen(".uint32(%i).%s(%s[ks[i]]).ldelim()", 16 | wireType, type, ref);
          gen("}")("}");
        } else if (field.repeated) {
          gen("if(%s!=null&&%s.length){", ref, ref);
          if (field.packed && types.packed[type] !== void 0) {
            gen("w.uint32(%i).fork()", (field.id << 3 | 2) >>> 0)("for(var i=0;i<%s.length;++i)", ref)("w.%s(%s[i])", type, ref)("w.ldelim()");
          } else {
            gen("for(var i=0;i<%s.length;++i)", ref);
            if (wireType === void 0)
              genTypePartial(gen, field, index, ref + "[i]");
            else gen("w.uint32(%i).%s(%s[i])", (field.id << 3 | wireType) >>> 0, type, ref);
          }
          gen("}");
        } else {
          if (field.optional) gen("if(%s!=null&&Object.hasOwnProperty.call(m,%j))", ref, field.name);
          if (wireType === void 0)
            genTypePartial(gen, field, index, ref);
          else gen("w.uint32(%i).%s(%s)", (field.id << 3 | wireType) >>> 0, type, ref);
        }
      }
      return gen("return w");
    }
  }
});

// node_modules/protobufjs/src/index-light.js
var require_index_light = __commonJS({
  "node_modules/protobufjs/src/index-light.js"(exports2, module2) {
    "use strict";
    var protobuf = module2.exports = require_index_minimal();
    protobuf.build = "light";
    function load(filename, root, callback) {
      if (typeof root === "function") {
        callback = root;
        root = new protobuf.Root();
      } else if (!root)
        root = new protobuf.Root();
      return root.load(filename, callback);
    }
    protobuf.load = load;
    function loadSync(filename, root) {
      if (!root)
        root = new protobuf.Root();
      return root.loadSync(filename);
    }
    protobuf.loadSync = loadSync;
    protobuf.encoder = require_encoder();
    protobuf.decoder = require_decoder();
    protobuf.verifier = require_verifier();
    protobuf.converter = require_converter();
    protobuf.ReflectionObject = require_object();
    protobuf.Namespace = require_namespace();
    protobuf.Root = require_root();
    protobuf.Enum = require_enum();
    protobuf.Type = require_type();
    protobuf.Field = require_field();
    protobuf.OneOf = require_oneof();
    protobuf.MapField = require_mapfield();
    protobuf.Service = require_service2();
    protobuf.Method = require_method();
    protobuf.Message = require_message();
    protobuf.wrappers = require_wrappers();
    protobuf.types = require_types();
    protobuf.util = require_util();
    protobuf.ReflectionObject._configure(protobuf.Root);
    protobuf.Namespace._configure(protobuf.Type, protobuf.Service, protobuf.Enum);
    protobuf.Root._configure(protobuf.Type);
    protobuf.Field._configure(protobuf.Type);
  }
});

// node_modules/protobufjs/src/tokenize.js
var require_tokenize = __commonJS({
  "node_modules/protobufjs/src/tokenize.js"(exports2, module2) {
    "use strict";
    module2.exports = tokenize;
    var delimRe = /[\s{}=;:[\],'"()<>]/g;
    var stringDoubleRe = /(?:"([^"\\]*(?:\\.[^"\\]*)*)")/g;
    var stringSingleRe = /(?:'([^'\\]*(?:\\.[^'\\]*)*)')/g;
    var setCommentRe = /^ *[*/]+ */;
    var setCommentAltRe = /^\s*\*?\/*/;
    var setCommentSplitRe = /\n/g;
    var whitespaceRe = /\s/;
    var unescapeRe = /\\(.?)/g;
    var unescapeMap = {
      "0": "\0",
      "r": "\r",
      "n": "\n",
      "t": "	"
    };
    function unescape2(str) {
      return str.replace(unescapeRe, function($0, $1) {
        switch ($1) {
          case "\\":
          case "":
            return $1;
          default:
            return unescapeMap[$1] || "";
        }
      });
    }
    tokenize.unescape = unescape2;
    function tokenize(source, alternateCommentMode) {
      source = source.toString();
      var offset = 0, length = source.length, line = 1, commentType = null, commentText = null, commentLine = 0, commentLineEmpty = false, commentIsLeading = false;
      var stack = [];
      var stringDelim = null;
      function illegal(subject) {
        return Error("illegal " + subject + " (line " + line + ")");
      }
      function readString() {
        var re = stringDelim === "'" ? stringSingleRe : stringDoubleRe;
        re.lastIndex = offset - 1;
        var match = re.exec(source);
        if (!match)
          throw illegal("string");
        offset = re.lastIndex;
        push(stringDelim);
        stringDelim = null;
        return unescape2(match[1]);
      }
      function charAt(pos) {
        return source.charAt(pos);
      }
      function setComment(start, end, isLeading) {
        commentType = source.charAt(start++);
        commentLine = line;
        commentLineEmpty = false;
        commentIsLeading = isLeading;
        var lookback;
        if (alternateCommentMode) {
          lookback = 2;
        } else {
          lookback = 3;
        }
        var commentOffset = start - lookback, c2;
        do {
          if (--commentOffset < 0 || (c2 = source.charAt(commentOffset)) === "\n") {
            commentLineEmpty = true;
            break;
          }
        } while (c2 === " " || c2 === "	");
        var lines = source.substring(start, end).split(setCommentSplitRe);
        for (var i = 0; i < lines.length; ++i)
          lines[i] = lines[i].replace(alternateCommentMode ? setCommentAltRe : setCommentRe, "").trim();
        commentText = lines.join("\n").trim();
      }
      function isDoubleSlashCommentLine(startOffset) {
        var endOffset = findEndOfLine(startOffset);
        var lineText = source.substring(startOffset, endOffset);
        var isComment = /^\s*\/{1,2}/.test(lineText);
        return isComment;
      }
      function findEndOfLine(cursor) {
        var endOffset = cursor;
        while (endOffset < length && charAt(endOffset) !== "\n") {
          endOffset++;
        }
        return endOffset;
      }
      function next() {
        if (stack.length > 0)
          return stack.shift();
        if (stringDelim)
          return readString();
        var repeat2, prev, curr, start, isDoc, isLeadingComment = offset === 0;
        do {
          if (offset === length)
            return null;
          repeat2 = false;
          while (whitespaceRe.test(curr = charAt(offset))) {
            if (curr === "\n") {
              isLeadingComment = true;
              ++line;
            }
            if (++offset === length)
              return null;
          }
          if (charAt(offset) === "/") {
            if (++offset === length) {
              throw illegal("comment");
            }
            if (charAt(offset) === "/") {
              if (!alternateCommentMode) {
                isDoc = charAt(start = offset + 1) === "/";
                while (charAt(++offset) !== "\n") {
                  if (offset === length) {
                    return null;
                  }
                }
                ++offset;
                if (isDoc) {
                  setComment(start, offset - 1, isLeadingComment);
                }
                ++line;
                repeat2 = true;
              } else {
                start = offset;
                isDoc = false;
                if (isDoubleSlashCommentLine(offset)) {
                  isDoc = true;
                  do {
                    offset = findEndOfLine(offset);
                    if (offset === length) {
                      break;
                    }
                    offset++;
                  } while (isDoubleSlashCommentLine(offset));
                } else {
                  offset = Math.min(length, findEndOfLine(offset) + 1);
                }
                if (isDoc) {
                  setComment(start, offset, isLeadingComment);
                }
                line++;
                repeat2 = true;
              }
            } else if ((curr = charAt(offset)) === "*") {
              start = offset + 1;
              isDoc = alternateCommentMode || charAt(start) === "*";
              do {
                if (curr === "\n") {
                  ++line;
                }
                if (++offset === length) {
                  throw illegal("comment");
                }
                prev = curr;
                curr = charAt(offset);
              } while (prev !== "*" || curr !== "/");
              ++offset;
              if (isDoc) {
                setComment(start, offset - 2, isLeadingComment);
              }
              repeat2 = true;
            } else {
              return "/";
            }
          }
        } while (repeat2);
        var end = offset;
        delimRe.lastIndex = 0;
        var delim = delimRe.test(charAt(end++));
        if (!delim)
          while (end < length && !delimRe.test(charAt(end)))
            ++end;
        var token = source.substring(offset, offset = end);
        if (token === '"' || token === "'")
          stringDelim = token;
        return token;
      }
      function push(token) {
        stack.push(token);
      }
      function peek() {
        if (!stack.length) {
          var token = next();
          if (token === null)
            return null;
          push(token);
        }
        return stack[0];
      }
      function skip2(expected, optional) {
        var actual = peek(), equals = actual === expected;
        if (equals) {
          next();
          return true;
        }
        if (!optional)
          throw illegal("token '" + actual + "', '" + expected + "' expected");
        return false;
      }
      function cmnt(trailingLine) {
        var ret = null;
        if (trailingLine === void 0) {
          if (commentLine === line - 1 && (alternateCommentMode || commentType === "*" || commentLineEmpty)) {
            ret = commentIsLeading ? commentText : null;
          }
        } else {
          if (commentLine < trailingLine) {
            peek();
          }
          if (commentLine === trailingLine && !commentLineEmpty && (alternateCommentMode || commentType === "/")) {
            ret = commentIsLeading ? null : commentText;
          }
        }
        return ret;
      }
      return Object.defineProperty({
        next,
        peek,
        push,
        skip: skip2,
        cmnt
      }, "line", {
        get: function() {
          return line;
        }
      });
    }
  }
});

// node_modules/protobufjs/src/parse.js
var require_parse = __commonJS({
  "node_modules/protobufjs/src/parse.js"(exports2, module2) {
    "use strict";
    module2.exports = parse2;
    parse2.filename = null;
    parse2.defaults = { keepCase: false };
    var tokenize = require_tokenize();
    var Root = require_root();
    var Type = require_type();
    var Field = require_field();
    var MapField = require_mapfield();
    var OneOf = require_oneof();
    var Enum = require_enum();
    var Service = require_service2();
    var Method = require_method();
    var types = require_types();
    var util = require_util();
    var base10Re = /^[1-9][0-9]*$/;
    var base10NegRe = /^-?[1-9][0-9]*$/;
    var base16Re = /^0[x][0-9a-fA-F]+$/;
    var base16NegRe = /^-?0[x][0-9a-fA-F]+$/;
    var base8Re = /^0[0-7]+$/;
    var base8NegRe = /^-?0[0-7]+$/;
    var numberRe = /^(?![eE])[0-9]*(?:\.[0-9]*)?(?:[eE][+-]?[0-9]+)?$/;
    var nameRe = /^[a-zA-Z_][a-zA-Z_0-9]*$/;
    var typeRefRe = /^(?:\.?[a-zA-Z_][a-zA-Z_0-9]*)(?:\.[a-zA-Z_][a-zA-Z_0-9]*)*$/;
    var fqTypeRefRe = /^(?:\.[a-zA-Z_][a-zA-Z_0-9]*)+$/;
    function parse2(source, root, options) {
      if (!(root instanceof Root)) {
        options = root;
        root = new Root();
      }
      if (!options)
        options = parse2.defaults;
      var preferTrailingComment = options.preferTrailingComment || false;
      var tn = tokenize(source, options.alternateCommentMode || false), next = tn.next, push = tn.push, peek = tn.peek, skip2 = tn.skip, cmnt = tn.cmnt;
      var head = true, pkg, imports, weakImports, syntax, isProto3 = false;
      var ptr = root;
      var applyCase = options.keepCase ? function(name) {
        return name;
      } : util.camelCase;
      function illegal(token2, name, insideTryCatch) {
        var filename = parse2.filename;
        if (!insideTryCatch)
          parse2.filename = null;
        return Error("illegal " + (name || "token") + " '" + token2 + "' (" + (filename ? filename + ", " : "") + "line " + tn.line + ")");
      }
      function readString() {
        var values = [], token2;
        do {
          if ((token2 = next()) !== '"' && token2 !== "'")
            throw illegal(token2);
          values.push(next());
          skip2(token2);
          token2 = peek();
        } while (token2 === '"' || token2 === "'");
        return values.join("");
      }
      function readValue(acceptTypeRef) {
        var token2 = next();
        switch (token2) {
          case "'":
          case '"':
            push(token2);
            return readString();
          case "true":
          case "TRUE":
            return true;
          case "false":
          case "FALSE":
            return false;
        }
        try {
          return parseNumber(
            token2,
            /* insideTryCatch */
            true
          );
        } catch (e2) {
          if (acceptTypeRef && typeRefRe.test(token2))
            return token2;
          throw illegal(token2, "value");
        }
      }
      function readRanges(target, acceptStrings) {
        var token2, start;
        do {
          if (acceptStrings && ((token2 = peek()) === '"' || token2 === "'"))
            target.push(readString());
          else
            target.push([start = parseId(next()), skip2("to", true) ? parseId(next()) : start]);
        } while (skip2(",", true));
        skip2(";");
      }
      function parseNumber(token2, insideTryCatch) {
        var sign = 1;
        if (token2.charAt(0) === "-") {
          sign = -1;
          token2 = token2.substring(1);
        }
        switch (token2) {
          case "inf":
          case "INF":
          case "Inf":
            return sign * Infinity;
          case "nan":
          case "NAN":
          case "Nan":
          case "NaN":
            return NaN;
          case "0":
            return 0;
        }
        if (base10Re.test(token2))
          return sign * parseInt(token2, 10);
        if (base16Re.test(token2))
          return sign * parseInt(token2, 16);
        if (base8Re.test(token2))
          return sign * parseInt(token2, 8);
        if (numberRe.test(token2))
          return sign * parseFloat(token2);
        throw illegal(token2, "number", insideTryCatch);
      }
      function parseId(token2, acceptNegative) {
        switch (token2) {
          case "max":
          case "MAX":
          case "Max":
            return 536870911;
          case "0":
            return 0;
        }
        if (!acceptNegative && token2.charAt(0) === "-")
          throw illegal(token2, "id");
        if (base10NegRe.test(token2))
          return parseInt(token2, 10);
        if (base16NegRe.test(token2))
          return parseInt(token2, 16);
        if (base8NegRe.test(token2))
          return parseInt(token2, 8);
        throw illegal(token2, "id");
      }
      function parsePackage() {
        if (pkg !== void 0)
          throw illegal("package");
        pkg = next();
        if (!typeRefRe.test(pkg))
          throw illegal(pkg, "name");
        ptr = ptr.define(pkg);
        skip2(";");
      }
      function parseImport() {
        var token2 = peek();
        var whichImports;
        switch (token2) {
          case "weak":
            whichImports = weakImports || (weakImports = []);
            next();
            break;
          case "public":
            next();
          default:
            whichImports = imports || (imports = []);
            break;
        }
        token2 = readString();
        skip2(";");
        whichImports.push(token2);
      }
      function parseSyntax() {
        skip2("=");
        syntax = readString();
        isProto3 = syntax === "proto3";
        if (!isProto3 && syntax !== "proto2")
          throw illegal(syntax, "syntax");
        skip2(";");
      }
      function parseCommon(parent, token2) {
        switch (token2) {
          case "option":
            parseOption(parent, token2);
            skip2(";");
            return true;
          case "message":
            parseType(parent, token2);
            return true;
          case "enum":
            parseEnum(parent, token2);
            return true;
          case "service":
            parseService(parent, token2);
            return true;
          case "extend":
            parseExtension(parent, token2);
            return true;
        }
        return false;
      }
      function ifBlock(obj, fnIf, fnElse) {
        var trailingLine = tn.line;
        if (obj) {
          if (typeof obj.comment !== "string") {
            obj.comment = cmnt();
          }
          obj.filename = parse2.filename;
        }
        if (skip2("{", true)) {
          var token2;
          while ((token2 = next()) !== "}")
            fnIf(token2);
          skip2(";", true);
        } else {
          if (fnElse)
            fnElse();
          skip2(";");
          if (obj && (typeof obj.comment !== "string" || preferTrailingComment))
            obj.comment = cmnt(trailingLine) || obj.comment;
        }
      }
      function parseType(parent, token2) {
        if (!nameRe.test(token2 = next()))
          throw illegal(token2, "type name");
        var type = new Type(token2);
        ifBlock(type, function parseType_block(token3) {
          if (parseCommon(type, token3))
            return;
          switch (token3) {
            case "map":
              parseMapField(type, token3);
              break;
            case "required":
            case "repeated":
              parseField(type, token3);
              break;
            case "optional":
              if (isProto3) {
                parseField(type, "proto3_optional");
              } else {
                parseField(type, "optional");
              }
              break;
            case "oneof":
              parseOneOf(type, token3);
              break;
            case "extensions":
              readRanges(type.extensions || (type.extensions = []));
              break;
            case "reserved":
              readRanges(type.reserved || (type.reserved = []), true);
              break;
            default:
              if (!isProto3 || !typeRefRe.test(token3))
                throw illegal(token3);
              push(token3);
              parseField(type, "optional");
              break;
          }
        });
        parent.add(type);
      }
      function parseField(parent, rule, extend) {
        var type = next();
        if (type === "group") {
          parseGroup(parent, rule);
          return;
        }
        if (!typeRefRe.test(type))
          throw illegal(type, "type");
        var name = next();
        if (!nameRe.test(name))
          throw illegal(name, "name");
        name = applyCase(name);
        skip2("=");
        var field = new Field(name, parseId(next()), type, rule, extend);
        ifBlock(field, function parseField_block(token2) {
          if (token2 === "option") {
            parseOption(field, token2);
            skip2(";");
          } else
            throw illegal(token2);
        }, function parseField_line() {
          parseInlineOptions(field);
        });
        if (rule === "proto3_optional") {
          var oneof = new OneOf("_" + name);
          field.setOption("proto3_optional", true);
          oneof.add(field);
          parent.add(oneof);
        } else {
          parent.add(field);
        }
        if (!isProto3 && field.repeated && (types.packed[type] !== void 0 || types.basic[type] === void 0))
          field.setOption(
            "packed",
            false,
            /* ifNotSet */
            true
          );
      }
      function parseGroup(parent, rule) {
        var name = next();
        if (!nameRe.test(name))
          throw illegal(name, "name");
        var fieldName = util.lcFirst(name);
        if (name === fieldName)
          name = util.ucFirst(name);
        skip2("=");
        var id = parseId(next());
        var type = new Type(name);
        type.group = true;
        var field = new Field(fieldName, id, name, rule);
        field.filename = parse2.filename;
        ifBlock(type, function parseGroup_block(token2) {
          switch (token2) {
            case "option":
              parseOption(type, token2);
              skip2(";");
              break;
            case "required":
            case "repeated":
              parseField(type, token2);
              break;
            case "optional":
              if (isProto3) {
                parseField(type, "proto3_optional");
              } else {
                parseField(type, "optional");
              }
              break;
            default:
              throw illegal(token2);
          }
        });
        parent.add(type).add(field);
      }
      function parseMapField(parent) {
        skip2("<");
        var keyType = next();
        if (types.mapKey[keyType] === void 0)
          throw illegal(keyType, "type");
        skip2(",");
        var valueType = next();
        if (!typeRefRe.test(valueType))
          throw illegal(valueType, "type");
        skip2(">");
        var name = next();
        if (!nameRe.test(name))
          throw illegal(name, "name");
        skip2("=");
        var field = new MapField(applyCase(name), parseId(next()), keyType, valueType);
        ifBlock(field, function parseMapField_block(token2) {
          if (token2 === "option") {
            parseOption(field, token2);
            skip2(";");
          } else
            throw illegal(token2);
        }, function parseMapField_line() {
          parseInlineOptions(field);
        });
        parent.add(field);
      }
      function parseOneOf(parent, token2) {
        if (!nameRe.test(token2 = next()))
          throw illegal(token2, "name");
        var oneof = new OneOf(applyCase(token2));
        ifBlock(oneof, function parseOneOf_block(token3) {
          if (token3 === "option") {
            parseOption(oneof, token3);
            skip2(";");
          } else {
            push(token3);
            parseField(oneof, "optional");
          }
        });
        parent.add(oneof);
      }
      function parseEnum(parent, token2) {
        if (!nameRe.test(token2 = next()))
          throw illegal(token2, "name");
        var enm = new Enum(token2);
        ifBlock(enm, function parseEnum_block(token3) {
          switch (token3) {
            case "option":
              parseOption(enm, token3);
              skip2(";");
              break;
            case "reserved":
              readRanges(enm.reserved || (enm.reserved = []), true);
              break;
            default:
              parseEnumValue(enm, token3);
          }
        });
        parent.add(enm);
      }
      function parseEnumValue(parent, token2) {
        if (!nameRe.test(token2))
          throw illegal(token2, "name");
        skip2("=");
        var value = parseId(next(), true), dummy = {};
        ifBlock(dummy, function parseEnumValue_block(token3) {
          if (token3 === "option") {
            parseOption(dummy, token3);
            skip2(";");
          } else
            throw illegal(token3);
        }, function parseEnumValue_line() {
          parseInlineOptions(dummy);
        });
        parent.add(token2, value, dummy.comment);
      }
      function parseOption(parent, token2) {
        var isCustom = skip2("(", true);
        if (!typeRefRe.test(token2 = next()))
          throw illegal(token2, "name");
        var name = token2;
        var option = name;
        var propName;
        if (isCustom) {
          skip2(")");
          name = "(" + name + ")";
          option = name;
          token2 = peek();
          if (fqTypeRefRe.test(token2)) {
            propName = token2.substr(1);
            name += token2;
            next();
          }
        }
        skip2("=");
        var optionValue = parseOptionValue(parent, name);
        setParsedOption(parent, option, optionValue, propName);
      }
      function parseOptionValue(parent, name) {
        if (skip2("{", true)) {
          var result = {};
          while (!skip2("}", true)) {
            if (!nameRe.test(token = next()))
              throw illegal(token, "name");
            var value;
            var propName = token;
            if (peek() === "{")
              value = parseOptionValue(parent, name + "." + token);
            else {
              skip2(":");
              if (peek() === "{")
                value = parseOptionValue(parent, name + "." + token);
              else {
                value = readValue(true);
                setOption(parent, name + "." + token, value);
              }
            }
            var prevValue = result[propName];
            if (prevValue)
              value = [].concat(prevValue).concat(value);
            result[propName] = value;
            skip2(",", true);
          }
          return result;
        }
        var simpleValue = readValue(true);
        setOption(parent, name, simpleValue);
        return simpleValue;
      }
      function setOption(parent, name, value) {
        if (parent.setOption)
          parent.setOption(name, value);
      }
      function setParsedOption(parent, name, value, propName) {
        if (parent.setParsedOption)
          parent.setParsedOption(name, value, propName);
      }
      function parseInlineOptions(parent) {
        if (skip2("[", true)) {
          do {
            parseOption(parent, "option");
          } while (skip2(",", true));
          skip2("]");
        }
        return parent;
      }
      function parseService(parent, token2) {
        if (!nameRe.test(token2 = next()))
          throw illegal(token2, "service name");
        var service = new Service(token2);
        ifBlock(service, function parseService_block(token3) {
          if (parseCommon(service, token3))
            return;
          if (token3 === "rpc")
            parseMethod(service, token3);
          else
            throw illegal(token3);
        });
        parent.add(service);
      }
      function parseMethod(parent, token2) {
        var commentText = cmnt();
        var type = token2;
        if (!nameRe.test(token2 = next()))
          throw illegal(token2, "name");
        var name = token2, requestType, requestStream, responseType, responseStream;
        skip2("(");
        if (skip2("stream", true))
          requestStream = true;
        if (!typeRefRe.test(token2 = next()))
          throw illegal(token2);
        requestType = token2;
        skip2(")");
        skip2("returns");
        skip2("(");
        if (skip2("stream", true))
          responseStream = true;
        if (!typeRefRe.test(token2 = next()))
          throw illegal(token2);
        responseType = token2;
        skip2(")");
        var method = new Method(name, type, requestType, responseType, requestStream, responseStream);
        method.comment = commentText;
        ifBlock(method, function parseMethod_block(token3) {
          if (token3 === "option") {
            parseOption(method, token3);
            skip2(";");
          } else
            throw illegal(token3);
        });
        parent.add(method);
      }
      function parseExtension(parent, token2) {
        if (!typeRefRe.test(token2 = next()))
          throw illegal(token2, "reference");
        var reference = token2;
        ifBlock(null, function parseExtension_block(token3) {
          switch (token3) {
            case "required":
            case "repeated":
              parseField(parent, token3, reference);
              break;
            case "optional":
              if (isProto3) {
                parseField(parent, "proto3_optional", reference);
              } else {
                parseField(parent, "optional", reference);
              }
              break;
            default:
              if (!isProto3 || !typeRefRe.test(token3))
                throw illegal(token3);
              push(token3);
              parseField(parent, "optional", reference);
              break;
          }
        });
      }
      var token;
      while ((token = next()) !== null) {
        switch (token) {
          case "package":
            if (!head)
              throw illegal(token);
            parsePackage();
            break;
          case "import":
            if (!head)
              throw illegal(token);
            parseImport();
            break;
          case "syntax":
            if (!head)
              throw illegal(token);
            parseSyntax();
            break;
          case "option":
            parseOption(ptr, token);
            skip2(";");
            break;
          default:
            if (parseCommon(ptr, token)) {
              head = false;
              continue;
            }
            throw illegal(token);
        }
      }
      parse2.filename = null;
      return {
        "package": pkg,
        "imports": imports,
        weakImports,
        syntax,
        root
      };
    }
  }
});

// node_modules/protobufjs/src/common.js
var require_common = __commonJS({
  "node_modules/protobufjs/src/common.js"(exports2, module2) {
    "use strict";
    module2.exports = common;
    var commonRe = /\/|\./;
    function common(name, json) {
      if (!commonRe.test(name)) {
        name = "google/protobuf/" + name + ".proto";
        json = { nested: { google: { nested: { protobuf: { nested: json } } } } };
      }
      common[name] = json;
    }
    common("any", {
      /**
       * Properties of a google.protobuf.Any message.
       * @interface IAny
       * @type {Object}
       * @property {string} [typeUrl]
       * @property {Uint8Array} [bytes]
       * @memberof common
       */
      Any: {
        fields: {
          type_url: {
            type: "string",
            id: 1
          },
          value: {
            type: "bytes",
            id: 2
          }
        }
      }
    });
    var timeType;
    common("duration", {
      /**
       * Properties of a google.protobuf.Duration message.
       * @interface IDuration
       * @type {Object}
       * @property {number|Long} [seconds]
       * @property {number} [nanos]
       * @memberof common
       */
      Duration: timeType = {
        fields: {
          seconds: {
            type: "int64",
            id: 1
          },
          nanos: {
            type: "int32",
            id: 2
          }
        }
      }
    });
    common("timestamp", {
      /**
       * Properties of a google.protobuf.Timestamp message.
       * @interface ITimestamp
       * @type {Object}
       * @property {number|Long} [seconds]
       * @property {number} [nanos]
       * @memberof common
       */
      Timestamp: timeType
    });
    common("empty", {
      /**
       * Properties of a google.protobuf.Empty message.
       * @interface IEmpty
       * @memberof common
       */
      Empty: {
        fields: {}
      }
    });
    common("struct", {
      /**
       * Properties of a google.protobuf.Struct message.
       * @interface IStruct
       * @type {Object}
       * @property {Object.<string,IValue>} [fields]
       * @memberof common
       */
      Struct: {
        fields: {
          fields: {
            keyType: "string",
            type: "Value",
            id: 1
          }
        }
      },
      /**
       * Properties of a google.protobuf.Value message.
       * @interface IValue
       * @type {Object}
       * @property {string} [kind]
       * @property {0} [nullValue]
       * @property {number} [numberValue]
       * @property {string} [stringValue]
       * @property {boolean} [boolValue]
       * @property {IStruct} [structValue]
       * @property {IListValue} [listValue]
       * @memberof common
       */
      Value: {
        oneofs: {
          kind: {
            oneof: [
              "nullValue",
              "numberValue",
              "stringValue",
              "boolValue",
              "structValue",
              "listValue"
            ]
          }
        },
        fields: {
          nullValue: {
            type: "NullValue",
            id: 1
          },
          numberValue: {
            type: "double",
            id: 2
          },
          stringValue: {
            type: "string",
            id: 3
          },
          boolValue: {
            type: "bool",
            id: 4
          },
          structValue: {
            type: "Struct",
            id: 5
          },
          listValue: {
            type: "ListValue",
            id: 6
          }
        }
      },
      NullValue: {
        values: {
          NULL_VALUE: 0
        }
      },
      /**
       * Properties of a google.protobuf.ListValue message.
       * @interface IListValue
       * @type {Object}
       * @property {Array.<IValue>} [values]
       * @memberof common
       */
      ListValue: {
        fields: {
          values: {
            rule: "repeated",
            type: "Value",
            id: 1
          }
        }
      }
    });
    common("wrappers", {
      /**
       * Properties of a google.protobuf.DoubleValue message.
       * @interface IDoubleValue
       * @type {Object}
       * @property {number} [value]
       * @memberof common
       */
      DoubleValue: {
        fields: {
          value: {
            type: "double",
            id: 1
          }
        }
      },
      /**
       * Properties of a google.protobuf.FloatValue message.
       * @interface IFloatValue
       * @type {Object}
       * @property {number} [value]
       * @memberof common
       */
      FloatValue: {
        fields: {
          value: {
            type: "float",
            id: 1
          }
        }
      },
      /**
       * Properties of a google.protobuf.Int64Value message.
       * @interface IInt64Value
       * @type {Object}
       * @property {number|Long} [value]
       * @memberof common
       */
      Int64Value: {
        fields: {
          value: {
            type: "int64",
            id: 1
          }
        }
      },
      /**
       * Properties of a google.protobuf.UInt64Value message.
       * @interface IUInt64Value
       * @type {Object}
       * @property {number|Long} [value]
       * @memberof common
       */
      UInt64Value: {
        fields: {
          value: {
            type: "uint64",
            id: 1
          }
        }
      },
      /**
       * Properties of a google.protobuf.Int32Value message.
       * @interface IInt32Value
       * @type {Object}
       * @property {number} [value]
       * @memberof common
       */
      Int32Value: {
        fields: {
          value: {
            type: "int32",
            id: 1
          }
        }
      },
      /**
       * Properties of a google.protobuf.UInt32Value message.
       * @interface IUInt32Value
       * @type {Object}
       * @property {number} [value]
       * @memberof common
       */
      UInt32Value: {
        fields: {
          value: {
            type: "uint32",
            id: 1
          }
        }
      },
      /**
       * Properties of a google.protobuf.BoolValue message.
       * @interface IBoolValue
       * @type {Object}
       * @property {boolean} [value]
       * @memberof common
       */
      BoolValue: {
        fields: {
          value: {
            type: "bool",
            id: 1
          }
        }
      },
      /**
       * Properties of a google.protobuf.StringValue message.
       * @interface IStringValue
       * @type {Object}
       * @property {string} [value]
       * @memberof common
       */
      StringValue: {
        fields: {
          value: {
            type: "string",
            id: 1
          }
        }
      },
      /**
       * Properties of a google.protobuf.BytesValue message.
       * @interface IBytesValue
       * @type {Object}
       * @property {Uint8Array} [value]
       * @memberof common
       */
      BytesValue: {
        fields: {
          value: {
            type: "bytes",
            id: 1
          }
        }
      }
    });
    common("field_mask", {
      /**
       * Properties of a google.protobuf.FieldMask message.
       * @interface IDoubleValue
       * @type {Object}
       * @property {number} [value]
       * @memberof common
       */
      FieldMask: {
        fields: {
          paths: {
            rule: "repeated",
            type: "string",
            id: 1
          }
        }
      }
    });
    common.get = function get(file) {
      return common[file] || null;
    };
  }
});

// node_modules/protobufjs/src/index.js
var require_src = __commonJS({
  "node_modules/protobufjs/src/index.js"(exports2, module2) {
    "use strict";
    var protobuf = module2.exports = require_index_light();
    protobuf.build = "full";
    protobuf.tokenize = require_tokenize();
    protobuf.parse = require_parse();
    protobuf.common = require_common();
    protobuf.Root._configure(protobuf.Type, protobuf.parse, protobuf.common);
  }
});

// node_modules/protobufjs/index.js
var require_protobufjs = __commonJS({
  "node_modules/protobufjs/index.js"(exports2, module2) {
    "use strict";
    module2.exports = require_src();
  }
});

// node_modules/@snap/camera-kit/dist/common/copyDefinedProperties.js
function copyDefinedProperties(obj) {
  return Object.fromEntries(Object.entries(obj).filter(([_, value]) => value !== void 0));
}

// node_modules/@snap/camera-kit/dist/configurationOverrides.js
var windowFieldPrefix = "__snap_camkit_override__";
var configPropertiesToOverride = [
  "wasmEndpointOverride",
  "logger",
  "logLevel",
  "userAgentFlavor"
];
configPropertiesToOverride.forEach((fieldToOverride) => {
  defineWindowField(fieldToOverride);
});
function defineWindowField(propertyToOverride) {
  if (typeof window === "undefined")
    return;
  Object.defineProperty(window, `${windowFieldPrefix}${propertyToOverride}`, {
    get() {
      var _a;
      return (_a = getConfigurationOverrides()) === null || _a === void 0 ? void 0 : _a[propertyToOverride];
    },
    set(value) {
      const storedOverrides = Object.assign(Object.assign({}, getConfigurationOverrides()), { [propertyToOverride]: value });
      if (Object.values(storedOverrides).every((value2) => typeof value2 === "undefined")) {
        sessionStorage.removeItem(windowFieldPrefix);
      } else {
        sessionStorage.setItem(windowFieldPrefix, JSON.stringify(storedOverrides));
      }
    },
    enumerable: false,
    configurable: true
  });
}
function getConfigurationOverrides() {
  if (!sessionStorage)
    return void 0;
  const overridesString = sessionStorage.getItem(windowFieldPrefix);
  return overridesString && JSON.parse(overridesString);
}

// node_modules/@snap/camera-kit/dist/dependency-injection/Injectable.js
function Injectable(token, dependenciesOrFn, maybeFn) {
  const dependencies = Array.isArray(dependenciesOrFn) ? dependenciesOrFn : [];
  const fn = typeof dependenciesOrFn === "function" ? dependenciesOrFn : maybeFn;
  if (!fn) {
    throw new TypeError("[Injectable] Received invalid arguments. The factory function must be either the second or third argument.");
  }
  if (fn.length !== dependencies.length) {
    throw new TypeError(`[Injectable] Function arity does not match the number of dependencies. Function has arity ${fn.length}, but ${dependencies.length} dependencies were specified.
Dependencies: ${JSON.stringify(dependencies)}`);
  }
  const factory = (...args) => fn(...args);
  factory.token = token;
  factory.dependencies = dependencies;
  return factory;
}
function ConcatInjectable(token, dependenciesOrFn, maybeFn) {
  const dependencies = Array.isArray(dependenciesOrFn) ? dependenciesOrFn : [];
  const fn = typeof dependenciesOrFn === "function" ? dependenciesOrFn : maybeFn;
  if (!fn) {
    throw new TypeError("[ConcatInjectable] Received invalid arguments. The factory function must be either the second or third argument.");
  }
  if (fn.length !== dependencies.length) {
    throw new TypeError(`[Injectable] Function arity does not match the number of dependencies. Function has arity ${fn.length}, but ${dependencies.length} dependencies were specified.
Dependencies: ${JSON.stringify(dependencies)}`);
  }
  const factory = (array, ...args) => {
    return array.concat(fn(...args));
  };
  factory.token = token;
  factory.dependencies = [token, ...dependencies];
  return factory;
}

// node_modules/@snap/camera-kit/dist/configuration.js
var defaultConfiguration = {
  lensPerformance: { cluster: 0, benchmarks: [], webglRendererInfo: "unknown" },
  logger: "noop",
  logLevel: "info",
  shouldUseWorker: true,
  apiHostname: "camera-kit-api.snapar.com",
  userAgentFlavor: "release"
};
var configurationToken = "configuration";
function isHandledAppleDevice() {
  return /iPad|iPhone|iPod/.test(navigator.platform) || navigator.platform === "MacIntel" && navigator.maxTouchPoints > 2;
}
var createCameraKitConfigurationFactory = (configuration) => {
  const overrides = getConfigurationOverrides();
  if (overrides) {
    console.warn("Configuration overrides applied", overrides);
  }
  return Injectable(configurationToken, () => {
    const safeConfig = Object.assign(Object.assign({}, configuration), { lensPerformance: configuration.lensPerformance instanceof Promise ? configuration.lensPerformance.catch(() => defaultConfiguration.lensPerformance) : configuration.lensPerformance });
    return Object.assign(Object.assign(Object.assign(Object.assign({}, defaultConfiguration), { shouldUseWorker: isHandledAppleDevice() ? false : defaultConfiguration.shouldUseWorker }), copyDefinedProperties(safeConfig)), copyDefinedProperties(overrides !== null && overrides !== void 0 ? overrides : {}));
  });
};

// node_modules/tslib/tslib.es6.mjs
var extendStatics = function(d2, b2) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
    d3.__proto__ = b3;
  } || function(d3, b3) {
    for (var p2 in b3) if (Object.prototype.hasOwnProperty.call(b3, p2)) d3[p2] = b3[p2];
  };
  return extendStatics(d2, b2);
};
function __extends(d2, b2) {
  if (typeof b2 !== "function" && b2 !== null)
    throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
  extendStatics(d2, b2);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
function __rest(s2, e2) {
  var t2 = {};
  for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
    t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t2[p2[i]] = s2[p2[i]];
    }
  return t2;
}
function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
  function accept(f3) {
    if (f3 !== void 0 && typeof f3 !== "function") throw new TypeError("Function expected");
    return f3;
  }
  var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
  var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
  var _, done = false;
  for (var i = decorators.length - 1; i >= 0; i--) {
    var context2 = {};
    for (var p2 in contextIn) context2[p2] = p2 === "access" ? {} : contextIn[p2];
    for (var p2 in contextIn.access) context2.access[p2] = contextIn.access[p2];
    context2.addInitializer = function(f3) {
      if (done) throw new TypeError("Cannot add initializers after decoration has completed");
      extraInitializers.push(accept(f3 || null));
    };
    var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context2);
    if (kind === "accessor") {
      if (result === void 0) continue;
      if (result === null || typeof result !== "object") throw new TypeError("Object expected");
      if (_ = accept(result.get)) descriptor.get = _;
      if (_ = accept(result.set)) descriptor.set = _;
      if (_ = accept(result.init)) initializers.unshift(_);
    } else if (_ = accept(result)) {
      if (kind === "field") initializers.unshift(_);
      else descriptor[key] = _;
    }
  }
  if (target) Object.defineProperty(target, contextIn.name, descriptor);
  done = true;
}
function __runInitializers(thisArg, initializers, value) {
  var useValue = arguments.length > 2;
  for (var i = 0; i < initializers.length; i++) {
    value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
  }
  return useValue ? value : void 0;
}
function __awaiter(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t2[0] & 1) throw t2[1];
    return t2[1];
  }, trys: [], ops: [] }, f3, y2, t2, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
  return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n2) {
    return function(v2) {
      return step([n2, v2]);
    };
  }
  function step(op) {
    if (f3) throw new TypeError("Generator is already executing.");
    while (g && (g = 0, op[0] && (_ = 0)), _) try {
      if (f3 = 1, y2 && (t2 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done) return t2;
      if (y2 = 0, t2) op = [op[0] & 2, t2.value];
      switch (op[0]) {
        case 0:
        case 1:
          t2 = op;
          break;
        case 4:
          _.label++;
          return { value: op[1], done: false };
        case 5:
          _.label++;
          y2 = op[1];
          op = [0];
          continue;
        case 7:
          op = _.ops.pop();
          _.trys.pop();
          continue;
        default:
          if (!(t2 = _.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _ = 0;
            continue;
          }
          if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
            _.label = op[1];
            break;
          }
          if (op[0] === 6 && _.label < t2[1]) {
            _.label = t2[1];
            t2 = op;
            break;
          }
          if (t2 && _.label < t2[2]) {
            _.label = t2[2];
            _.ops.push(op);
            break;
          }
          if (t2[2]) _.ops.pop();
          _.trys.pop();
          continue;
      }
      op = body.call(thisArg, _);
    } catch (e2) {
      op = [6, e2];
      y2 = 0;
    } finally {
      f3 = t2 = 0;
    }
    if (op[0] & 5) throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
function __values(o) {
  var s2 = typeof Symbol === "function" && Symbol.iterator, m2 = s2 && o[s2], i = 0;
  if (m2) return m2.call(o);
  if (o && typeof o.length === "number") return {
    next: function() {
      if (o && i >= o.length) o = void 0;
      return { value: o && o[i++], done: !o };
    }
  };
  throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o, n2) {
  var m2 = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m2) return o;
  var i = m2.call(o), r2, ar = [], e2;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r2 = i.next()).done) ar.push(r2.value);
  } catch (error) {
    e2 = { error };
  } finally {
    try {
      if (r2 && !r2.done && (m2 = i["return"])) m2.call(i);
    } finally {
      if (e2) throw e2.error;
    }
  }
  return ar;
}
function __spreadArray(to, from2, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l2 = from2.length, ar; i < l2; i++) {
    if (ar || !(i in from2)) {
      if (!ar) ar = Array.prototype.slice.call(from2, 0, i);
      ar[i] = from2[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from2));
}
function __await(v2) {
  return this instanceof __await ? (this.v = v2, this) : new __await(v2);
}
function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var g = generator.apply(thisArg, _arguments || []), i, q = [];
  return i = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i[Symbol.asyncIterator] = function() {
    return this;
  }, i;
  function awaitReturn(f3) {
    return function(v2) {
      return Promise.resolve(v2).then(f3, reject);
    };
  }
  function verb(n2, f3) {
    if (g[n2]) {
      i[n2] = function(v2) {
        return new Promise(function(a2, b2) {
          q.push([n2, v2, a2, b2]) > 1 || resume(n2, v2);
        });
      };
      if (f3) i[n2] = f3(i[n2]);
    }
  }
  function resume(n2, v2) {
    try {
      step(g[n2](v2));
    } catch (e2) {
      settle(q[0][3], e2);
    }
  }
  function step(r2) {
    r2.value instanceof __await ? Promise.resolve(r2.value.v).then(fulfill, reject) : settle(q[0][2], r2);
  }
  function fulfill(value) {
    resume("next", value);
  }
  function reject(value) {
    resume("throw", value);
  }
  function settle(f3, v2) {
    if (f3(v2), q.shift(), q.length) resume(q[0][0], q[0][1]);
  }
}
function __asyncValues(o) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var m2 = o[Symbol.asyncIterator], i;
  return m2 ? m2.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i);
  function verb(n2) {
    i[n2] = o[n2] && function(v2) {
      return new Promise(function(resolve, reject) {
        v2 = o[n2](v2), settle(resolve, reject, v2.done, v2.value);
      });
    };
  }
  function settle(resolve, reject, d2, v2) {
    Promise.resolve(v2).then(function(v6) {
      resolve({ value: v6, done: d2 });
    }, reject);
  }
}

// node_modules/@snap/camera-kit/dist/namedErrors.js
function cleanErrorStack(stack) {
  const [first2, _, ...rest] = stack.split("\n");
  return [first2, ...rest].join("\n");
}
function namedError(name) {
  return (message, cause) => {
    const error = new Error(message, { cause });
    error.name = name;
    error.stack = error.stack && cleanErrorStack(error.stack);
    return error;
  };
}
var legalError = namedError("LegalError");
var lensContentValidationError = namedError("LensContentValidationError");
var lensError = namedError("LensError");
var cameraKitSourceError = namedError("CameraKitSourceError");
var lensImagePickerError = namedError("LensImagePickerError");
var cacheKeyNotFoundError = namedError("CacheKeyNotFoundError");
var configurationError = namedError("ConfigurationError");
var webGLError = namedError("WebGLError");
var benchmarkError = namedError("BenchmarkError");
var platformNotSupportedError = namedError("PlatformNotSupportedError");
var lensExecutionError = namedError("LensExecutionError");
var lensAbortError = namedError("LensAbortError");
var persistentStoreError = namedError("PersistentStoreError");
var lensAssetError = namedError("LensAssetError");
var bootstrapError = namedError("BootstrapError");
var argumentValidationError = namedError("ArgumentValidationError");

// node_modules/@snap/camera-kit/dist/benchmark/webglUtils.js
var webGLEntityCreationError = (name) => webGLError(`Could not create ${name}.`);
function createProgram(gl, vertexSource2, fragmentSource2) {
  const vertexShader = createShader(gl, vertexSource2, gl.VERTEX_SHADER);
  const fragmentShader = createShader(gl, fragmentSource2, gl.FRAGMENT_SHADER);
  const program = gl.createProgram();
  if (!program)
    throw webGLEntityCreationError("WebGLProgram");
  gl.attachShader(program, vertexShader);
  gl.deleteShader(vertexShader);
  gl.attachShader(program, fragmentShader);
  gl.deleteShader(fragmentShader);
  gl.linkProgram(program);
  const success = gl.getProgramParameter(program, gl.LINK_STATUS);
  if (!success) {
    const message = gl.getProgramInfoLog(program);
    gl.deleteProgram(program);
    throw webGLError(`WebGLProgram linking failed with status: ${message}.`);
  }
  return program;
}
function createShader(gl, source, type) {
  const shader = gl.createShader(type);
  if (!shader)
    throw webGLEntityCreationError(`WebGLShader (type ${type})`);
  gl.shaderSource(shader, source);
  gl.compileShader(shader);
  const success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
  if (!success) {
    const message = gl.getShaderInfoLog(shader);
    gl.deleteShader(shader);
    throw webGLError(`WebGLShader (type ${type}) compilation failed with status: ${message}.`);
  }
  return shader;
}
function createTexture(gl, width2, height2) {
  const texture = gl.createTexture();
  if (!texture)
    throw webGLEntityCreationError("WebGLTexture");
  gl.bindTexture(gl.TEXTURE_2D, texture);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width2, height2, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
  return texture;
}
function createFramebuffer(gl, texture) {
  const framebuffer = gl.createFramebuffer();
  if (!framebuffer)
    throw webGLEntityCreationError("WebGLFramebuffer");
  gl.bindTexture(gl.TEXTURE_2D, texture);
  gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
  gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
  return framebuffer;
}
function setUniform1i(gl, program, name, data) {
  gl.uniform1i(gl.getUniformLocation(program, name), data);
}
function setUniform4f(gl, program, name, data) {
  gl.uniform4f(gl.getUniformLocation(program, name), ...data);
}
function promiseSync(gl) {
  const sync = gl.fenceSync(gl.SYNC_GPU_COMMANDS_COMPLETE, 0);
  if (!sync)
    throw webGLEntityCreationError("WebGLSync");
  gl.flush();
  return new Promise((resolve, reject) => {
    const waitForSync = () => {
      const glEnum = gl.clientWaitSync(sync, 0, 0);
      switch (glEnum) {
        case gl.TIMEOUT_EXPIRED:
          setTimeout(waitForSync);
          return;
        case gl.WAIT_FAILED:
          gl.deleteSync(sync);
          return reject();
        case gl.ALREADY_SIGNALED:
        case gl.CONDITION_SATISFIED:
          gl.deleteSync(sync);
          return resolve();
      }
    };
    waitForSync();
  });
}

// node_modules/@snap/camera-kit/dist/benchmark/benchmarkGflops.js
var vertexSource = `#version 300 es

precision mediump float;
precision mediump int;

in vec2 pos;

void main() {
    gl_Position = vec4(pos, 0.0, 1.0);
}
`;
var fragmentSource = `#version 300 es

precision mediump float;
precision mediump int;

uniform int LOOP_COUNT;
uniform vec4 v0;
uniform vec4 v1;
uniform vec4 v2;

out vec4 fragColor;

#define REPEAT_2(x) x; x
#define REPEAT_4(x) REPEAT_2(x); REPEAT_2(x)
#define REPEAT_8(x) REPEAT_4(x); REPEAT_4(x)
#define REPEAT_16(x) REPEAT_8(x); REPEAT_8(x)
#define REPEAT_32(x) REPEAT_16(x); REPEAT_16(x)

void main() {
    vec4 r = v2;
    for (int i = 0; i < LOOP_COUNT; i++) {
        REPEAT_32(r = r * v1 + v0);
    }
    fragColor = r;
}
`;
var width = 1024;
var height = 1024;
var budgetMs = 300;
var maxLoopCount = 1e3;
function prepareBenchmark(gl) {
  const texture = createTexture(gl, width, height);
  const framebuffer = createFramebuffer(gl, texture);
  gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
  const buffer2 = gl.createBuffer();
  if (!buffer2) {
    throw new Error("Failed to create WebGLBuffer.");
  }
  gl.bindBuffer(gl.ARRAY_BUFFER, buffer2);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1, 1, -1, -1, 1, -1, 1, 1]), gl.STATIC_DRAW);
  gl.viewport(0, 0, width, height);
  gl.disable(gl.CULL_FACE);
  gl.disable(gl.DEPTH_TEST);
  const program = createProgram(gl, vertexSource, fragmentSource);
  gl.useProgram(program);
  const posLocation = gl.getAttribLocation(program, "pos");
  gl.enableVertexAttribArray(posLocation);
  gl.vertexAttribPointer(posLocation, 2, gl.FLOAT, false, 0, 0);
  setUniform4f(gl, program, "v0", [1.15, 1.23, 1.47, 1.84]);
  setUniform4f(gl, program, "v1", [1.65, 1.22, 1.69, 1.04]);
  setUniform4f(gl, program, "v2", [1.05, 1.3, 1.55, 1.23]);
  return {
    program,
    cleanupBenchmark: () => {
      gl.deleteProgram(program);
      gl.deleteBuffer(buffer2);
      gl.deleteFramebuffer(framebuffer);
      gl.deleteTexture(texture);
    }
  };
}
function runBenchmark(gl, program) {
  return __awaiter(this, void 0, void 0, function* () {
    yield promiseSync(gl);
    const start = performance.now();
    const flops = [];
    let loopCount = 20;
    while (true) {
      setUniform1i(gl, program, "LOOP_COUNT", loopCount);
      const iterationStart = performance.now();
      gl.drawArrays(gl.TRIANGLE_FAN, 0, 4);
      yield promiseSync(gl);
      const iterationEnd = performance.now();
      const duration = iterationEnd - iterationStart;
      flops.push(loopCount / duration);
      const remainingBudgetMs = budgetMs - (iterationEnd - start);
      if (remainingBudgetMs < 0)
        break;
      if (loopCount < maxLoopCount) {
        loopCount += remainingBudgetMs < duration ? 10 : 0.6 * loopCount * remainingBudgetMs / duration;
      }
    }
    const maxFlops = Math.max(...flops) * (8 * 32) * width * height;
    return maxFlops / 1e6;
  });
}
var gflopsClusterCenters = /* @__PURE__ */ new Map([
  [34, 1],
  [134, 2],
  [385, 3],
  [783, 4],
  [1484, 5],
  [2313, 6]
]);
function benchmarkGflops(gl) {
  return __awaiter(this, void 0, void 0, function* () {
    const { program, cleanupBenchmark } = prepareBenchmark(gl);
    const gflops = yield runBenchmark(gl, program);
    cleanupBenchmark();
    return { name: "gflops", value: gflops };
  });
}

// node_modules/@snap/camera-kit/dist/benchmark/estimateLensPerformanceCluster.js
var findNearest = (n2, arr) => arr.reduce((a2, b2) => Math.abs(a2 - n2) <= Math.abs(b2 - n2) ? a2 : b2);
var webglContextAttributes = {
  alpha: false,
  antialias: false,
  premultipliedAlpha: false,
  preserveDrawingBuffer: false,
  depth: false,
  stencil: false,
  failIfMajorPerformanceCaveat: false,
  powerPreference: "high-performance"
};
function estimateLensPerformance() {
  var _a;
  return __awaiter(this, void 0, void 0, function* () {
    const canvas = document.createElement("canvas");
    const gl = canvas.getContext("webgl2", webglContextAttributes);
    if (!gl)
      throw benchmarkError("WebGL2 is required to compute performance, but it is not supported.");
    const debugInfo = gl.getExtension("WEBGL_debug_renderer_info");
    const webglRendererInfo = debugInfo ? gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL) : "unknown";
    const gflops = yield benchmarkGflops(gl);
    const nearestGflopsClusterCenter = findNearest(gflops.value, Array.from(gflopsClusterCenters.keys()));
    const gflopsCluster = (_a = gflopsClusterCenters.get(nearestGflopsClusterCenter)) !== null && _a !== void 0 ? _a : 0;
    return {
      cluster: gflopsCluster,
      benchmarks: [gflops],
      webglRendererInfo
    };
  });
}

// node_modules/@snap/camera-kit/dist/environment.js
var environment_default = { PACKAGE_VERSION: "0.18.1" };

// node_modules/@snap/camera-kit/dist/lensCoreWasmVersions.js
var lensCoreWasmVersions_default = {
  version: "267",
  buildNumber: "312",
  baseUrl: "https://cf-st.sc-cdn.net/d/P7GNr57Olcevwd0qGstFA?go=IgsKCTIBBEgBUFxgAQ%3D%3D&uc=92"
};

// node_modules/@snap/camera-kit/dist/common/validate.js
var ordinalSuffixMap = {
  1: "st",
  2: "nd",
  3: "rd"
};
function getArgumentInfo(target, methodName, argumentIndex, arg) {
  var _a;
  let argString;
  try {
    argString = JSON.stringify(arg);
  } catch (_b) {
    argString = String(arg);
  }
  return {
    argPosition: `${argumentIndex + 1}${(_a = ordinalSuffixMap[argumentIndex + 1]) !== null && _a !== void 0 ? _a : "th"}`,
    methodPath: `${getTypeName(target)}.${String(methodName)}()`,
    argString
  };
}
function getTypeName(value) {
  if (value === null) {
    return "null";
  }
  const baseType = typeof value;
  if (!["object", "function"].includes(baseType)) {
    return baseType;
  }
  const nonNullValue = value;
  const tag = nonNullValue[Symbol.toStringTag];
  if (typeof tag === "string") {
    return tag;
  }
  if (baseType === "function" && Function.prototype.toString.call(nonNullValue).startsWith("class")) {
    return "class";
  }
  const className = nonNullValue.constructor.name;
  if (typeof className === "string" && className !== "") {
    return className;
  }
  return baseType;
}
function validate(...guards) {
  return function validator(target, context2) {
    return function(...args) {
      for (const [index, guard] of guards.entries()) {
        if (!guard(args[index])) {
          const { argPosition, methodPath, argString } = getArgumentInfo(this, context2.name, index, args[index]);
          throw argumentValidationError(`The ${argPosition} argument to ${methodPath} method has an invalid value: ${argString}.`);
        }
      }
      return target.apply(this, args);
    };
  };
}

// node_modules/@snap/camera-kit/dist/common/typeguards.js
function isString(value) {
  return typeof value === "string";
}
function isSafeString(value) {
  return isString(value) && encodeURIComponent(value) === value;
}
function isNumber(value) {
  return typeof value === "number";
}
function isValidNumber(value) {
  return isNumber(value) && !Number.isNaN(value) && Number.isFinite(value);
}
function isValidNumberOrUndefined(value) {
  return isUndefined(value) || isValidNumber(value);
}
function isArrayOfType(elementTypeGuard, value) {
  return Array.isArray(value) && value.every((id) => elementTypeGuard(id));
}
function isSafeStringArray(value) {
  return isArrayOfType(isSafeString, value);
}
function isStringOrUndefined(value) {
  return isUndefined(value) || isString(value);
}
function isArrayBuffer(value) {
  return value instanceof ArrayBuffer;
}
function isTypedArray(value) {
  return value instanceof Object.getPrototypeOf(Uint8Array);
}
function isUndefined(value) {
  return typeof value === "undefined";
}
function isRecord(value) {
  return typeof value === "object" && value !== null && !Array.isArray(value);
}
function isFunction(value) {
  return typeof value === "function";
}
function isDate(value) {
  return value instanceof Date;
}
function isDateOrUndefined(value) {
  return isUndefined(value) || isDate(value);
}
function predicateRecordValues(predicate) {
  return (value) => {
    for (const v2 of Object.values(value))
      if (!predicate(v2))
        return false;
    return true;
  };
}
function isEmptyOrSafeUrl(urlString) {
  if (!urlString)
    return true;
  try {
    const url = new URL(urlString);
    return url.protocol === "https:" || url.protocol === "http:";
  } catch (_a) {
    return false;
  }
}

// node_modules/@snap/camera-kit/dist/handlers/HandlerChainBuilder.js
var HandlerChainBuilder = class _HandlerChainBuilder {
  constructor(inner) {
    this.inner = inner;
  }
  get handler() {
    return this.inner;
  }
  map(outer) {
    const outerHandler = (req, metadata) => {
      var _a;
      const abort = new AbortController();
      const signal = abort.signal;
      let innerCompleted = false;
      const maybeAbort = () => {
        var _a2;
        if (signal.aborted || innerCompleted)
          return;
        abort.abort();
        (_a2 = metadata === null || metadata === void 0 ? void 0 : metadata.signal) === null || _a2 === void 0 ? void 0 : _a2.removeEventListener("abort", maybeAbort);
      };
      (_a = metadata === null || metadata === void 0 ? void 0 : metadata.signal) === null || _a === void 0 ? void 0 : _a.addEventListener("abort", maybeAbort);
      const innerHandler = new Proxy(this.inner, {
        apply: (target, thisArg, args) => {
          const [req2, metadata2] = args;
          if (metadata2 === null || metadata2 === void 0 ? void 0 : metadata2.isSideEffect)
            innerCompleted = true;
          const abortListeners = [];
          signal.addEventListener = new Proxy(signal.addEventListener, {
            apply: (target2, thisArg2, args2) => {
              abortListeners.push(args2[1]);
              return Reflect.apply(target2, thisArg2, args2);
            }
          });
          const cleanupAndMarkComplete = () => {
            var _a2;
            (_a2 = metadata2 === null || metadata2 === void 0 ? void 0 : metadata2.signal) === null || _a2 === void 0 ? void 0 : _a2.removeEventListener("abort", maybeAbort);
            abortListeners.forEach((listener) => signal.removeEventListener("abort", listener));
            innerCompleted = true;
          };
          const innerResponse = Reflect.apply(target, thisArg, [
            req2,
            Object.assign(Object.assign({}, metadata2), { isSideEffect: false, signal })
          ]);
          innerResponse.catch(() => {
          }).then(cleanupAndMarkComplete);
          return innerResponse;
        }
      });
      const outerResponse = outer(innerHandler)(req, metadata);
      outerResponse.catch(() => {
      }).then(maybeAbort);
      return outerResponse;
    };
    return new _HandlerChainBuilder(outerHandler);
  }
};

// node_modules/rxjs/dist/esm5/internal/util/isFunction.js
function isFunction2(value) {
  return typeof value === "function";
}

// node_modules/rxjs/dist/esm5/internal/util/createErrorClass.js
function createErrorClass(createImpl) {
  var _super = function(instance) {
    Error.call(instance);
    instance.stack = new Error().stack;
  };
  var ctorFunc = createImpl(_super);
  ctorFunc.prototype = Object.create(Error.prototype);
  ctorFunc.prototype.constructor = ctorFunc;
  return ctorFunc;
}

// node_modules/rxjs/dist/esm5/internal/util/UnsubscriptionError.js
var UnsubscriptionError = createErrorClass(function(_super) {
  return function UnsubscriptionErrorImpl(errors) {
    _super(this);
    this.message = errors ? errors.length + " errors occurred during unsubscription:\n" + errors.map(function(err, i) {
      return i + 1 + ") " + err.toString();
    }).join("\n  ") : "";
    this.name = "UnsubscriptionError";
    this.errors = errors;
  };
});

// node_modules/rxjs/dist/esm5/internal/util/arrRemove.js
function arrRemove(arr, item) {
  if (arr) {
    var index = arr.indexOf(item);
    0 <= index && arr.splice(index, 1);
  }
}

// node_modules/rxjs/dist/esm5/internal/Subscription.js
var Subscription = function() {
  function Subscription2(initialTeardown) {
    this.initialTeardown = initialTeardown;
    this.closed = false;
    this._parentage = null;
    this._finalizers = null;
  }
  Subscription2.prototype.unsubscribe = function() {
    var e_1, _a, e_2, _b;
    var errors;
    if (!this.closed) {
      this.closed = true;
      var _parentage = this._parentage;
      if (_parentage) {
        this._parentage = null;
        if (Array.isArray(_parentage)) {
          try {
            for (var _parentage_1 = __values(_parentage), _parentage_1_1 = _parentage_1.next(); !_parentage_1_1.done; _parentage_1_1 = _parentage_1.next()) {
              var parent_1 = _parentage_1_1.value;
              parent_1.remove(this);
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (_parentage_1_1 && !_parentage_1_1.done && (_a = _parentage_1.return)) _a.call(_parentage_1);
            } finally {
              if (e_1) throw e_1.error;
            }
          }
        } else {
          _parentage.remove(this);
        }
      }
      var initialFinalizer = this.initialTeardown;
      if (isFunction2(initialFinalizer)) {
        try {
          initialFinalizer();
        } catch (e2) {
          errors = e2 instanceof UnsubscriptionError ? e2.errors : [e2];
        }
      }
      var _finalizers = this._finalizers;
      if (_finalizers) {
        this._finalizers = null;
        try {
          for (var _finalizers_1 = __values(_finalizers), _finalizers_1_1 = _finalizers_1.next(); !_finalizers_1_1.done; _finalizers_1_1 = _finalizers_1.next()) {
            var finalizer = _finalizers_1_1.value;
            try {
              execFinalizer(finalizer);
            } catch (err) {
              errors = errors !== null && errors !== void 0 ? errors : [];
              if (err instanceof UnsubscriptionError) {
                errors = __spreadArray(__spreadArray([], __read(errors)), __read(err.errors));
              } else {
                errors.push(err);
              }
            }
          }
        } catch (e_2_1) {
          e_2 = { error: e_2_1 };
        } finally {
          try {
            if (_finalizers_1_1 && !_finalizers_1_1.done && (_b = _finalizers_1.return)) _b.call(_finalizers_1);
          } finally {
            if (e_2) throw e_2.error;
          }
        }
      }
      if (errors) {
        throw new UnsubscriptionError(errors);
      }
    }
  };
  Subscription2.prototype.add = function(teardown) {
    var _a;
    if (teardown && teardown !== this) {
      if (this.closed) {
        execFinalizer(teardown);
      } else {
        if (teardown instanceof Subscription2) {
          if (teardown.closed || teardown._hasParent(this)) {
            return;
          }
          teardown._addParent(this);
        }
        (this._finalizers = (_a = this._finalizers) !== null && _a !== void 0 ? _a : []).push(teardown);
      }
    }
  };
  Subscription2.prototype._hasParent = function(parent) {
    var _parentage = this._parentage;
    return _parentage === parent || Array.isArray(_parentage) && _parentage.includes(parent);
  };
  Subscription2.prototype._addParent = function(parent) {
    var _parentage = this._parentage;
    this._parentage = Array.isArray(_parentage) ? (_parentage.push(parent), _parentage) : _parentage ? [_parentage, parent] : parent;
  };
  Subscription2.prototype._removeParent = function(parent) {
    var _parentage = this._parentage;
    if (_parentage === parent) {
      this._parentage = null;
    } else if (Array.isArray(_parentage)) {
      arrRemove(_parentage, parent);
    }
  };
  Subscription2.prototype.remove = function(teardown) {
    var _finalizers = this._finalizers;
    _finalizers && arrRemove(_finalizers, teardown);
    if (teardown instanceof Subscription2) {
      teardown._removeParent(this);
    }
  };
  Subscription2.EMPTY = function() {
    var empty2 = new Subscription2();
    empty2.closed = true;
    return empty2;
  }();
  return Subscription2;
}();
var EMPTY_SUBSCRIPTION = Subscription.EMPTY;
function isSubscription(value) {
  return value instanceof Subscription || value && "closed" in value && isFunction2(value.remove) && isFunction2(value.add) && isFunction2(value.unsubscribe);
}
function execFinalizer(finalizer) {
  if (isFunction2(finalizer)) {
    finalizer();
  } else {
    finalizer.unsubscribe();
  }
}

// node_modules/rxjs/dist/esm5/internal/config.js
var config = {
  onUnhandledError: null,
  onStoppedNotification: null,
  Promise: void 0,
  useDeprecatedSynchronousErrorHandling: false,
  useDeprecatedNextContext: false
};

// node_modules/rxjs/dist/esm5/internal/scheduler/timeoutProvider.js
var timeoutProvider = {
  setTimeout: function(handler, timeout2) {
    var args = [];
    for (var _i = 2; _i < arguments.length; _i++) {
      args[_i - 2] = arguments[_i];
    }
    var delegate = timeoutProvider.delegate;
    if (delegate === null || delegate === void 0 ? void 0 : delegate.setTimeout) {
      return delegate.setTimeout.apply(delegate, __spreadArray([handler, timeout2], __read(args)));
    }
    return setTimeout.apply(void 0, __spreadArray([handler, timeout2], __read(args)));
  },
  clearTimeout: function(handle) {
    var delegate = timeoutProvider.delegate;
    return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearTimeout) || clearTimeout)(handle);
  },
  delegate: void 0
};

// node_modules/rxjs/dist/esm5/internal/util/reportUnhandledError.js
function reportUnhandledError(err) {
  timeoutProvider.setTimeout(function() {
    var onUnhandledError = config.onUnhandledError;
    if (onUnhandledError) {
      onUnhandledError(err);
    } else {
      throw err;
    }
  });
}

// node_modules/rxjs/dist/esm5/internal/util/noop.js
function noop() {
}

// node_modules/rxjs/dist/esm5/internal/NotificationFactories.js
var COMPLETE_NOTIFICATION = function() {
  return createNotification("C", void 0, void 0);
}();
function errorNotification(error) {
  return createNotification("E", void 0, error);
}
function nextNotification(value) {
  return createNotification("N", value, void 0);
}
function createNotification(kind, value, error) {
  return {
    kind,
    value,
    error
  };
}

// node_modules/rxjs/dist/esm5/internal/util/errorContext.js
var context = null;
function errorContext(cb) {
  if (config.useDeprecatedSynchronousErrorHandling) {
    var isRoot = !context;
    if (isRoot) {
      context = { errorThrown: false, error: null };
    }
    cb();
    if (isRoot) {
      var _a = context, errorThrown = _a.errorThrown, error = _a.error;
      context = null;
      if (errorThrown) {
        throw error;
      }
    }
  } else {
    cb();
  }
}
function captureError(err) {
  if (config.useDeprecatedSynchronousErrorHandling && context) {
    context.errorThrown = true;
    context.error = err;
  }
}

// node_modules/rxjs/dist/esm5/internal/Subscriber.js
var Subscriber = function(_super) {
  __extends(Subscriber2, _super);
  function Subscriber2(destination) {
    var _this = _super.call(this) || this;
    _this.isStopped = false;
    if (destination) {
      _this.destination = destination;
      if (isSubscription(destination)) {
        destination.add(_this);
      }
    } else {
      _this.destination = EMPTY_OBSERVER;
    }
    return _this;
  }
  Subscriber2.create = function(next, error, complete) {
    return new SafeSubscriber(next, error, complete);
  };
  Subscriber2.prototype.next = function(value) {
    if (this.isStopped) {
      handleStoppedNotification(nextNotification(value), this);
    } else {
      this._next(value);
    }
  };
  Subscriber2.prototype.error = function(err) {
    if (this.isStopped) {
      handleStoppedNotification(errorNotification(err), this);
    } else {
      this.isStopped = true;
      this._error(err);
    }
  };
  Subscriber2.prototype.complete = function() {
    if (this.isStopped) {
      handleStoppedNotification(COMPLETE_NOTIFICATION, this);
    } else {
      this.isStopped = true;
      this._complete();
    }
  };
  Subscriber2.prototype.unsubscribe = function() {
    if (!this.closed) {
      this.isStopped = true;
      _super.prototype.unsubscribe.call(this);
      this.destination = null;
    }
  };
  Subscriber2.prototype._next = function(value) {
    this.destination.next(value);
  };
  Subscriber2.prototype._error = function(err) {
    try {
      this.destination.error(err);
    } finally {
      this.unsubscribe();
    }
  };
  Subscriber2.prototype._complete = function() {
    try {
      this.destination.complete();
    } finally {
      this.unsubscribe();
    }
  };
  return Subscriber2;
}(Subscription);
var _bind = Function.prototype.bind;
function bind(fn, thisArg) {
  return _bind.call(fn, thisArg);
}
var ConsumerObserver = function() {
  function ConsumerObserver2(partialObserver) {
    this.partialObserver = partialObserver;
  }
  ConsumerObserver2.prototype.next = function(value) {
    var partialObserver = this.partialObserver;
    if (partialObserver.next) {
      try {
        partialObserver.next(value);
      } catch (error) {
        handleUnhandledError(error);
      }
    }
  };
  ConsumerObserver2.prototype.error = function(err) {
    var partialObserver = this.partialObserver;
    if (partialObserver.error) {
      try {
        partialObserver.error(err);
      } catch (error) {
        handleUnhandledError(error);
      }
    } else {
      handleUnhandledError(err);
    }
  };
  ConsumerObserver2.prototype.complete = function() {
    var partialObserver = this.partialObserver;
    if (partialObserver.complete) {
      try {
        partialObserver.complete();
      } catch (error) {
        handleUnhandledError(error);
      }
    }
  };
  return ConsumerObserver2;
}();
var SafeSubscriber = function(_super) {
  __extends(SafeSubscriber2, _super);
  function SafeSubscriber2(observerOrNext, error, complete) {
    var _this = _super.call(this) || this;
    var partialObserver;
    if (isFunction2(observerOrNext) || !observerOrNext) {
      partialObserver = {
        next: observerOrNext !== null && observerOrNext !== void 0 ? observerOrNext : void 0,
        error: error !== null && error !== void 0 ? error : void 0,
        complete: complete !== null && complete !== void 0 ? complete : void 0
      };
    } else {
      var context_1;
      if (_this && config.useDeprecatedNextContext) {
        context_1 = Object.create(observerOrNext);
        context_1.unsubscribe = function() {
          return _this.unsubscribe();
        };
        partialObserver = {
          next: observerOrNext.next && bind(observerOrNext.next, context_1),
          error: observerOrNext.error && bind(observerOrNext.error, context_1),
          complete: observerOrNext.complete && bind(observerOrNext.complete, context_1)
        };
      } else {
        partialObserver = observerOrNext;
      }
    }
    _this.destination = new ConsumerObserver(partialObserver);
    return _this;
  }
  return SafeSubscriber2;
}(Subscriber);
function handleUnhandledError(error) {
  if (config.useDeprecatedSynchronousErrorHandling) {
    captureError(error);
  } else {
    reportUnhandledError(error);
  }
}
function defaultErrorHandler(err) {
  throw err;
}
function handleStoppedNotification(notification, subscriber) {
  var onStoppedNotification = config.onStoppedNotification;
  onStoppedNotification && timeoutProvider.setTimeout(function() {
    return onStoppedNotification(notification, subscriber);
  });
}
var EMPTY_OBSERVER = {
  closed: true,
  next: noop,
  error: defaultErrorHandler,
  complete: noop
};

// node_modules/rxjs/dist/esm5/internal/symbol/observable.js
var observable = function() {
  return typeof Symbol === "function" && Symbol.observable || "@@observable";
}();

// node_modules/rxjs/dist/esm5/internal/util/identity.js
function identity(x) {
  return x;
}

// node_modules/rxjs/dist/esm5/internal/util/pipe.js
function pipe() {
  var fns = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    fns[_i] = arguments[_i];
  }
  return pipeFromArray(fns);
}
function pipeFromArray(fns) {
  if (fns.length === 0) {
    return identity;
  }
  if (fns.length === 1) {
    return fns[0];
  }
  return function piped(input) {
    return fns.reduce(function(prev, fn) {
      return fn(prev);
    }, input);
  };
}

// node_modules/rxjs/dist/esm5/internal/Observable.js
var Observable = function() {
  function Observable2(subscribe) {
    if (subscribe) {
      this._subscribe = subscribe;
    }
  }
  Observable2.prototype.lift = function(operator) {
    var observable2 = new Observable2();
    observable2.source = this;
    observable2.operator = operator;
    return observable2;
  };
  Observable2.prototype.subscribe = function(observerOrNext, error, complete) {
    var _this = this;
    var subscriber = isSubscriber(observerOrNext) ? observerOrNext : new SafeSubscriber(observerOrNext, error, complete);
    errorContext(function() {
      var _a = _this, operator = _a.operator, source = _a.source;
      subscriber.add(operator ? operator.call(subscriber, source) : source ? _this._subscribe(subscriber) : _this._trySubscribe(subscriber));
    });
    return subscriber;
  };
  Observable2.prototype._trySubscribe = function(sink) {
    try {
      return this._subscribe(sink);
    } catch (err) {
      sink.error(err);
    }
  };
  Observable2.prototype.forEach = function(next, promiseCtor) {
    var _this = this;
    promiseCtor = getPromiseCtor(promiseCtor);
    return new promiseCtor(function(resolve, reject) {
      var subscriber = new SafeSubscriber({
        next: function(value) {
          try {
            next(value);
          } catch (err) {
            reject(err);
            subscriber.unsubscribe();
          }
        },
        error: reject,
        complete: resolve
      });
      _this.subscribe(subscriber);
    });
  };
  Observable2.prototype._subscribe = function(subscriber) {
    var _a;
    return (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber);
  };
  Observable2.prototype[observable] = function() {
    return this;
  };
  Observable2.prototype.pipe = function() {
    var operations = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      operations[_i] = arguments[_i];
    }
    return pipeFromArray(operations)(this);
  };
  Observable2.prototype.toPromise = function(promiseCtor) {
    var _this = this;
    promiseCtor = getPromiseCtor(promiseCtor);
    return new promiseCtor(function(resolve, reject) {
      var value;
      _this.subscribe(function(x) {
        return value = x;
      }, function(err) {
        return reject(err);
      }, function() {
        return resolve(value);
      });
    });
  };
  Observable2.create = function(subscribe) {
    return new Observable2(subscribe);
  };
  return Observable2;
}();
function getPromiseCtor(promiseCtor) {
  var _a;
  return (_a = promiseCtor !== null && promiseCtor !== void 0 ? promiseCtor : config.Promise) !== null && _a !== void 0 ? _a : Promise;
}
function isObserver(value) {
  return value && isFunction2(value.next) && isFunction2(value.error) && isFunction2(value.complete);
}
function isSubscriber(value) {
  return value && value instanceof Subscriber || isObserver(value) && isSubscription(value);
}

// node_modules/rxjs/dist/esm5/internal/util/lift.js
function hasLift(source) {
  return isFunction2(source === null || source === void 0 ? void 0 : source.lift);
}
function operate(init) {
  return function(source) {
    if (hasLift(source)) {
      return source.lift(function(liftedSource) {
        try {
          return init(liftedSource, this);
        } catch (err) {
          this.error(err);
        }
      });
    }
    throw new TypeError("Unable to lift unknown Observable type");
  };
}

// node_modules/rxjs/dist/esm5/internal/operators/OperatorSubscriber.js
function createOperatorSubscriber(destination, onNext, onComplete, onError, onFinalize) {
  return new OperatorSubscriber(destination, onNext, onComplete, onError, onFinalize);
}
var OperatorSubscriber = function(_super) {
  __extends(OperatorSubscriber2, _super);
  function OperatorSubscriber2(destination, onNext, onComplete, onError, onFinalize, shouldUnsubscribe) {
    var _this = _super.call(this, destination) || this;
    _this.onFinalize = onFinalize;
    _this.shouldUnsubscribe = shouldUnsubscribe;
    _this._next = onNext ? function(value) {
      try {
        onNext(value);
      } catch (err) {
        destination.error(err);
      }
    } : _super.prototype._next;
    _this._error = onError ? function(err) {
      try {
        onError(err);
      } catch (err2) {
        destination.error(err2);
      } finally {
        this.unsubscribe();
      }
    } : _super.prototype._error;
    _this._complete = onComplete ? function() {
      try {
        onComplete();
      } catch (err) {
        destination.error(err);
      } finally {
        this.unsubscribe();
      }
    } : _super.prototype._complete;
    return _this;
  }
  OperatorSubscriber2.prototype.unsubscribe = function() {
    var _a;
    if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {
      var closed_1 = this.closed;
      _super.prototype.unsubscribe.call(this);
      !closed_1 && ((_a = this.onFinalize) === null || _a === void 0 ? void 0 : _a.call(this));
    }
  };
  return OperatorSubscriber2;
}(Subscriber);

// node_modules/rxjs/dist/esm5/internal/operators/refCount.js
function refCount() {
  return operate(function(source, subscriber) {
    var connection = null;
    source._refCount++;
    var refCounter = createOperatorSubscriber(subscriber, void 0, void 0, void 0, function() {
      if (!source || source._refCount <= 0 || 0 < --source._refCount) {
        connection = null;
        return;
      }
      var sharedConnection = source._connection;
      var conn = connection;
      connection = null;
      if (sharedConnection && (!conn || sharedConnection === conn)) {
        sharedConnection.unsubscribe();
      }
      subscriber.unsubscribe();
    });
    source.subscribe(refCounter);
    if (!refCounter.closed) {
      connection = source.connect();
    }
  });
}

// node_modules/rxjs/dist/esm5/internal/observable/ConnectableObservable.js
var ConnectableObservable = function(_super) {
  __extends(ConnectableObservable2, _super);
  function ConnectableObservable2(source, subjectFactory) {
    var _this = _super.call(this) || this;
    _this.source = source;
    _this.subjectFactory = subjectFactory;
    _this._subject = null;
    _this._refCount = 0;
    _this._connection = null;
    if (hasLift(source)) {
      _this.lift = source.lift;
    }
    return _this;
  }
  ConnectableObservable2.prototype._subscribe = function(subscriber) {
    return this.getSubject().subscribe(subscriber);
  };
  ConnectableObservable2.prototype.getSubject = function() {
    var subject = this._subject;
    if (!subject || subject.isStopped) {
      this._subject = this.subjectFactory();
    }
    return this._subject;
  };
  ConnectableObservable2.prototype._teardown = function() {
    this._refCount = 0;
    var _connection = this._connection;
    this._subject = this._connection = null;
    _connection === null || _connection === void 0 ? void 0 : _connection.unsubscribe();
  };
  ConnectableObservable2.prototype.connect = function() {
    var _this = this;
    var connection = this._connection;
    if (!connection) {
      connection = this._connection = new Subscription();
      var subject_1 = this.getSubject();
      connection.add(this.source.subscribe(createOperatorSubscriber(subject_1, void 0, function() {
        _this._teardown();
        subject_1.complete();
      }, function(err) {
        _this._teardown();
        subject_1.error(err);
      }, function() {
        return _this._teardown();
      })));
      if (connection.closed) {
        this._connection = null;
        connection = Subscription.EMPTY;
      }
    }
    return connection;
  };
  ConnectableObservable2.prototype.refCount = function() {
    return refCount()(this);
  };
  return ConnectableObservable2;
}(Observable);

// node_modules/rxjs/dist/esm5/internal/scheduler/performanceTimestampProvider.js
var performanceTimestampProvider = {
  now: function() {
    return (performanceTimestampProvider.delegate || performance).now();
  },
  delegate: void 0
};

// node_modules/rxjs/dist/esm5/internal/scheduler/animationFrameProvider.js
var animationFrameProvider = {
  schedule: function(callback) {
    var request = requestAnimationFrame;
    var cancel = cancelAnimationFrame;
    var delegate = animationFrameProvider.delegate;
    if (delegate) {
      request = delegate.requestAnimationFrame;
      cancel = delegate.cancelAnimationFrame;
    }
    var handle = request(function(timestamp2) {
      cancel = void 0;
      callback(timestamp2);
    });
    return new Subscription(function() {
      return cancel === null || cancel === void 0 ? void 0 : cancel(handle);
    });
  },
  requestAnimationFrame: function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var delegate = animationFrameProvider.delegate;
    return ((delegate === null || delegate === void 0 ? void 0 : delegate.requestAnimationFrame) || requestAnimationFrame).apply(void 0, __spreadArray([], __read(args)));
  },
  cancelAnimationFrame: function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var delegate = animationFrameProvider.delegate;
    return ((delegate === null || delegate === void 0 ? void 0 : delegate.cancelAnimationFrame) || cancelAnimationFrame).apply(void 0, __spreadArray([], __read(args)));
  },
  delegate: void 0
};

// node_modules/rxjs/dist/esm5/internal/observable/dom/animationFrames.js
function animationFramesFactory(timestampProvider) {
  return new Observable(function(subscriber) {
    var provider = timestampProvider || performanceTimestampProvider;
    var start = provider.now();
    var id = 0;
    var run = function() {
      if (!subscriber.closed) {
        id = animationFrameProvider.requestAnimationFrame(function(timestamp2) {
          id = 0;
          var now = provider.now();
          subscriber.next({
            timestamp: timestampProvider ? now : timestamp2,
            elapsed: now - start
          });
          run();
        });
      }
    };
    run();
    return function() {
      if (id) {
        animationFrameProvider.cancelAnimationFrame(id);
      }
    };
  });
}
var DEFAULT_ANIMATION_FRAMES = animationFramesFactory();

// node_modules/rxjs/dist/esm5/internal/util/ObjectUnsubscribedError.js
var ObjectUnsubscribedError = createErrorClass(function(_super) {
  return function ObjectUnsubscribedErrorImpl() {
    _super(this);
    this.name = "ObjectUnsubscribedError";
    this.message = "object unsubscribed";
  };
});

// node_modules/rxjs/dist/esm5/internal/Subject.js
var Subject = function(_super) {
  __extends(Subject2, _super);
  function Subject2() {
    var _this = _super.call(this) || this;
    _this.closed = false;
    _this.currentObservers = null;
    _this.observers = [];
    _this.isStopped = false;
    _this.hasError = false;
    _this.thrownError = null;
    return _this;
  }
  Subject2.prototype.lift = function(operator) {
    var subject = new AnonymousSubject(this, this);
    subject.operator = operator;
    return subject;
  };
  Subject2.prototype._throwIfClosed = function() {
    if (this.closed) {
      throw new ObjectUnsubscribedError();
    }
  };
  Subject2.prototype.next = function(value) {
    var _this = this;
    errorContext(function() {
      var e_1, _a;
      _this._throwIfClosed();
      if (!_this.isStopped) {
        if (!_this.currentObservers) {
          _this.currentObservers = Array.from(_this.observers);
        }
        try {
          for (var _b = __values(_this.currentObservers), _c = _b.next(); !_c.done; _c = _b.next()) {
            var observer = _c.value;
            observer.next(value);
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
          } finally {
            if (e_1) throw e_1.error;
          }
        }
      }
    });
  };
  Subject2.prototype.error = function(err) {
    var _this = this;
    errorContext(function() {
      _this._throwIfClosed();
      if (!_this.isStopped) {
        _this.hasError = _this.isStopped = true;
        _this.thrownError = err;
        var observers = _this.observers;
        while (observers.length) {
          observers.shift().error(err);
        }
      }
    });
  };
  Subject2.prototype.complete = function() {
    var _this = this;
    errorContext(function() {
      _this._throwIfClosed();
      if (!_this.isStopped) {
        _this.isStopped = true;
        var observers = _this.observers;
        while (observers.length) {
          observers.shift().complete();
        }
      }
    });
  };
  Subject2.prototype.unsubscribe = function() {
    this.isStopped = this.closed = true;
    this.observers = this.currentObservers = null;
  };
  Object.defineProperty(Subject2.prototype, "observed", {
    get: function() {
      var _a;
      return ((_a = this.observers) === null || _a === void 0 ? void 0 : _a.length) > 0;
    },
    enumerable: false,
    configurable: true
  });
  Subject2.prototype._trySubscribe = function(subscriber) {
    this._throwIfClosed();
    return _super.prototype._trySubscribe.call(this, subscriber);
  };
  Subject2.prototype._subscribe = function(subscriber) {
    this._throwIfClosed();
    this._checkFinalizedStatuses(subscriber);
    return this._innerSubscribe(subscriber);
  };
  Subject2.prototype._innerSubscribe = function(subscriber) {
    var _this = this;
    var _a = this, hasError = _a.hasError, isStopped = _a.isStopped, observers = _a.observers;
    if (hasError || isStopped) {
      return EMPTY_SUBSCRIPTION;
    }
    this.currentObservers = null;
    observers.push(subscriber);
    return new Subscription(function() {
      _this.currentObservers = null;
      arrRemove(observers, subscriber);
    });
  };
  Subject2.prototype._checkFinalizedStatuses = function(subscriber) {
    var _a = this, hasError = _a.hasError, thrownError = _a.thrownError, isStopped = _a.isStopped;
    if (hasError) {
      subscriber.error(thrownError);
    } else if (isStopped) {
      subscriber.complete();
    }
  };
  Subject2.prototype.asObservable = function() {
    var observable2 = new Observable();
    observable2.source = this;
    return observable2;
  };
  Subject2.create = function(destination, source) {
    return new AnonymousSubject(destination, source);
  };
  return Subject2;
}(Observable);
var AnonymousSubject = function(_super) {
  __extends(AnonymousSubject2, _super);
  function AnonymousSubject2(destination, source) {
    var _this = _super.call(this) || this;
    _this.destination = destination;
    _this.source = source;
    return _this;
  }
  AnonymousSubject2.prototype.next = function(value) {
    var _a, _b;
    (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.next) === null || _b === void 0 ? void 0 : _b.call(_a, value);
  };
  AnonymousSubject2.prototype.error = function(err) {
    var _a, _b;
    (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.error) === null || _b === void 0 ? void 0 : _b.call(_a, err);
  };
  AnonymousSubject2.prototype.complete = function() {
    var _a, _b;
    (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.complete) === null || _b === void 0 ? void 0 : _b.call(_a);
  };
  AnonymousSubject2.prototype._subscribe = function(subscriber) {
    var _a, _b;
    return (_b = (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber)) !== null && _b !== void 0 ? _b : EMPTY_SUBSCRIPTION;
  };
  return AnonymousSubject2;
}(Subject);

// node_modules/rxjs/dist/esm5/internal/BehaviorSubject.js
var BehaviorSubject = function(_super) {
  __extends(BehaviorSubject2, _super);
  function BehaviorSubject2(_value) {
    var _this = _super.call(this) || this;
    _this._value = _value;
    return _this;
  }
  Object.defineProperty(BehaviorSubject2.prototype, "value", {
    get: function() {
      return this.getValue();
    },
    enumerable: false,
    configurable: true
  });
  BehaviorSubject2.prototype._subscribe = function(subscriber) {
    var subscription = _super.prototype._subscribe.call(this, subscriber);
    !subscription.closed && subscriber.next(this._value);
    return subscription;
  };
  BehaviorSubject2.prototype.getValue = function() {
    var _a = this, hasError = _a.hasError, thrownError = _a.thrownError, _value = _a._value;
    if (hasError) {
      throw thrownError;
    }
    this._throwIfClosed();
    return _value;
  };
  BehaviorSubject2.prototype.next = function(value) {
    _super.prototype.next.call(this, this._value = value);
  };
  return BehaviorSubject2;
}(Subject);

// node_modules/rxjs/dist/esm5/internal/scheduler/dateTimestampProvider.js
var dateTimestampProvider = {
  now: function() {
    return (dateTimestampProvider.delegate || Date).now();
  },
  delegate: void 0
};

// node_modules/rxjs/dist/esm5/internal/ReplaySubject.js
var ReplaySubject = function(_super) {
  __extends(ReplaySubject2, _super);
  function ReplaySubject2(_bufferSize, _windowTime, _timestampProvider) {
    if (_bufferSize === void 0) {
      _bufferSize = Infinity;
    }
    if (_windowTime === void 0) {
      _windowTime = Infinity;
    }
    if (_timestampProvider === void 0) {
      _timestampProvider = dateTimestampProvider;
    }
    var _this = _super.call(this) || this;
    _this._bufferSize = _bufferSize;
    _this._windowTime = _windowTime;
    _this._timestampProvider = _timestampProvider;
    _this._buffer = [];
    _this._infiniteTimeWindow = true;
    _this._infiniteTimeWindow = _windowTime === Infinity;
    _this._bufferSize = Math.max(1, _bufferSize);
    _this._windowTime = Math.max(1, _windowTime);
    return _this;
  }
  ReplaySubject2.prototype.next = function(value) {
    var _a = this, isStopped = _a.isStopped, _buffer = _a._buffer, _infiniteTimeWindow = _a._infiniteTimeWindow, _timestampProvider = _a._timestampProvider, _windowTime = _a._windowTime;
    if (!isStopped) {
      _buffer.push(value);
      !_infiniteTimeWindow && _buffer.push(_timestampProvider.now() + _windowTime);
    }
    this._trimBuffer();
    _super.prototype.next.call(this, value);
  };
  ReplaySubject2.prototype._subscribe = function(subscriber) {
    this._throwIfClosed();
    this._trimBuffer();
    var subscription = this._innerSubscribe(subscriber);
    var _a = this, _infiniteTimeWindow = _a._infiniteTimeWindow, _buffer = _a._buffer;
    var copy = _buffer.slice();
    for (var i = 0; i < copy.length && !subscriber.closed; i += _infiniteTimeWindow ? 1 : 2) {
      subscriber.next(copy[i]);
    }
    this._checkFinalizedStatuses(subscriber);
    return subscription;
  };
  ReplaySubject2.prototype._trimBuffer = function() {
    var _a = this, _bufferSize = _a._bufferSize, _timestampProvider = _a._timestampProvider, _buffer = _a._buffer, _infiniteTimeWindow = _a._infiniteTimeWindow;
    var adjustedBufferSize = (_infiniteTimeWindow ? 1 : 2) * _bufferSize;
    _bufferSize < Infinity && adjustedBufferSize < _buffer.length && _buffer.splice(0, _buffer.length - adjustedBufferSize);
    if (!_infiniteTimeWindow) {
      var now = _timestampProvider.now();
      var last3 = 0;
      for (var i = 1; i < _buffer.length && _buffer[i] <= now; i += 2) {
        last3 = i;
      }
      last3 && _buffer.splice(0, last3 + 1);
    }
  };
  return ReplaySubject2;
}(Subject);

// node_modules/rxjs/dist/esm5/internal/AsyncSubject.js
var AsyncSubject = function(_super) {
  __extends(AsyncSubject2, _super);
  function AsyncSubject2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this._value = null;
    _this._hasValue = false;
    _this._isComplete = false;
    return _this;
  }
  AsyncSubject2.prototype._checkFinalizedStatuses = function(subscriber) {
    var _a = this, hasError = _a.hasError, _hasValue = _a._hasValue, _value = _a._value, thrownError = _a.thrownError, isStopped = _a.isStopped, _isComplete = _a._isComplete;
    if (hasError) {
      subscriber.error(thrownError);
    } else if (isStopped || _isComplete) {
      _hasValue && subscriber.next(_value);
      subscriber.complete();
    }
  };
  AsyncSubject2.prototype.next = function(value) {
    if (!this.isStopped) {
      this._value = value;
      this._hasValue = true;
    }
  };
  AsyncSubject2.prototype.complete = function() {
    var _a = this, _hasValue = _a._hasValue, _value = _a._value, _isComplete = _a._isComplete;
    if (!_isComplete) {
      this._isComplete = true;
      _hasValue && _super.prototype.next.call(this, _value);
      _super.prototype.complete.call(this);
    }
  };
  return AsyncSubject2;
}(Subject);

// node_modules/rxjs/dist/esm5/internal/scheduler/Action.js
var Action = function(_super) {
  __extends(Action2, _super);
  function Action2(scheduler, work) {
    return _super.call(this) || this;
  }
  Action2.prototype.schedule = function(state, delay3) {
    if (delay3 === void 0) {
      delay3 = 0;
    }
    return this;
  };
  return Action2;
}(Subscription);

// node_modules/rxjs/dist/esm5/internal/scheduler/intervalProvider.js
var intervalProvider = {
  setInterval: function(handler, timeout2) {
    var args = [];
    for (var _i = 2; _i < arguments.length; _i++) {
      args[_i - 2] = arguments[_i];
    }
    var delegate = intervalProvider.delegate;
    if (delegate === null || delegate === void 0 ? void 0 : delegate.setInterval) {
      return delegate.setInterval.apply(delegate, __spreadArray([handler, timeout2], __read(args)));
    }
    return setInterval.apply(void 0, __spreadArray([handler, timeout2], __read(args)));
  },
  clearInterval: function(handle) {
    var delegate = intervalProvider.delegate;
    return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearInterval) || clearInterval)(handle);
  },
  delegate: void 0
};

// node_modules/rxjs/dist/esm5/internal/scheduler/AsyncAction.js
var AsyncAction = function(_super) {
  __extends(AsyncAction2, _super);
  function AsyncAction2(scheduler, work) {
    var _this = _super.call(this, scheduler, work) || this;
    _this.scheduler = scheduler;
    _this.work = work;
    _this.pending = false;
    return _this;
  }
  AsyncAction2.prototype.schedule = function(state, delay3) {
    var _a;
    if (delay3 === void 0) {
      delay3 = 0;
    }
    if (this.closed) {
      return this;
    }
    this.state = state;
    var id = this.id;
    var scheduler = this.scheduler;
    if (id != null) {
      this.id = this.recycleAsyncId(scheduler, id, delay3);
    }
    this.pending = true;
    this.delay = delay3;
    this.id = (_a = this.id) !== null && _a !== void 0 ? _a : this.requestAsyncId(scheduler, this.id, delay3);
    return this;
  };
  AsyncAction2.prototype.requestAsyncId = function(scheduler, _id, delay3) {
    if (delay3 === void 0) {
      delay3 = 0;
    }
    return intervalProvider.setInterval(scheduler.flush.bind(scheduler, this), delay3);
  };
  AsyncAction2.prototype.recycleAsyncId = function(_scheduler, id, delay3) {
    if (delay3 === void 0) {
      delay3 = 0;
    }
    if (delay3 != null && this.delay === delay3 && this.pending === false) {
      return id;
    }
    if (id != null) {
      intervalProvider.clearInterval(id);
    }
    return void 0;
  };
  AsyncAction2.prototype.execute = function(state, delay3) {
    if (this.closed) {
      return new Error("executing a cancelled action");
    }
    this.pending = false;
    var error = this._execute(state, delay3);
    if (error) {
      return error;
    } else if (this.pending === false && this.id != null) {
      this.id = this.recycleAsyncId(this.scheduler, this.id, null);
    }
  };
  AsyncAction2.prototype._execute = function(state, _delay) {
    var errored = false;
    var errorValue;
    try {
      this.work(state);
    } catch (e2) {
      errored = true;
      errorValue = e2 ? e2 : new Error("Scheduled action threw falsy error");
    }
    if (errored) {
      this.unsubscribe();
      return errorValue;
    }
  };
  AsyncAction2.prototype.unsubscribe = function() {
    if (!this.closed) {
      var _a = this, id = _a.id, scheduler = _a.scheduler;
      var actions = scheduler.actions;
      this.work = this.state = this.scheduler = null;
      this.pending = false;
      arrRemove(actions, this);
      if (id != null) {
        this.id = this.recycleAsyncId(scheduler, id, null);
      }
      this.delay = null;
      _super.prototype.unsubscribe.call(this);
    }
  };
  return AsyncAction2;
}(Action);

// node_modules/rxjs/dist/esm5/internal/util/Immediate.js
var nextHandle = 1;
var resolved;
var activeHandles = {};
function findAndClearHandle(handle) {
  if (handle in activeHandles) {
    delete activeHandles[handle];
    return true;
  }
  return false;
}
var Immediate = {
  setImmediate: function(cb) {
    var handle = nextHandle++;
    activeHandles[handle] = true;
    if (!resolved) {
      resolved = Promise.resolve();
    }
    resolved.then(function() {
      return findAndClearHandle(handle) && cb();
    });
    return handle;
  },
  clearImmediate: function(handle) {
    findAndClearHandle(handle);
  }
};

// node_modules/rxjs/dist/esm5/internal/scheduler/immediateProvider.js
var setImmediate = Immediate.setImmediate;
var clearImmediate = Immediate.clearImmediate;
var immediateProvider = {
  setImmediate: function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var delegate = immediateProvider.delegate;
    return ((delegate === null || delegate === void 0 ? void 0 : delegate.setImmediate) || setImmediate).apply(void 0, __spreadArray([], __read(args)));
  },
  clearImmediate: function(handle) {
    var delegate = immediateProvider.delegate;
    return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearImmediate) || clearImmediate)(handle);
  },
  delegate: void 0
};

// node_modules/rxjs/dist/esm5/internal/scheduler/AsapAction.js
var AsapAction = function(_super) {
  __extends(AsapAction2, _super);
  function AsapAction2(scheduler, work) {
    var _this = _super.call(this, scheduler, work) || this;
    _this.scheduler = scheduler;
    _this.work = work;
    return _this;
  }
  AsapAction2.prototype.requestAsyncId = function(scheduler, id, delay3) {
    if (delay3 === void 0) {
      delay3 = 0;
    }
    if (delay3 !== null && delay3 > 0) {
      return _super.prototype.requestAsyncId.call(this, scheduler, id, delay3);
    }
    scheduler.actions.push(this);
    return scheduler._scheduled || (scheduler._scheduled = immediateProvider.setImmediate(scheduler.flush.bind(scheduler, void 0)));
  };
  AsapAction2.prototype.recycleAsyncId = function(scheduler, id, delay3) {
    var _a;
    if (delay3 === void 0) {
      delay3 = 0;
    }
    if (delay3 != null ? delay3 > 0 : this.delay > 0) {
      return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay3);
    }
    var actions = scheduler.actions;
    if (id != null && ((_a = actions[actions.length - 1]) === null || _a === void 0 ? void 0 : _a.id) !== id) {
      immediateProvider.clearImmediate(id);
      if (scheduler._scheduled === id) {
        scheduler._scheduled = void 0;
      }
    }
    return void 0;
  };
  return AsapAction2;
}(AsyncAction);

// node_modules/rxjs/dist/esm5/internal/Scheduler.js
var Scheduler = function() {
  function Scheduler2(schedulerActionCtor, now) {
    if (now === void 0) {
      now = Scheduler2.now;
    }
    this.schedulerActionCtor = schedulerActionCtor;
    this.now = now;
  }
  Scheduler2.prototype.schedule = function(work, delay3, state) {
    if (delay3 === void 0) {
      delay3 = 0;
    }
    return new this.schedulerActionCtor(this, work).schedule(state, delay3);
  };
  Scheduler2.now = dateTimestampProvider.now;
  return Scheduler2;
}();

// node_modules/rxjs/dist/esm5/internal/scheduler/AsyncScheduler.js
var AsyncScheduler = function(_super) {
  __extends(AsyncScheduler2, _super);
  function AsyncScheduler2(SchedulerAction, now) {
    if (now === void 0) {
      now = Scheduler.now;
    }
    var _this = _super.call(this, SchedulerAction, now) || this;
    _this.actions = [];
    _this._active = false;
    return _this;
  }
  AsyncScheduler2.prototype.flush = function(action) {
    var actions = this.actions;
    if (this._active) {
      actions.push(action);
      return;
    }
    var error;
    this._active = true;
    do {
      if (error = action.execute(action.state, action.delay)) {
        break;
      }
    } while (action = actions.shift());
    this._active = false;
    if (error) {
      while (action = actions.shift()) {
        action.unsubscribe();
      }
      throw error;
    }
  };
  return AsyncScheduler2;
}(Scheduler);

// node_modules/rxjs/dist/esm5/internal/scheduler/AsapScheduler.js
var AsapScheduler = function(_super) {
  __extends(AsapScheduler2, _super);
  function AsapScheduler2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  AsapScheduler2.prototype.flush = function(action) {
    this._active = true;
    var flushId = this._scheduled;
    this._scheduled = void 0;
    var actions = this.actions;
    var error;
    action = action || actions.shift();
    do {
      if (error = action.execute(action.state, action.delay)) {
        break;
      }
    } while ((action = actions[0]) && action.id === flushId && actions.shift());
    this._active = false;
    if (error) {
      while ((action = actions[0]) && action.id === flushId && actions.shift()) {
        action.unsubscribe();
      }
      throw error;
    }
  };
  return AsapScheduler2;
}(AsyncScheduler);

// node_modules/rxjs/dist/esm5/internal/scheduler/asap.js
var asapScheduler = new AsapScheduler(AsapAction);

// node_modules/rxjs/dist/esm5/internal/scheduler/async.js
var asyncScheduler = new AsyncScheduler(AsyncAction);
var async = asyncScheduler;

// node_modules/rxjs/dist/esm5/internal/scheduler/QueueAction.js
var QueueAction = function(_super) {
  __extends(QueueAction2, _super);
  function QueueAction2(scheduler, work) {
    var _this = _super.call(this, scheduler, work) || this;
    _this.scheduler = scheduler;
    _this.work = work;
    return _this;
  }
  QueueAction2.prototype.schedule = function(state, delay3) {
    if (delay3 === void 0) {
      delay3 = 0;
    }
    if (delay3 > 0) {
      return _super.prototype.schedule.call(this, state, delay3);
    }
    this.delay = delay3;
    this.state = state;
    this.scheduler.flush(this);
    return this;
  };
  QueueAction2.prototype.execute = function(state, delay3) {
    return delay3 > 0 || this.closed ? _super.prototype.execute.call(this, state, delay3) : this._execute(state, delay3);
  };
  QueueAction2.prototype.requestAsyncId = function(scheduler, id, delay3) {
    if (delay3 === void 0) {
      delay3 = 0;
    }
    if (delay3 != null && delay3 > 0 || delay3 == null && this.delay > 0) {
      return _super.prototype.requestAsyncId.call(this, scheduler, id, delay3);
    }
    scheduler.flush(this);
    return 0;
  };
  return QueueAction2;
}(AsyncAction);

// node_modules/rxjs/dist/esm5/internal/scheduler/QueueScheduler.js
var QueueScheduler = function(_super) {
  __extends(QueueScheduler2, _super);
  function QueueScheduler2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  return QueueScheduler2;
}(AsyncScheduler);

// node_modules/rxjs/dist/esm5/internal/scheduler/queue.js
var queueScheduler = new QueueScheduler(QueueAction);

// node_modules/rxjs/dist/esm5/internal/scheduler/AnimationFrameAction.js
var AnimationFrameAction = function(_super) {
  __extends(AnimationFrameAction2, _super);
  function AnimationFrameAction2(scheduler, work) {
    var _this = _super.call(this, scheduler, work) || this;
    _this.scheduler = scheduler;
    _this.work = work;
    return _this;
  }
  AnimationFrameAction2.prototype.requestAsyncId = function(scheduler, id, delay3) {
    if (delay3 === void 0) {
      delay3 = 0;
    }
    if (delay3 !== null && delay3 > 0) {
      return _super.prototype.requestAsyncId.call(this, scheduler, id, delay3);
    }
    scheduler.actions.push(this);
    return scheduler._scheduled || (scheduler._scheduled = animationFrameProvider.requestAnimationFrame(function() {
      return scheduler.flush(void 0);
    }));
  };
  AnimationFrameAction2.prototype.recycleAsyncId = function(scheduler, id, delay3) {
    var _a;
    if (delay3 === void 0) {
      delay3 = 0;
    }
    if (delay3 != null ? delay3 > 0 : this.delay > 0) {
      return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay3);
    }
    var actions = scheduler.actions;
    if (id != null && ((_a = actions[actions.length - 1]) === null || _a === void 0 ? void 0 : _a.id) !== id) {
      animationFrameProvider.cancelAnimationFrame(id);
      scheduler._scheduled = void 0;
    }
    return void 0;
  };
  return AnimationFrameAction2;
}(AsyncAction);

// node_modules/rxjs/dist/esm5/internal/scheduler/AnimationFrameScheduler.js
var AnimationFrameScheduler = function(_super) {
  __extends(AnimationFrameScheduler2, _super);
  function AnimationFrameScheduler2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  AnimationFrameScheduler2.prototype.flush = function(action) {
    this._active = true;
    var flushId = this._scheduled;
    this._scheduled = void 0;
    var actions = this.actions;
    var error;
    action = action || actions.shift();
    do {
      if (error = action.execute(action.state, action.delay)) {
        break;
      }
    } while ((action = actions[0]) && action.id === flushId && actions.shift());
    this._active = false;
    if (error) {
      while ((action = actions[0]) && action.id === flushId && actions.shift()) {
        action.unsubscribe();
      }
      throw error;
    }
  };
  return AnimationFrameScheduler2;
}(AsyncScheduler);

// node_modules/rxjs/dist/esm5/internal/scheduler/animationFrame.js
var animationFrameScheduler = new AnimationFrameScheduler(AnimationFrameAction);

// node_modules/rxjs/dist/esm5/internal/scheduler/VirtualTimeScheduler.js
var VirtualTimeScheduler = function(_super) {
  __extends(VirtualTimeScheduler2, _super);
  function VirtualTimeScheduler2(schedulerActionCtor, maxFrames) {
    if (schedulerActionCtor === void 0) {
      schedulerActionCtor = VirtualAction;
    }
    if (maxFrames === void 0) {
      maxFrames = Infinity;
    }
    var _this = _super.call(this, schedulerActionCtor, function() {
      return _this.frame;
    }) || this;
    _this.maxFrames = maxFrames;
    _this.frame = 0;
    _this.index = -1;
    return _this;
  }
  VirtualTimeScheduler2.prototype.flush = function() {
    var _a = this, actions = _a.actions, maxFrames = _a.maxFrames;
    var error;
    var action;
    while ((action = actions[0]) && action.delay <= maxFrames) {
      actions.shift();
      this.frame = action.delay;
      if (error = action.execute(action.state, action.delay)) {
        break;
      }
    }
    if (error) {
      while (action = actions.shift()) {
        action.unsubscribe();
      }
      throw error;
    }
  };
  VirtualTimeScheduler2.frameTimeFactor = 10;
  return VirtualTimeScheduler2;
}(AsyncScheduler);
var VirtualAction = function(_super) {
  __extends(VirtualAction2, _super);
  function VirtualAction2(scheduler, work, index) {
    if (index === void 0) {
      index = scheduler.index += 1;
    }
    var _this = _super.call(this, scheduler, work) || this;
    _this.scheduler = scheduler;
    _this.work = work;
    _this.index = index;
    _this.active = true;
    _this.index = scheduler.index = index;
    return _this;
  }
  VirtualAction2.prototype.schedule = function(state, delay3) {
    if (delay3 === void 0) {
      delay3 = 0;
    }
    if (Number.isFinite(delay3)) {
      if (!this.id) {
        return _super.prototype.schedule.call(this, state, delay3);
      }
      this.active = false;
      var action = new VirtualAction2(this.scheduler, this.work);
      this.add(action);
      return action.schedule(state, delay3);
    } else {
      return Subscription.EMPTY;
    }
  };
  VirtualAction2.prototype.requestAsyncId = function(scheduler, id, delay3) {
    if (delay3 === void 0) {
      delay3 = 0;
    }
    this.delay = scheduler.frame + delay3;
    var actions = scheduler.actions;
    actions.push(this);
    actions.sort(VirtualAction2.sortActions);
    return 1;
  };
  VirtualAction2.prototype.recycleAsyncId = function(scheduler, id, delay3) {
    if (delay3 === void 0) {
      delay3 = 0;
    }
    return void 0;
  };
  VirtualAction2.prototype._execute = function(state, delay3) {
    if (this.active === true) {
      return _super.prototype._execute.call(this, state, delay3);
    }
  };
  VirtualAction2.sortActions = function(a2, b2) {
    if (a2.delay === b2.delay) {
      if (a2.index === b2.index) {
        return 0;
      } else if (a2.index > b2.index) {
        return 1;
      } else {
        return -1;
      }
    } else if (a2.delay > b2.delay) {
      return 1;
    } else {
      return -1;
    }
  };
  return VirtualAction2;
}(AsyncAction);

// node_modules/rxjs/dist/esm5/internal/observable/empty.js
var EMPTY = new Observable(function(subscriber) {
  return subscriber.complete();
});

// node_modules/rxjs/dist/esm5/internal/util/isScheduler.js
function isScheduler(value) {
  return value && isFunction2(value.schedule);
}

// node_modules/rxjs/dist/esm5/internal/util/args.js
function last(arr) {
  return arr[arr.length - 1];
}
function popResultSelector(args) {
  return isFunction2(last(args)) ? args.pop() : void 0;
}
function popScheduler(args) {
  return isScheduler(last(args)) ? args.pop() : void 0;
}
function popNumber(args, defaultValue) {
  return typeof last(args) === "number" ? args.pop() : defaultValue;
}

// node_modules/rxjs/dist/esm5/internal/util/isArrayLike.js
var isArrayLike = function(x) {
  return x && typeof x.length === "number" && typeof x !== "function";
};

// node_modules/rxjs/dist/esm5/internal/util/isPromise.js
function isPromise(value) {
  return isFunction2(value === null || value === void 0 ? void 0 : value.then);
}

// node_modules/rxjs/dist/esm5/internal/util/isInteropObservable.js
function isInteropObservable(input) {
  return isFunction2(input[observable]);
}

// node_modules/rxjs/dist/esm5/internal/util/isAsyncIterable.js
function isAsyncIterable(obj) {
  return Symbol.asyncIterator && isFunction2(obj === null || obj === void 0 ? void 0 : obj[Symbol.asyncIterator]);
}

// node_modules/rxjs/dist/esm5/internal/util/throwUnobservableError.js
function createInvalidObservableTypeError(input) {
  return new TypeError("You provided " + (input !== null && typeof input === "object" ? "an invalid object" : "'" + input + "'") + " where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.");
}

// node_modules/rxjs/dist/esm5/internal/symbol/iterator.js
function getSymbolIterator() {
  if (typeof Symbol !== "function" || !Symbol.iterator) {
    return "@@iterator";
  }
  return Symbol.iterator;
}
var iterator = getSymbolIterator();

// node_modules/rxjs/dist/esm5/internal/util/isIterable.js
function isIterable(input) {
  return isFunction2(input === null || input === void 0 ? void 0 : input[iterator]);
}

// node_modules/rxjs/dist/esm5/internal/util/isReadableStreamLike.js
function readableStreamLikeToAsyncGenerator(readableStream) {
  return __asyncGenerator(this, arguments, function readableStreamLikeToAsyncGenerator_1() {
    var reader, _a, value, done;
    return __generator(this, function(_b) {
      switch (_b.label) {
        case 0:
          reader = readableStream.getReader();
          _b.label = 1;
        case 1:
          _b.trys.push([1, , 9, 10]);
          _b.label = 2;
        case 2:
          if (false) return [3, 8];
          return [4, __await(reader.read())];
        case 3:
          _a = _b.sent(), value = _a.value, done = _a.done;
          if (!done) return [3, 5];
          return [4, __await(void 0)];
        case 4:
          return [2, _b.sent()];
        case 5:
          return [4, __await(value)];
        case 6:
          return [4, _b.sent()];
        case 7:
          _b.sent();
          return [3, 2];
        case 8:
          return [3, 10];
        case 9:
          reader.releaseLock();
          return [7];
        case 10:
          return [2];
      }
    });
  });
}
function isReadableStreamLike(obj) {
  return isFunction2(obj === null || obj === void 0 ? void 0 : obj.getReader);
}

// node_modules/rxjs/dist/esm5/internal/observable/innerFrom.js
function innerFrom(input) {
  if (input instanceof Observable) {
    return input;
  }
  if (input != null) {
    if (isInteropObservable(input)) {
      return fromInteropObservable(input);
    }
    if (isArrayLike(input)) {
      return fromArrayLike(input);
    }
    if (isPromise(input)) {
      return fromPromise(input);
    }
    if (isAsyncIterable(input)) {
      return fromAsyncIterable(input);
    }
    if (isIterable(input)) {
      return fromIterable(input);
    }
    if (isReadableStreamLike(input)) {
      return fromReadableStreamLike(input);
    }
  }
  throw createInvalidObservableTypeError(input);
}
function fromInteropObservable(obj) {
  return new Observable(function(subscriber) {
    var obs = obj[observable]();
    if (isFunction2(obs.subscribe)) {
      return obs.subscribe(subscriber);
    }
    throw new TypeError("Provided object does not correctly implement Symbol.observable");
  });
}
function fromArrayLike(array) {
  return new Observable(function(subscriber) {
    for (var i = 0; i < array.length && !subscriber.closed; i++) {
      subscriber.next(array[i]);
    }
    subscriber.complete();
  });
}
function fromPromise(promise) {
  return new Observable(function(subscriber) {
    promise.then(function(value) {
      if (!subscriber.closed) {
        subscriber.next(value);
        subscriber.complete();
      }
    }, function(err) {
      return subscriber.error(err);
    }).then(null, reportUnhandledError);
  });
}
function fromIterable(iterable) {
  return new Observable(function(subscriber) {
    var e_1, _a;
    try {
      for (var iterable_1 = __values(iterable), iterable_1_1 = iterable_1.next(); !iterable_1_1.done; iterable_1_1 = iterable_1.next()) {
        var value = iterable_1_1.value;
        subscriber.next(value);
        if (subscriber.closed) {
          return;
        }
      }
    } catch (e_1_1) {
      e_1 = { error: e_1_1 };
    } finally {
      try {
        if (iterable_1_1 && !iterable_1_1.done && (_a = iterable_1.return)) _a.call(iterable_1);
      } finally {
        if (e_1) throw e_1.error;
      }
    }
    subscriber.complete();
  });
}
function fromAsyncIterable(asyncIterable) {
  return new Observable(function(subscriber) {
    process(asyncIterable, subscriber).catch(function(err) {
      return subscriber.error(err);
    });
  });
}
function fromReadableStreamLike(readableStream) {
  return fromAsyncIterable(readableStreamLikeToAsyncGenerator(readableStream));
}
function process(asyncIterable, subscriber) {
  var asyncIterable_1, asyncIterable_1_1;
  var e_2, _a;
  return __awaiter(this, void 0, void 0, function() {
    var value, e_2_1;
    return __generator(this, function(_b) {
      switch (_b.label) {
        case 0:
          _b.trys.push([0, 5, 6, 11]);
          asyncIterable_1 = __asyncValues(asyncIterable);
          _b.label = 1;
        case 1:
          return [4, asyncIterable_1.next()];
        case 2:
          if (!(asyncIterable_1_1 = _b.sent(), !asyncIterable_1_1.done)) return [3, 4];
          value = asyncIterable_1_1.value;
          subscriber.next(value);
          if (subscriber.closed) {
            return [2];
          }
          _b.label = 3;
        case 3:
          return [3, 1];
        case 4:
          return [3, 11];
        case 5:
          e_2_1 = _b.sent();
          e_2 = { error: e_2_1 };
          return [3, 11];
        case 6:
          _b.trys.push([6, , 9, 10]);
          if (!(asyncIterable_1_1 && !asyncIterable_1_1.done && (_a = asyncIterable_1.return))) return [3, 8];
          return [4, _a.call(asyncIterable_1)];
        case 7:
          _b.sent();
          _b.label = 8;
        case 8:
          return [3, 10];
        case 9:
          if (e_2) throw e_2.error;
          return [7];
        case 10:
          return [7];
        case 11:
          subscriber.complete();
          return [2];
      }
    });
  });
}

// node_modules/rxjs/dist/esm5/internal/util/executeSchedule.js
function executeSchedule(parentSubscription, scheduler, work, delay3, repeat2) {
  if (delay3 === void 0) {
    delay3 = 0;
  }
  if (repeat2 === void 0) {
    repeat2 = false;
  }
  var scheduleSubscription = scheduler.schedule(function() {
    work();
    if (repeat2) {
      parentSubscription.add(this.schedule(null, delay3));
    } else {
      this.unsubscribe();
    }
  }, delay3);
  parentSubscription.add(scheduleSubscription);
  if (!repeat2) {
    return scheduleSubscription;
  }
}

// node_modules/rxjs/dist/esm5/internal/operators/observeOn.js
function observeOn(scheduler, delay3) {
  if (delay3 === void 0) {
    delay3 = 0;
  }
  return operate(function(source, subscriber) {
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      return executeSchedule(subscriber, scheduler, function() {
        return subscriber.next(value);
      }, delay3);
    }, function() {
      return executeSchedule(subscriber, scheduler, function() {
        return subscriber.complete();
      }, delay3);
    }, function(err) {
      return executeSchedule(subscriber, scheduler, function() {
        return subscriber.error(err);
      }, delay3);
    }));
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/subscribeOn.js
function subscribeOn(scheduler, delay3) {
  if (delay3 === void 0) {
    delay3 = 0;
  }
  return operate(function(source, subscriber) {
    subscriber.add(scheduler.schedule(function() {
      return source.subscribe(subscriber);
    }, delay3));
  });
}

// node_modules/rxjs/dist/esm5/internal/scheduled/scheduleObservable.js
function scheduleObservable(input, scheduler) {
  return innerFrom(input).pipe(subscribeOn(scheduler), observeOn(scheduler));
}

// node_modules/rxjs/dist/esm5/internal/scheduled/schedulePromise.js
function schedulePromise(input, scheduler) {
  return innerFrom(input).pipe(subscribeOn(scheduler), observeOn(scheduler));
}

// node_modules/rxjs/dist/esm5/internal/scheduled/scheduleArray.js
function scheduleArray(input, scheduler) {
  return new Observable(function(subscriber) {
    var i = 0;
    return scheduler.schedule(function() {
      if (i === input.length) {
        subscriber.complete();
      } else {
        subscriber.next(input[i++]);
        if (!subscriber.closed) {
          this.schedule();
        }
      }
    });
  });
}

// node_modules/rxjs/dist/esm5/internal/scheduled/scheduleIterable.js
function scheduleIterable(input, scheduler) {
  return new Observable(function(subscriber) {
    var iterator2;
    executeSchedule(subscriber, scheduler, function() {
      iterator2 = input[iterator]();
      executeSchedule(subscriber, scheduler, function() {
        var _a;
        var value;
        var done;
        try {
          _a = iterator2.next(), value = _a.value, done = _a.done;
        } catch (err) {
          subscriber.error(err);
          return;
        }
        if (done) {
          subscriber.complete();
        } else {
          subscriber.next(value);
        }
      }, 0, true);
    });
    return function() {
      return isFunction2(iterator2 === null || iterator2 === void 0 ? void 0 : iterator2.return) && iterator2.return();
    };
  });
}

// node_modules/rxjs/dist/esm5/internal/scheduled/scheduleAsyncIterable.js
function scheduleAsyncIterable(input, scheduler) {
  if (!input) {
    throw new Error("Iterable cannot be null");
  }
  return new Observable(function(subscriber) {
    executeSchedule(subscriber, scheduler, function() {
      var iterator2 = input[Symbol.asyncIterator]();
      executeSchedule(subscriber, scheduler, function() {
        iterator2.next().then(function(result) {
          if (result.done) {
            subscriber.complete();
          } else {
            subscriber.next(result.value);
          }
        });
      }, 0, true);
    });
  });
}

// node_modules/rxjs/dist/esm5/internal/scheduled/scheduleReadableStreamLike.js
function scheduleReadableStreamLike(input, scheduler) {
  return scheduleAsyncIterable(readableStreamLikeToAsyncGenerator(input), scheduler);
}

// node_modules/rxjs/dist/esm5/internal/scheduled/scheduled.js
function scheduled(input, scheduler) {
  if (input != null) {
    if (isInteropObservable(input)) {
      return scheduleObservable(input, scheduler);
    }
    if (isArrayLike(input)) {
      return scheduleArray(input, scheduler);
    }
    if (isPromise(input)) {
      return schedulePromise(input, scheduler);
    }
    if (isAsyncIterable(input)) {
      return scheduleAsyncIterable(input, scheduler);
    }
    if (isIterable(input)) {
      return scheduleIterable(input, scheduler);
    }
    if (isReadableStreamLike(input)) {
      return scheduleReadableStreamLike(input, scheduler);
    }
  }
  throw createInvalidObservableTypeError(input);
}

// node_modules/rxjs/dist/esm5/internal/observable/from.js
function from(input, scheduler) {
  return scheduler ? scheduled(input, scheduler) : innerFrom(input);
}

// node_modules/rxjs/dist/esm5/internal/observable/of.js
function of() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  var scheduler = popScheduler(args);
  return from(args, scheduler);
}

// node_modules/rxjs/dist/esm5/internal/observable/throwError.js
function throwError(errorOrErrorFactory, scheduler) {
  var errorFactory = isFunction2(errorOrErrorFactory) ? errorOrErrorFactory : function() {
    return errorOrErrorFactory;
  };
  var init = function(subscriber) {
    return subscriber.error(errorFactory());
  };
  return new Observable(scheduler ? function(subscriber) {
    return scheduler.schedule(init, 0, subscriber);
  } : init);
}

// node_modules/rxjs/dist/esm5/internal/Notification.js
var NotificationKind;
(function(NotificationKind2) {
  NotificationKind2["NEXT"] = "N";
  NotificationKind2["ERROR"] = "E";
  NotificationKind2["COMPLETE"] = "C";
})(NotificationKind || (NotificationKind = {}));
var Notification = function() {
  function Notification2(kind, value, error) {
    this.kind = kind;
    this.value = value;
    this.error = error;
    this.hasValue = kind === "N";
  }
  Notification2.prototype.observe = function(observer) {
    return observeNotification(this, observer);
  };
  Notification2.prototype.do = function(nextHandler, errorHandler, completeHandler) {
    var _a = this, kind = _a.kind, value = _a.value, error = _a.error;
    return kind === "N" ? nextHandler === null || nextHandler === void 0 ? void 0 : nextHandler(value) : kind === "E" ? errorHandler === null || errorHandler === void 0 ? void 0 : errorHandler(error) : completeHandler === null || completeHandler === void 0 ? void 0 : completeHandler();
  };
  Notification2.prototype.accept = function(nextOrObserver, error, complete) {
    var _a;
    return isFunction2((_a = nextOrObserver) === null || _a === void 0 ? void 0 : _a.next) ? this.observe(nextOrObserver) : this.do(nextOrObserver, error, complete);
  };
  Notification2.prototype.toObservable = function() {
    var _a = this, kind = _a.kind, value = _a.value, error = _a.error;
    var result = kind === "N" ? of(value) : kind === "E" ? throwError(function() {
      return error;
    }) : kind === "C" ? EMPTY : 0;
    if (!result) {
      throw new TypeError("Unexpected notification kind " + kind);
    }
    return result;
  };
  Notification2.createNext = function(value) {
    return new Notification2("N", value);
  };
  Notification2.createError = function(err) {
    return new Notification2("E", void 0, err);
  };
  Notification2.createComplete = function() {
    return Notification2.completeNotification;
  };
  Notification2.completeNotification = new Notification2("C");
  return Notification2;
}();
function observeNotification(notification, observer) {
  var _a, _b, _c;
  var _d = notification, kind = _d.kind, value = _d.value, error = _d.error;
  if (typeof kind !== "string") {
    throw new TypeError('Invalid notification, missing "kind"');
  }
  kind === "N" ? (_a = observer.next) === null || _a === void 0 ? void 0 : _a.call(observer, value) : kind === "E" ? (_b = observer.error) === null || _b === void 0 ? void 0 : _b.call(observer, error) : (_c = observer.complete) === null || _c === void 0 ? void 0 : _c.call(observer);
}

// node_modules/rxjs/dist/esm5/internal/util/EmptyError.js
var EmptyError = createErrorClass(function(_super) {
  return function EmptyErrorImpl() {
    _super(this);
    this.name = "EmptyError";
    this.message = "no elements in sequence";
  };
});

// node_modules/rxjs/dist/esm5/internal/firstValueFrom.js
function firstValueFrom(source, config2) {
  var hasConfig = typeof config2 === "object";
  return new Promise(function(resolve, reject) {
    var subscriber = new SafeSubscriber({
      next: function(value) {
        resolve(value);
        subscriber.unsubscribe();
      },
      error: reject,
      complete: function() {
        if (hasConfig) {
          resolve(config2.defaultValue);
        } else {
          reject(new EmptyError());
        }
      }
    });
    source.subscribe(subscriber);
  });
}

// node_modules/rxjs/dist/esm5/internal/util/ArgumentOutOfRangeError.js
var ArgumentOutOfRangeError = createErrorClass(function(_super) {
  return function ArgumentOutOfRangeErrorImpl() {
    _super(this);
    this.name = "ArgumentOutOfRangeError";
    this.message = "argument out of range";
  };
});

// node_modules/rxjs/dist/esm5/internal/util/NotFoundError.js
var NotFoundError = createErrorClass(function(_super) {
  return function NotFoundErrorImpl(message) {
    _super(this);
    this.name = "NotFoundError";
    this.message = message;
  };
});

// node_modules/rxjs/dist/esm5/internal/util/SequenceError.js
var SequenceError = createErrorClass(function(_super) {
  return function SequenceErrorImpl(message) {
    _super(this);
    this.name = "SequenceError";
    this.message = message;
  };
});

// node_modules/rxjs/dist/esm5/internal/util/isDate.js
function isValidDate(value) {
  return value instanceof Date && !isNaN(value);
}

// node_modules/rxjs/dist/esm5/internal/operators/timeout.js
var TimeoutError = createErrorClass(function(_super) {
  return function TimeoutErrorImpl(info) {
    if (info === void 0) {
      info = null;
    }
    _super(this);
    this.message = "Timeout has occurred";
    this.name = "TimeoutError";
    this.info = info;
  };
});

// node_modules/rxjs/dist/esm5/internal/operators/map.js
function map(project, thisArg) {
  return operate(function(source, subscriber) {
    var index = 0;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      subscriber.next(project.call(thisArg, value, index++));
    }));
  });
}

// node_modules/rxjs/dist/esm5/internal/util/mapOneOrManyArgs.js
var isArray = Array.isArray;
function callOrApply(fn, args) {
  return isArray(args) ? fn.apply(void 0, __spreadArray([], __read(args))) : fn(args);
}
function mapOneOrManyArgs(fn) {
  return map(function(args) {
    return callOrApply(fn, args);
  });
}

// node_modules/rxjs/dist/esm5/internal/util/argsArgArrayOrObject.js
var isArray2 = Array.isArray;
var getPrototypeOf = Object.getPrototypeOf;
var objectProto = Object.prototype;
var getKeys = Object.keys;
function argsArgArrayOrObject(args) {
  if (args.length === 1) {
    var first_1 = args[0];
    if (isArray2(first_1)) {
      return { args: first_1, keys: null };
    }
    if (isPOJO(first_1)) {
      var keys = getKeys(first_1);
      return {
        args: keys.map(function(key) {
          return first_1[key];
        }),
        keys
      };
    }
  }
  return { args, keys: null };
}
function isPOJO(obj) {
  return obj && typeof obj === "object" && getPrototypeOf(obj) === objectProto;
}

// node_modules/rxjs/dist/esm5/internal/util/createObject.js
function createObject(keys, values) {
  return keys.reduce(function(result, key, i) {
    return result[key] = values[i], result;
  }, {});
}

// node_modules/rxjs/dist/esm5/internal/observable/combineLatest.js
function combineLatestInit(observables, scheduler, valueTransform) {
  if (valueTransform === void 0) {
    valueTransform = identity;
  }
  return function(subscriber) {
    maybeSchedule(scheduler, function() {
      var length = observables.length;
      var values = new Array(length);
      var active = length;
      var remainingFirstValues = length;
      var _loop_1 = function(i2) {
        maybeSchedule(scheduler, function() {
          var source = from(observables[i2], scheduler);
          var hasFirstValue = false;
          source.subscribe(createOperatorSubscriber(subscriber, function(value) {
            values[i2] = value;
            if (!hasFirstValue) {
              hasFirstValue = true;
              remainingFirstValues--;
            }
            if (!remainingFirstValues) {
              subscriber.next(valueTransform(values.slice()));
            }
          }, function() {
            if (!--active) {
              subscriber.complete();
            }
          }));
        }, subscriber);
      };
      for (var i = 0; i < length; i++) {
        _loop_1(i);
      }
    }, subscriber);
  };
}
function maybeSchedule(scheduler, execute, subscription) {
  if (scheduler) {
    executeSchedule(subscription, scheduler, execute);
  } else {
    execute();
  }
}

// node_modules/rxjs/dist/esm5/internal/operators/mergeInternals.js
function mergeInternals(source, subscriber, project, concurrent, onBeforeNext, expand2, innerSubScheduler, additionalFinalizer) {
  var buffer2 = [];
  var active = 0;
  var index = 0;
  var isComplete = false;
  var checkComplete = function() {
    if (isComplete && !buffer2.length && !active) {
      subscriber.complete();
    }
  };
  var outerNext = function(value) {
    return active < concurrent ? doInnerSub(value) : buffer2.push(value);
  };
  var doInnerSub = function(value) {
    expand2 && subscriber.next(value);
    active++;
    var innerComplete = false;
    innerFrom(project(value, index++)).subscribe(createOperatorSubscriber(subscriber, function(innerValue) {
      onBeforeNext === null || onBeforeNext === void 0 ? void 0 : onBeforeNext(innerValue);
      if (expand2) {
        outerNext(innerValue);
      } else {
        subscriber.next(innerValue);
      }
    }, function() {
      innerComplete = true;
    }, void 0, function() {
      if (innerComplete) {
        try {
          active--;
          var _loop_1 = function() {
            var bufferedValue = buffer2.shift();
            if (innerSubScheduler) {
              executeSchedule(subscriber, innerSubScheduler, function() {
                return doInnerSub(bufferedValue);
              });
            } else {
              doInnerSub(bufferedValue);
            }
          };
          while (buffer2.length && active < concurrent) {
            _loop_1();
          }
          checkComplete();
        } catch (err) {
          subscriber.error(err);
        }
      }
    }));
  };
  source.subscribe(createOperatorSubscriber(subscriber, outerNext, function() {
    isComplete = true;
    checkComplete();
  }));
  return function() {
    additionalFinalizer === null || additionalFinalizer === void 0 ? void 0 : additionalFinalizer();
  };
}

// node_modules/rxjs/dist/esm5/internal/operators/mergeMap.js
function mergeMap(project, resultSelector, concurrent) {
  if (concurrent === void 0) {
    concurrent = Infinity;
  }
  if (isFunction2(resultSelector)) {
    return mergeMap(function(a2, i) {
      return map(function(b2, ii) {
        return resultSelector(a2, b2, i, ii);
      })(innerFrom(project(a2, i)));
    }, concurrent);
  } else if (typeof resultSelector === "number") {
    concurrent = resultSelector;
  }
  return operate(function(source, subscriber) {
    return mergeInternals(source, subscriber, project, concurrent);
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/mergeAll.js
function mergeAll(concurrent) {
  if (concurrent === void 0) {
    concurrent = Infinity;
  }
  return mergeMap(identity, concurrent);
}

// node_modules/rxjs/dist/esm5/internal/operators/concatAll.js
function concatAll() {
  return mergeAll(1);
}

// node_modules/rxjs/dist/esm5/internal/observable/concat.js
function concat() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  return concatAll()(from(args, popScheduler(args)));
}

// node_modules/rxjs/dist/esm5/internal/observable/defer.js
function defer(observableFactory) {
  return new Observable(function(subscriber) {
    innerFrom(observableFactory()).subscribe(subscriber);
  });
}

// node_modules/rxjs/dist/esm5/internal/observable/forkJoin.js
function forkJoin() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  var resultSelector = popResultSelector(args);
  var _a = argsArgArrayOrObject(args), sources = _a.args, keys = _a.keys;
  var result = new Observable(function(subscriber) {
    var length = sources.length;
    if (!length) {
      subscriber.complete();
      return;
    }
    var values = new Array(length);
    var remainingCompletions = length;
    var remainingEmissions = length;
    var _loop_1 = function(sourceIndex2) {
      var hasValue = false;
      innerFrom(sources[sourceIndex2]).subscribe(createOperatorSubscriber(subscriber, function(value) {
        if (!hasValue) {
          hasValue = true;
          remainingEmissions--;
        }
        values[sourceIndex2] = value;
      }, function() {
        return remainingCompletions--;
      }, void 0, function() {
        if (!remainingCompletions || !hasValue) {
          if (!remainingEmissions) {
            subscriber.next(keys ? createObject(keys, values) : values);
          }
          subscriber.complete();
        }
      }));
    };
    for (var sourceIndex = 0; sourceIndex < length; sourceIndex++) {
      _loop_1(sourceIndex);
    }
  });
  return resultSelector ? result.pipe(mapOneOrManyArgs(resultSelector)) : result;
}

// node_modules/rxjs/dist/esm5/internal/observable/fromEvent.js
var nodeEventEmitterMethods = ["addListener", "removeListener"];
var eventTargetMethods = ["addEventListener", "removeEventListener"];
var jqueryMethods = ["on", "off"];
function fromEvent(target, eventName, options, resultSelector) {
  if (isFunction2(options)) {
    resultSelector = options;
    options = void 0;
  }
  if (resultSelector) {
    return fromEvent(target, eventName, options).pipe(mapOneOrManyArgs(resultSelector));
  }
  var _a = __read(isEventTarget(target) ? eventTargetMethods.map(function(methodName) {
    return function(handler) {
      return target[methodName](eventName, handler, options);
    };
  }) : isNodeStyleEventEmitter(target) ? nodeEventEmitterMethods.map(toCommonHandlerRegistry(target, eventName)) : isJQueryStyleEventEmitter(target) ? jqueryMethods.map(toCommonHandlerRegistry(target, eventName)) : [], 2), add = _a[0], remove = _a[1];
  if (!add) {
    if (isArrayLike(target)) {
      return mergeMap(function(subTarget) {
        return fromEvent(subTarget, eventName, options);
      })(innerFrom(target));
    }
  }
  if (!add) {
    throw new TypeError("Invalid event target");
  }
  return new Observable(function(subscriber) {
    var handler = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return subscriber.next(1 < args.length ? args : args[0]);
    };
    add(handler);
    return function() {
      return remove(handler);
    };
  });
}
function toCommonHandlerRegistry(target, eventName) {
  return function(methodName) {
    return function(handler) {
      return target[methodName](eventName, handler);
    };
  };
}
function isNodeStyleEventEmitter(target) {
  return isFunction2(target.addListener) && isFunction2(target.removeListener);
}
function isJQueryStyleEventEmitter(target) {
  return isFunction2(target.on) && isFunction2(target.off);
}
function isEventTarget(target) {
  return isFunction2(target.addEventListener) && isFunction2(target.removeEventListener);
}

// node_modules/rxjs/dist/esm5/internal/observable/timer.js
function timer(dueTime, intervalOrScheduler, scheduler) {
  if (dueTime === void 0) {
    dueTime = 0;
  }
  if (scheduler === void 0) {
    scheduler = async;
  }
  var intervalDuration = -1;
  if (intervalOrScheduler != null) {
    if (isScheduler(intervalOrScheduler)) {
      scheduler = intervalOrScheduler;
    } else {
      intervalDuration = intervalOrScheduler;
    }
  }
  return new Observable(function(subscriber) {
    var due = isValidDate(dueTime) ? +dueTime - scheduler.now() : dueTime;
    if (due < 0) {
      due = 0;
    }
    var n2 = 0;
    return scheduler.schedule(function() {
      if (!subscriber.closed) {
        subscriber.next(n2++);
        if (0 <= intervalDuration) {
          this.schedule(void 0, intervalDuration);
        } else {
          subscriber.complete();
        }
      }
    }, due);
  });
}

// node_modules/rxjs/dist/esm5/internal/observable/merge.js
function merge() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  var scheduler = popScheduler(args);
  var concurrent = popNumber(args, Infinity);
  var sources = args;
  return !sources.length ? EMPTY : sources.length === 1 ? innerFrom(sources[0]) : mergeAll(concurrent)(from(sources, scheduler));
}

// node_modules/rxjs/dist/esm5/internal/observable/never.js
var NEVER = new Observable(noop);

// node_modules/rxjs/dist/esm5/internal/util/argsOrArgArray.js
var isArray3 = Array.isArray;
function argsOrArgArray(args) {
  return args.length === 1 && isArray3(args[0]) ? args[0] : args;
}

// node_modules/rxjs/dist/esm5/internal/operators/filter.js
function filter(predicate, thisArg) {
  return operate(function(source, subscriber) {
    var index = 0;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      return predicate.call(thisArg, value, index++) && subscriber.next(value);
    }));
  });
}

// node_modules/rxjs/dist/esm5/internal/observable/race.js
function raceInit(sources) {
  return function(subscriber) {
    var subscriptions = [];
    var _loop_1 = function(i2) {
      subscriptions.push(innerFrom(sources[i2]).subscribe(createOperatorSubscriber(subscriber, function(value) {
        if (subscriptions) {
          for (var s2 = 0; s2 < subscriptions.length; s2++) {
            s2 !== i2 && subscriptions[s2].unsubscribe();
          }
          subscriptions = null;
        }
        subscriber.next(value);
      })));
    };
    for (var i = 0; subscriptions && !subscriber.closed && i < sources.length; i++) {
      _loop_1(i);
    }
  };
}

// node_modules/rxjs/dist/esm5/internal/operators/buffer.js
function buffer(closingNotifier) {
  return operate(function(source, subscriber) {
    var currentBuffer = [];
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      return currentBuffer.push(value);
    }, function() {
      subscriber.next(currentBuffer);
      subscriber.complete();
    }));
    innerFrom(closingNotifier).subscribe(createOperatorSubscriber(subscriber, function() {
      var b2 = currentBuffer;
      currentBuffer = [];
      subscriber.next(b2);
    }, noop));
    return function() {
      currentBuffer = null;
    };
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/catchError.js
function catchError(selector) {
  return operate(function(source, subscriber) {
    var innerSub = null;
    var syncUnsub = false;
    var handledResult;
    innerSub = source.subscribe(createOperatorSubscriber(subscriber, void 0, void 0, function(err) {
      handledResult = innerFrom(selector(err, catchError(selector)(source)));
      if (innerSub) {
        innerSub.unsubscribe();
        innerSub = null;
        handledResult.subscribe(subscriber);
      } else {
        syncUnsub = true;
      }
    }));
    if (syncUnsub) {
      innerSub.unsubscribe();
      innerSub = null;
      handledResult.subscribe(subscriber);
    }
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/scanInternals.js
function scanInternals(accumulator, seed, hasSeed, emitOnNext, emitBeforeComplete) {
  return function(source, subscriber) {
    var hasState = hasSeed;
    var state = seed;
    var index = 0;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      var i = index++;
      state = hasState ? accumulator(state, value, i) : (hasState = true, value);
      emitOnNext && subscriber.next(state);
    }, emitBeforeComplete && function() {
      hasState && subscriber.next(state);
      subscriber.complete();
    }));
  };
}

// node_modules/rxjs/dist/esm5/internal/operators/combineLatest.js
function combineLatest2() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  var resultSelector = popResultSelector(args);
  return resultSelector ? pipe(combineLatest2.apply(void 0, __spreadArray([], __read(args))), mapOneOrManyArgs(resultSelector)) : operate(function(source, subscriber) {
    combineLatestInit(__spreadArray([source], __read(argsOrArgArray(args))))(subscriber);
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/combineLatestWith.js
function combineLatestWith() {
  var otherSources = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    otherSources[_i] = arguments[_i];
  }
  return combineLatest2.apply(void 0, __spreadArray([], __read(otherSources)));
}

// node_modules/rxjs/dist/esm5/internal/operators/debounceTime.js
function debounceTime(dueTime, scheduler) {
  if (scheduler === void 0) {
    scheduler = asyncScheduler;
  }
  return operate(function(source, subscriber) {
    var activeTask = null;
    var lastValue = null;
    var lastTime = null;
    var emit = function() {
      if (activeTask) {
        activeTask.unsubscribe();
        activeTask = null;
        var value = lastValue;
        lastValue = null;
        subscriber.next(value);
      }
    };
    function emitWhenIdle() {
      var targetTime = lastTime + dueTime;
      var now = scheduler.now();
      if (now < targetTime) {
        activeTask = this.schedule(void 0, targetTime - now);
        subscriber.add(activeTask);
        return;
      }
      emit();
    }
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      lastValue = value;
      lastTime = scheduler.now();
      if (!activeTask) {
        activeTask = scheduler.schedule(emitWhenIdle, dueTime);
        subscriber.add(activeTask);
      }
    }, function() {
      emit();
      subscriber.complete();
    }, void 0, function() {
      lastValue = activeTask = null;
    }));
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/take.js
function take(count2) {
  return count2 <= 0 ? function() {
    return EMPTY;
  } : operate(function(source, subscriber) {
    var seen = 0;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      if (++seen <= count2) {
        subscriber.next(value);
        if (count2 <= seen) {
          subscriber.complete();
        }
      }
    }));
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/exhaustMap.js
function exhaustMap(project, resultSelector) {
  if (resultSelector) {
    return function(source) {
      return source.pipe(exhaustMap(function(a2, i) {
        return innerFrom(project(a2, i)).pipe(map(function(b2, ii) {
          return resultSelector(a2, b2, i, ii);
        }));
      }));
    };
  }
  return operate(function(source, subscriber) {
    var index = 0;
    var innerSub = null;
    var isComplete = false;
    source.subscribe(createOperatorSubscriber(subscriber, function(outerValue) {
      if (!innerSub) {
        innerSub = createOperatorSubscriber(subscriber, void 0, function() {
          innerSub = null;
          isComplete && subscriber.complete();
        });
        innerFrom(project(outerValue, index++)).subscribe(innerSub);
      }
    }, function() {
      isComplete = true;
      !innerSub && subscriber.complete();
    }));
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/finalize.js
function finalize(callback) {
  return operate(function(source, subscriber) {
    try {
      source.subscribe(subscriber);
    } finally {
      subscriber.add(callback);
    }
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/raceWith.js
function raceWith() {
  var otherSources = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    otherSources[_i] = arguments[_i];
  }
  return !otherSources.length ? identity : operate(function(source, subscriber) {
    raceInit(__spreadArray([source], __read(otherSources)))(subscriber);
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/retry.js
function retry(configOrCount) {
  if (configOrCount === void 0) {
    configOrCount = Infinity;
  }
  var config2;
  if (configOrCount && typeof configOrCount === "object") {
    config2 = configOrCount;
  } else {
    config2 = {
      count: configOrCount
    };
  }
  var _a = config2.count, count2 = _a === void 0 ? Infinity : _a, delay3 = config2.delay, _b = config2.resetOnSuccess, resetOnSuccess = _b === void 0 ? false : _b;
  return count2 <= 0 ? identity : operate(function(source, subscriber) {
    var soFar = 0;
    var innerSub;
    var subscribeForRetry = function() {
      var syncUnsub = false;
      innerSub = source.subscribe(createOperatorSubscriber(subscriber, function(value) {
        if (resetOnSuccess) {
          soFar = 0;
        }
        subscriber.next(value);
      }, void 0, function(err) {
        if (soFar++ < count2) {
          var resub_1 = function() {
            if (innerSub) {
              innerSub.unsubscribe();
              innerSub = null;
              subscribeForRetry();
            } else {
              syncUnsub = true;
            }
          };
          if (delay3 != null) {
            var notifier = typeof delay3 === "number" ? timer(delay3) : innerFrom(delay3(err, soFar));
            var notifierSubscriber_1 = createOperatorSubscriber(subscriber, function() {
              notifierSubscriber_1.unsubscribe();
              resub_1();
            }, function() {
              subscriber.complete();
            });
            notifier.subscribe(notifierSubscriber_1);
          } else {
            resub_1();
          }
        } else {
          subscriber.error(err);
        }
      }));
      if (syncUnsub) {
        innerSub.unsubscribe();
        innerSub = null;
        subscribeForRetry();
      }
    };
    subscribeForRetry();
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/scan.js
function scan(accumulator, seed) {
  return operate(scanInternals(accumulator, seed, arguments.length >= 2, true));
}

// node_modules/rxjs/dist/esm5/internal/operators/share.js
function share(options) {
  if (options === void 0) {
    options = {};
  }
  var _a = options.connector, connector = _a === void 0 ? function() {
    return new Subject();
  } : _a, _b = options.resetOnError, resetOnError = _b === void 0 ? true : _b, _c = options.resetOnComplete, resetOnComplete = _c === void 0 ? true : _c, _d = options.resetOnRefCountZero, resetOnRefCountZero = _d === void 0 ? true : _d;
  return function(wrapperSource) {
    var connection;
    var resetConnection;
    var subject;
    var refCount2 = 0;
    var hasCompleted = false;
    var hasErrored = false;
    var cancelReset = function() {
      resetConnection === null || resetConnection === void 0 ? void 0 : resetConnection.unsubscribe();
      resetConnection = void 0;
    };
    var reset = function() {
      cancelReset();
      connection = subject = void 0;
      hasCompleted = hasErrored = false;
    };
    var resetAndUnsubscribe = function() {
      var conn = connection;
      reset();
      conn === null || conn === void 0 ? void 0 : conn.unsubscribe();
    };
    return operate(function(source, subscriber) {
      refCount2++;
      if (!hasErrored && !hasCompleted) {
        cancelReset();
      }
      var dest = subject = subject !== null && subject !== void 0 ? subject : connector();
      subscriber.add(function() {
        refCount2--;
        if (refCount2 === 0 && !hasErrored && !hasCompleted) {
          resetConnection = handleReset(resetAndUnsubscribe, resetOnRefCountZero);
        }
      });
      dest.subscribe(subscriber);
      if (!connection && refCount2 > 0) {
        connection = new SafeSubscriber({
          next: function(value) {
            return dest.next(value);
          },
          error: function(err) {
            hasErrored = true;
            cancelReset();
            resetConnection = handleReset(reset, resetOnError, err);
            dest.error(err);
          },
          complete: function() {
            hasCompleted = true;
            cancelReset();
            resetConnection = handleReset(reset, resetOnComplete);
            dest.complete();
          }
        });
        innerFrom(source).subscribe(connection);
      }
    })(wrapperSource);
  };
}
function handleReset(reset, on) {
  var args = [];
  for (var _i = 2; _i < arguments.length; _i++) {
    args[_i - 2] = arguments[_i];
  }
  if (on === true) {
    reset();
    return;
  }
  if (on === false) {
    return;
  }
  var onSubscriber = new SafeSubscriber({
    next: function() {
      onSubscriber.unsubscribe();
      reset();
    }
  });
  return innerFrom(on.apply(void 0, __spreadArray([], __read(args)))).subscribe(onSubscriber);
}

// node_modules/rxjs/dist/esm5/internal/operators/shareReplay.js
function shareReplay(configOrBufferSize, windowTime2, scheduler) {
  var _a, _b, _c;
  var bufferSize;
  var refCount2 = false;
  if (configOrBufferSize && typeof configOrBufferSize === "object") {
    _a = configOrBufferSize.bufferSize, bufferSize = _a === void 0 ? Infinity : _a, _b = configOrBufferSize.windowTime, windowTime2 = _b === void 0 ? Infinity : _b, _c = configOrBufferSize.refCount, refCount2 = _c === void 0 ? false : _c, scheduler = configOrBufferSize.scheduler;
  } else {
    bufferSize = configOrBufferSize !== null && configOrBufferSize !== void 0 ? configOrBufferSize : Infinity;
  }
  return share({
    connector: function() {
      return new ReplaySubject(bufferSize, windowTime2, scheduler);
    },
    resetOnError: true,
    resetOnComplete: false,
    resetOnRefCountZero: refCount2
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/startWith.js
function startWith() {
  var values = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    values[_i] = arguments[_i];
  }
  var scheduler = popScheduler(values);
  return operate(function(source, subscriber) {
    (scheduler ? concat(values, source, scheduler) : concat(values, source)).subscribe(subscriber);
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/switchMap.js
function switchMap(project, resultSelector) {
  return operate(function(source, subscriber) {
    var innerSubscriber = null;
    var index = 0;
    var isComplete = false;
    var checkComplete = function() {
      return isComplete && !innerSubscriber && subscriber.complete();
    };
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      innerSubscriber === null || innerSubscriber === void 0 ? void 0 : innerSubscriber.unsubscribe();
      var innerIndex = 0;
      var outerIndex = index++;
      innerFrom(project(value, outerIndex)).subscribe(innerSubscriber = createOperatorSubscriber(subscriber, function(innerValue) {
        return subscriber.next(resultSelector ? resultSelector(value, innerValue, outerIndex, innerIndex++) : innerValue);
      }, function() {
        innerSubscriber = null;
        checkComplete();
      }));
    }, function() {
      isComplete = true;
      checkComplete();
    }));
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/takeUntil.js
function takeUntil(notifier) {
  return operate(function(source, subscriber) {
    innerFrom(notifier).subscribe(createOperatorSubscriber(subscriber, function() {
      return subscriber.complete();
    }, noop));
    !subscriber.closed && source.subscribe(subscriber);
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/tap.js
function tap(observerOrNext, error, complete) {
  var tapObserver = isFunction2(observerOrNext) || error || complete ? { next: observerOrNext, error, complete } : observerOrNext;
  return tapObserver ? operate(function(source, subscriber) {
    var _a;
    (_a = tapObserver.subscribe) === null || _a === void 0 ? void 0 : _a.call(tapObserver);
    var isUnsub = true;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      var _a2;
      (_a2 = tapObserver.next) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver, value);
      subscriber.next(value);
    }, function() {
      var _a2;
      isUnsub = false;
      (_a2 = tapObserver.complete) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver);
      subscriber.complete();
    }, function(err) {
      var _a2;
      isUnsub = false;
      (_a2 = tapObserver.error) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver, err);
      subscriber.error(err);
    }, function() {
      var _a2, _b;
      if (isUnsub) {
        (_a2 = tapObserver.unsubscribe) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver);
      }
      (_b = tapObserver.finalize) === null || _b === void 0 ? void 0 : _b.call(tapObserver);
    }));
  }) : identity;
}

// node_modules/rxjs/dist/esm5/internal/operators/withLatestFrom.js
function withLatestFrom() {
  var inputs = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    inputs[_i] = arguments[_i];
  }
  var project = popResultSelector(inputs);
  return operate(function(source, subscriber) {
    var len = inputs.length;
    var otherValues = new Array(len);
    var hasValue = inputs.map(function() {
      return false;
    });
    var ready = false;
    var _loop_1 = function(i2) {
      innerFrom(inputs[i2]).subscribe(createOperatorSubscriber(subscriber, function(value) {
        otherValues[i2] = value;
        if (!ready && !hasValue[i2]) {
          hasValue[i2] = true;
          (ready = hasValue.every(identity)) && (hasValue = null);
        }
      }, noop));
    };
    for (var i = 0; i < len; i++) {
      _loop_1(i);
    }
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      if (ready) {
        var values = __spreadArray([value], __read(otherValues));
        subscriber.next(project ? project.apply(void 0, __spreadArray([], __read(values))) : values);
      }
    }));
  });
}

// node_modules/@snap/camera-kit/dist/common/entries.js
var entries = (o) => Object.entries(o);
var fromEntries = (entries2) => Object.fromEntries(entries2);

// node_modules/@snap/camera-kit/dist/logger/logger.js
var logEntriesSubject = new Subject();
var logLevelMap = {
  error: 3,
  warn: 2,
  log: 1,
  info: 1,
  debug: 0
};
function resetLogger() {
  return logEntriesSubject = new Subject();
}
function getLogger(module2) {
  return entries(logLevelMap).reduce((logger25, [level]) => {
    logger25[level] = (...messages) => {
      logEntriesSubject.next({
        time: /* @__PURE__ */ new Date(),
        module: module2,
        level,
        messages
      });
    };
    return logger25;
  }, {});
}

// node_modules/@snap/camera-kit/dist/handlers/retryingHandler.js
var logger = getLogger("retryingHandler");
var logRetry = (responseOrError, sleep3) => {
  logger.warn(`Retrying handler got failed response:`, responseOrError, `Waited ${sleep3} millis, attempting retry now.`);
};
var sleep = (millis) => new Promise((resolve) => setTimeout(resolve, millis));
var randomInRange = (min2, max2) => Math.round(Math.random() * (max2 - min2) + min2);
var defaultOptions = {
  backoffMultiple: 3,
  baseSleep: 500,
  maxSleep: 5 * 1e3,
  maxRetries: 10,
  retryPredicate: (responseOrError) => responseOrError instanceof Response ? !responseOrError.ok : true
};
function ensureClonedRequest(input) {
  return input instanceof Request ? input.clone() : input;
}
var createRetryingHandler = (options = {}) => {
  const definedOptions = copyDefinedProperties(options);
  const { backoffMultiple, baseSleep, maxSleep, maxRetries, retryPredicate } = Object.assign(Object.assign({}, defaultOptions), definedOptions);
  let retryCount = -1;
  const jitterSleep = (priorSleep) => __awaiter(void 0, void 0, void 0, function* () {
    const nextSleep = Math.min(maxSleep, randomInRange(baseSleep, priorSleep * backoffMultiple));
    yield sleep(nextSleep);
    return nextSleep;
  });
  const makeRequestAttempt = (next, priorSleep = baseSleep) => (req, metadata) => __awaiter(void 0, void 0, void 0, function* () {
    var _a, _b;
    retryCount++;
    try {
      const response = yield next(ensureClonedRequest(req), metadata);
      if (retryCount < maxRetries && retryPredicate(response, retryCount)) {
        const nextSleep = yield jitterSleep(priorSleep);
        if ((_a = metadata === null || metadata === void 0 ? void 0 : metadata.signal) === null || _a === void 0 ? void 0 : _a.aborted)
          return response;
        logRetry(response, nextSleep);
        return makeRequestAttempt(next, nextSleep)(req, metadata);
      }
      return response;
    } catch (error) {
      if (!(error instanceof Error)) {
        throw new Error(`Invalid type caught by retrying handler. Handlers may only throw Errors. Got ${JSON.stringify(error)}`);
      }
      if (error.name === "AbortError")
        throw error;
      if (retryCount < maxRetries && retryPredicate(error, retryCount)) {
        const nextSleep = yield jitterSleep(priorSleep);
        if ((_b = metadata === null || metadata === void 0 ? void 0 : metadata.signal) === null || _b === void 0 ? void 0 : _b.aborted)
          throw error;
        logRetry(error, nextSleep);
        return makeRequestAttempt(next, nextSleep)(req, metadata);
      }
      throw error;
    }
  });
  return (next) => makeRequestAttempt(next);
};

// node_modules/@snap/camera-kit/dist/handlers/noCorsRetryingFetchHandler.js
var logger2 = getLogger("noCorsRetryingFetchHandler");
var logRetry2 = (error) => {
  logger2.warn(`NoCorsRetrying handler got failed response:`, error, `Retrying request with {mode: "no-cors"}.`);
};
var createNoCorsRetryingFetchHandler = () => {
  const noCorsRequests = /* @__PURE__ */ new Map();
  return (next) => (input, init = {}) => __awaiter(void 0, void 0, void 0, function* () {
    var _a;
    let requestKey = typeof input === "string" ? input : input.url;
    try {
      requestKey = new URL(requestKey, location.origin).host;
    } catch (_) {
    }
    try {
      return yield next(ensureClonedRequest(input), init);
    } catch (error) {
      if (error instanceof Error && error.name === "AbortError")
        throw error;
      logRetry2(error);
      const noCorsRequest = (_a = noCorsRequests.get(requestKey)) !== null && _a !== void 0 ? _a : next(ensureClonedRequest(input), Object.assign(Object.assign({}, init), { mode: "no-cors" }));
      noCorsRequests.set(requestKey, noCorsRequest);
      yield noCorsRequest;
      noCorsRequests.delete(requestKey);
      return next(ensureClonedRequest(input), init);
    }
  });
};

// node_modules/@snap/camera-kit/dist/handlers/timeoutHandler.js
var sleep2 = (millis) => new Promise((resolve) => setTimeout(resolve, millis));
var defaultOptions2 = {
  createError: (request) => {
    const destination = isString(request) ? `for ${request}` : request instanceof Request ? `for ${request.url}` : "";
    return new Error(`Request ${destination} timed out by client timeout handler.`);
  },
  timeout: 30 * 1e3
};
var createTimeoutHandler = (options = {}) => {
  const definedOptions = copyDefinedProperties(options);
  const { createError, timeout: timeout2 } = Object.assign(Object.assign({}, defaultOptions2), definedOptions);
  return (next) => (req, meta) => Promise.race([next(req, meta), sleep2(timeout2).then(() => Promise.reject(createError(req, meta)))]);
};

// node_modules/@snap/camera-kit/dist/handlers/defaultFetchHandler.js
var defaultFetchHandlerFactory = Injectable("defaultFetchHandler", () => {
  return new HandlerChainBuilder(fetch).map(createTimeoutHandler({ timeout: 20 * 1e3 })).map(createNoCorsRetryingFetchHandler()).map(createRetryingHandler({
    maxRetries: 3,
    retryPredicate: (responseOrError) => {
      if (responseOrError instanceof Response) {
        if (responseOrError.ok)
          return false;
        if (responseOrError.status % 400 < 100)
          return false;
      }
      return true;
    }
  })).handler;
});

// node_modules/@snap/camera-kit/dist/common/errorHelpers.js
function stringifyError(error) {
  var _a;
  const outer = (_a = error.stack) !== null && _a !== void 0 ? _a : "";
  return error.cause ? `${outer}
Caused by:
	${stringifyError(ensureError(error.cause))}` : outer;
}
function stringifyErrorMessage(error) {
  const cause = error.cause ? `; Caused by ${stringifyErrorMessage(ensureError(error.cause))}` : "";
  return `${error.name}: ${error.message}${cause}`;
}
function ensureError(error) {
  if (error instanceof Error)
    return error;
  try {
    return new Error(`Non-Error type exception thrown. Serialized error value: ${JSON.stringify(error)}`);
  } catch (_) {
    return new Error("Non-Error type exception thrown. Original error value could not be serialized.");
  }
}

// node_modules/@snap/camera-kit/dist/events/TypedCustomEvent.js
var TypedCustomEvent = class extends CustomEvent {
  constructor(type, detail, eventInitDict = {}) {
    super(type, Object.assign(Object.assign({}, eventInitDict), { detail }));
  }
};

// node_modules/@snap/camera-kit/dist/events/TypedEventTarget.js
var TypedEventTarget = class {
  constructor() {
    this.listeners = /* @__PURE__ */ new Map();
    this.options = /* @__PURE__ */ new Map();
  }
  addEventListener(type, callback, options) {
    var _a;
    const listener = callback;
    const listeners = (_a = this.listeners.get(type)) !== null && _a !== void 0 ? _a : [];
    this.listeners.set(type, [...listeners, listener]);
    if (options)
      this.options.set(listener, options);
  }
  dispatchEvent(event) {
    const listeners = this.listeners.get(event.type);
    if (!listeners)
      return true;
    listeners.forEach((listener) => {
      var _a;
      const options = (_a = this.options.get(listener)) !== null && _a !== void 0 ? _a : {};
      try {
        listener(event);
      } catch (error) {
        if (window)
          window.dispatchEvent(new CustomEvent("error", { detail: error }));
      }
      if (options.once)
        this.removeEventListener(event.type, listener);
    });
    return true;
  }
  removeEventListener(type, callback) {
    const listener = callback;
    const listeners = this.listeners.get(type);
    if (!listeners)
      return;
    this.listeners.set(type, listeners.filter((l2) => l2 !== listener));
    this.options.delete(listener);
  }
};

// node_modules/@snap/camera-kit/dist/common/time.js
var getTimeMs = () => performance.now();
var convertDaysToSeconds = (days) => days * 24 * 60 * 60;

// node_modules/@snap/camera-kit/dist/metrics/operational/Metric.js
var nameDelimiter = "_";
var dimensionDelimiter = ".";
var delimiterRegex = new RegExp(`^${nameDelimiter}+|${nameDelimiter}+$`, "g");
var Metric = class {
  constructor(name, dimensions = {}) {
    this.name = name;
    this.dimensions = dimensions;
  }
  child(constructor, name, dimensions = {}) {
    return new constructor(`${this.name}${nameDelimiter}${name}`, dimensions);
  }
};
function joinMetricNames(names) {
  return names.join(nameDelimiter).replace(delimiterRegex, "");
}
function serializeMetricDimensions(dimensions) {
  if (Object.keys(dimensions).length === 0)
    return "";
  return `${dimensionDelimiter}${Array.from(Object.entries(dimensions)).map((d2) => d2.join(dimensionDelimiter)).join(dimensionDelimiter)}`;
}

// node_modules/@snap/camera-kit/dist/metrics/operational/Timer.js
var Timer = class _Timer extends Metric {
  constructor(name, dimensions = {}) {
    super(name, dimensions);
    this.name = name;
    this.startTime = getTimeMs();
    this.stopped = false;
    this.marks = /* @__PURE__ */ new Set();
    this.measures = /* @__PURE__ */ new Set();
  }
  getMeasures() {
    return Array.from(this.measures.values()).concat(...Array.from(this.marks.values()).map((mark) => mark.getMeasures()));
  }
  mark(name, dimensions = {}) {
    const mark = new _Timer(joinMetricNames([this.name, name]), dimensions);
    if (this.stopped)
      mark.stop();
    this.marks.add(mark);
    return mark;
  }
  measure(nameOrDimensions, maybeDimensions) {
    if (this.stopped)
      return void 0;
    const name = typeof nameOrDimensions === "string" ? nameOrDimensions : "";
    const dimensions = typeof nameOrDimensions === "string" ? maybeDimensions : nameOrDimensions;
    const fullName = joinMetricNames([this.name, name]);
    const measure = {
      name: fullName,
      duration: getTimeMs() - this.startTime,
      dimensions: dimensions !== null && dimensions !== void 0 ? dimensions : this.dimensions
    };
    this.measures.add(measure);
    return measure;
  }
  clear() {
    this.measures.clear();
    this.marks.forEach((mark) => mark.clear());
  }
  stop() {
    this.stopped = true;
    this.marks.forEach((mark) => mark.stop());
  }
  stopAndReport(client) {
    return __awaiter(this, void 0, void 0, function* () {
      client.setOperationalMetrics(this);
      this.stop();
      this.clear();
    });
  }
  toOperationalMetric() {
    const timestamp2 = /* @__PURE__ */ new Date();
    return this.getMeasures().map((measure) => ({
      name: `${measure.name}${serializeMetricDimensions(measure.dimensions)}`,
      timestamp: timestamp2,
      metric: {
        $case: "latencyMillis",
        latencyMillis: `${Math.ceil(measure.duration)}`
      }
    }));
  }
};

// node_modules/@snap/camera-kit/dist/handlers/requestStateEmittingHandler.js
var requestId = 0;
var safeParseInt = (str) => {
  if (str == null)
    return 0;
  const maybeInt = parseInt(str);
  return isNaN(maybeInt) ? 0 : maybeInt;
};
var dispatchRequestStarted = (requestStateEventTarget, data) => {
  const started = Object.assign(Object.assign({}, data), { requestId: requestId++, timer: new Timer("download_latency") });
  requestStateEventTarget.dispatchEvent(new TypedCustomEvent("started", started));
  return started;
};
var dispatchRequestCompleted = (requestStateEventTarget, data) => {
  requestStateEventTarget.dispatchEvent(new TypedCustomEvent("completed", data));
  return data;
};
var dispatchRequestErrored = (requestStateEventTarget, data) => {
  requestStateEventTarget.dispatchEvent(new TypedCustomEvent("errored", data));
  return data;
};
var createRequestStateEmittingHandler = (requestStateEventTarget) => (next) => ([request, dimensions], metadata) => __awaiter(void 0, void 0, void 0, function* () {
  const { requestId: requestId2 } = dispatchRequestStarted(requestStateEventTarget, { dimensions });
  try {
    const response = yield next(request, metadata);
    const status = response.status;
    const sizeByte = safeParseInt(response.headers.get("content-length"));
    dispatchRequestCompleted(requestStateEventTarget, { requestId: requestId2, dimensions, status, sizeByte });
    return response;
  } catch (error) {
    dispatchRequestErrored(requestStateEventTarget, { requestId: requestId2, dimensions, error: ensureError(error) });
    throw error;
  }
});
var requestStateEventTargetFactory = Injectable("requestStateEventTarget", () => new TypedEventTarget());

// node_modules/@snap/camera-kit/dist/handlers/arrayBufferParsingHandler.js
var createArrayBufferParsingHandler = () => (next) => (req, metadata) => __awaiter(void 0, void 0, void 0, function* () {
  const response = yield next(req, metadata);
  let buffer2;
  try {
    buffer2 = yield response.arrayBuffer();
  } catch (_) {
    buffer2 = new ArrayBuffer(0);
  }
  return [buffer2, response];
});

// node_modules/@snap/camera-kit/dist/generated-proto/pb_schema/camera_kit/v3/lens.js
var import_long2 = __toESM(require_long());
var import_minimal2 = __toESM(require_minimal2());

// node_modules/@snap/camera-kit/dist/generated-proto/pb_schema/google/protobuf/any.js
var import_long = __toESM(require_long());
var import_minimal = __toESM(require_minimal2());
function createBaseAny() {
  return { typeUrl: "", value: new Uint8Array() };
}
var Any = {
  encode(message, writer = import_minimal.default.Writer.create()) {
    if (message.typeUrl !== "") {
      writer.uint32(10).string(message.typeUrl);
    }
    if (message.value.length !== 0) {
      writer.uint32(18).bytes(message.value);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal.default.Reader ? input : new import_minimal.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAny();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.typeUrl = reader.string();
          break;
        case 2:
          message.value = reader.bytes();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(object) {
    var _a, _b;
    const message = createBaseAny();
    message.typeUrl = (_a = object.typeUrl) !== null && _a !== void 0 ? _a : "";
    message.value = (_b = object.value) !== null && _b !== void 0 ? _b : new Uint8Array();
    return message;
  }
};
if (import_minimal.default.util.Long !== import_long.default) {
  import_minimal.default.util.Long = import_long.default;
  import_minimal.default.configure();
}

// node_modules/@snap/camera-kit/dist/generated-proto/pb_schema/camera_kit/v3/lens.js
var Lens_CameraFacing;
(function(Lens_CameraFacing2) {
  Lens_CameraFacing2[Lens_CameraFacing2["CAMERA_FACING_UNSET"] = 0] = "CAMERA_FACING_UNSET";
  Lens_CameraFacing2[Lens_CameraFacing2["CAMERA_FACING_FRONT"] = 1] = "CAMERA_FACING_FRONT";
  Lens_CameraFacing2[Lens_CameraFacing2["CAMERA_FACING_BACK"] = 2] = "CAMERA_FACING_BACK";
  Lens_CameraFacing2[Lens_CameraFacing2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(Lens_CameraFacing || (Lens_CameraFacing = {}));
var LensAssetManifestItem_Type;
(function(LensAssetManifestItem_Type2) {
  LensAssetManifestItem_Type2[LensAssetManifestItem_Type2["DEVICE_DEPENDENT_ASSET_UNSET"] = 0] = "DEVICE_DEPENDENT_ASSET_UNSET";
  LensAssetManifestItem_Type2[LensAssetManifestItem_Type2["ASSET"] = 1] = "ASSET";
  LensAssetManifestItem_Type2[LensAssetManifestItem_Type2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(LensAssetManifestItem_Type || (LensAssetManifestItem_Type = {}));
var LensAssetManifestItem_RequestTiming;
(function(LensAssetManifestItem_RequestTiming2) {
  LensAssetManifestItem_RequestTiming2[LensAssetManifestItem_RequestTiming2["PRELOAD_UNSET"] = 0] = "PRELOAD_UNSET";
  LensAssetManifestItem_RequestTiming2[LensAssetManifestItem_RequestTiming2["ON_DEMAND"] = 1] = "ON_DEMAND";
  LensAssetManifestItem_RequestTiming2[LensAssetManifestItem_RequestTiming2["REQUIRED"] = 2] = "REQUIRED";
  LensAssetManifestItem_RequestTiming2[LensAssetManifestItem_RequestTiming2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(LensAssetManifestItem_RequestTiming || (LensAssetManifestItem_RequestTiming = {}));
function createBaseLens() {
  return {
    id: "",
    name: "",
    vendorData: {},
    content: void 0,
    isThirdParty: false,
    cameraFacingPreference: 0,
    featureMetadata: [],
    lensCreator: void 0,
    scannable: void 0
  };
}
var Lens = {
  encode(message, writer = import_minimal2.default.Writer.create()) {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    Object.entries(message.vendorData).forEach(([key, value]) => {
      Lens_VendorDataEntry.encode({ key, value }, writer.uint32(26).fork()).ldelim();
    });
    if (message.content !== void 0) {
      Content.encode(message.content, writer.uint32(34).fork()).ldelim();
    }
    if (message.isThirdParty === true) {
      writer.uint32(40).bool(message.isThirdParty);
    }
    if (message.cameraFacingPreference !== 0) {
      writer.uint32(48).int32(message.cameraFacingPreference);
    }
    for (const v2 of message.featureMetadata) {
      Any.encode(v2, writer.uint32(58).fork()).ldelim();
    }
    if (message.lensCreator !== void 0) {
      LensCreator.encode(message.lensCreator, writer.uint32(66).fork()).ldelim();
    }
    if (message.scannable !== void 0) {
      Scannable.encode(message.scannable, writer.uint32(74).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal2.default.Reader ? input : new import_minimal2.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseLens();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.id = reader.string();
          break;
        case 2:
          message.name = reader.string();
          break;
        case 3:
          const entry3 = Lens_VendorDataEntry.decode(reader, reader.uint32());
          if (entry3.value !== void 0) {
            message.vendorData[entry3.key] = entry3.value;
          }
          break;
        case 4:
          message.content = Content.decode(reader, reader.uint32());
          break;
        case 5:
          message.isThirdParty = reader.bool();
          break;
        case 6:
          message.cameraFacingPreference = reader.int32();
          break;
        case 7:
          message.featureMetadata.push(Any.decode(reader, reader.uint32()));
          break;
        case 8:
          message.lensCreator = LensCreator.decode(reader, reader.uint32());
          break;
        case 9:
          message.scannable = Scannable.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(object) {
    var _a, _b, _c, _d, _e, _f;
    const message = createBaseLens();
    message.id = (_a = object.id) !== null && _a !== void 0 ? _a : "";
    message.name = (_b = object.name) !== null && _b !== void 0 ? _b : "";
    message.vendorData = Object.entries((_c = object.vendorData) !== null && _c !== void 0 ? _c : {}).reduce((acc, [key, value]) => {
      if (value !== void 0) {
        acc[key] = String(value);
      }
      return acc;
    }, {});
    message.content = object.content !== void 0 && object.content !== null ? Content.fromPartial(object.content) : void 0;
    message.isThirdParty = (_d = object.isThirdParty) !== null && _d !== void 0 ? _d : false;
    message.cameraFacingPreference = (_e = object.cameraFacingPreference) !== null && _e !== void 0 ? _e : 0;
    message.featureMetadata = ((_f = object.featureMetadata) === null || _f === void 0 ? void 0 : _f.map((e2) => Any.fromPartial(e2))) || [];
    message.lensCreator = object.lensCreator !== void 0 && object.lensCreator !== null ? LensCreator.fromPartial(object.lensCreator) : void 0;
    message.scannable = object.scannable !== void 0 && object.scannable !== null ? Scannable.fromPartial(object.scannable) : void 0;
    return message;
  }
};
function createBaseLens_VendorDataEntry() {
  return { key: "", value: "" };
}
var Lens_VendorDataEntry = {
  encode(message, writer = import_minimal2.default.Writer.create()) {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal2.default.Reader ? input : new import_minimal2.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseLens_VendorDataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.key = reader.string();
          break;
        case 2:
          message.value = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(object) {
    var _a, _b;
    const message = createBaseLens_VendorDataEntry();
    message.key = (_a = object.key) !== null && _a !== void 0 ? _a : "";
    message.value = (_b = object.value) !== null && _b !== void 0 ? _b : "";
    return message;
  }
};
function createBaseContent() {
  return {
    lnsUrl: "",
    lnsSha256: "",
    iconUrl: "",
    preview: void 0,
    assetManifest: [],
    defaultHintId: "",
    hintTranslations: {},
    lnsUrlBolt: "",
    iconUrlBolt: ""
  };
}
var Content = {
  encode(message, writer = import_minimal2.default.Writer.create()) {
    if (message.lnsUrl !== "") {
      writer.uint32(10).string(message.lnsUrl);
    }
    if (message.lnsSha256 !== "") {
      writer.uint32(18).string(message.lnsSha256);
    }
    if (message.iconUrl !== "") {
      writer.uint32(26).string(message.iconUrl);
    }
    if (message.preview !== void 0) {
      Preview.encode(message.preview, writer.uint32(34).fork()).ldelim();
    }
    for (const v2 of message.assetManifest) {
      LensAssetManifestItem.encode(v2, writer.uint32(42).fork()).ldelim();
    }
    if (message.defaultHintId !== "") {
      writer.uint32(50).string(message.defaultHintId);
    }
    Object.entries(message.hintTranslations).forEach(([key, value]) => {
      Content_HintTranslationsEntry.encode({ key, value }, writer.uint32(58).fork()).ldelim();
    });
    if (message.lnsUrlBolt !== "") {
      writer.uint32(66).string(message.lnsUrlBolt);
    }
    if (message.iconUrlBolt !== "") {
      writer.uint32(74).string(message.iconUrlBolt);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal2.default.Reader ? input : new import_minimal2.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseContent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.lnsUrl = reader.string();
          break;
        case 2:
          message.lnsSha256 = reader.string();
          break;
        case 3:
          message.iconUrl = reader.string();
          break;
        case 4:
          message.preview = Preview.decode(reader, reader.uint32());
          break;
        case 5:
          message.assetManifest.push(LensAssetManifestItem.decode(reader, reader.uint32()));
          break;
        case 6:
          message.defaultHintId = reader.string();
          break;
        case 7:
          const entry7 = Content_HintTranslationsEntry.decode(reader, reader.uint32());
          if (entry7.value !== void 0) {
            message.hintTranslations[entry7.key] = entry7.value;
          }
          break;
        case 8:
          message.lnsUrlBolt = reader.string();
          break;
        case 9:
          message.iconUrlBolt = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(object) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    const message = createBaseContent();
    message.lnsUrl = (_a = object.lnsUrl) !== null && _a !== void 0 ? _a : "";
    message.lnsSha256 = (_b = object.lnsSha256) !== null && _b !== void 0 ? _b : "";
    message.iconUrl = (_c = object.iconUrl) !== null && _c !== void 0 ? _c : "";
    message.preview = object.preview !== void 0 && object.preview !== null ? Preview.fromPartial(object.preview) : void 0;
    message.assetManifest = ((_d = object.assetManifest) === null || _d === void 0 ? void 0 : _d.map((e2) => LensAssetManifestItem.fromPartial(e2))) || [];
    message.defaultHintId = (_e = object.defaultHintId) !== null && _e !== void 0 ? _e : "";
    message.hintTranslations = Object.entries((_f = object.hintTranslations) !== null && _f !== void 0 ? _f : {}).reduce((acc, [key, value]) => {
      if (value !== void 0) {
        acc[key] = String(value);
      }
      return acc;
    }, {});
    message.lnsUrlBolt = (_g = object.lnsUrlBolt) !== null && _g !== void 0 ? _g : "";
    message.iconUrlBolt = (_h = object.iconUrlBolt) !== null && _h !== void 0 ? _h : "";
    return message;
  }
};
function createBaseContent_HintTranslationsEntry() {
  return { key: "", value: "" };
}
var Content_HintTranslationsEntry = {
  encode(message, writer = import_minimal2.default.Writer.create()) {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal2.default.Reader ? input : new import_minimal2.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseContent_HintTranslationsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.key = reader.string();
          break;
        case 2:
          message.value = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(object) {
    var _a, _b;
    const message = createBaseContent_HintTranslationsEntry();
    message.key = (_a = object.key) !== null && _a !== void 0 ? _a : "";
    message.value = (_b = object.value) !== null && _b !== void 0 ? _b : "";
    return message;
  }
};
function createBaseLensAssetManifestItem() {
  return { type: 0, id: "", requestTiming: 0, assetUrl: "", assetChecksum: "" };
}
var LensAssetManifestItem = {
  encode(message, writer = import_minimal2.default.Writer.create()) {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.id !== "") {
      writer.uint32(18).string(message.id);
    }
    if (message.requestTiming !== 0) {
      writer.uint32(24).int32(message.requestTiming);
    }
    if (message.assetUrl !== "") {
      writer.uint32(34).string(message.assetUrl);
    }
    if (message.assetChecksum !== "") {
      writer.uint32(42).string(message.assetChecksum);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal2.default.Reader ? input : new import_minimal2.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseLensAssetManifestItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.type = reader.int32();
          break;
        case 2:
          message.id = reader.string();
          break;
        case 3:
          message.requestTiming = reader.int32();
          break;
        case 4:
          message.assetUrl = reader.string();
          break;
        case 5:
          message.assetChecksum = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(object) {
    var _a, _b, _c, _d, _e;
    const message = createBaseLensAssetManifestItem();
    message.type = (_a = object.type) !== null && _a !== void 0 ? _a : 0;
    message.id = (_b = object.id) !== null && _b !== void 0 ? _b : "";
    message.requestTiming = (_c = object.requestTiming) !== null && _c !== void 0 ? _c : 0;
    message.assetUrl = (_d = object.assetUrl) !== null && _d !== void 0 ? _d : "";
    message.assetChecksum = (_e = object.assetChecksum) !== null && _e !== void 0 ? _e : "";
    return message;
  }
};
function createBasePreview() {
  return { imageUrl: "", imageSequenceSize: 0, imageSequenceWebpUrlPattern: "" };
}
var Preview = {
  encode(message, writer = import_minimal2.default.Writer.create()) {
    if (message.imageUrl !== "") {
      writer.uint32(10).string(message.imageUrl);
    }
    if (message.imageSequenceSize !== 0) {
      writer.uint32(16).int32(message.imageSequenceSize);
    }
    if (message.imageSequenceWebpUrlPattern !== "") {
      writer.uint32(26).string(message.imageSequenceWebpUrlPattern);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal2.default.Reader ? input : new import_minimal2.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBasePreview();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.imageUrl = reader.string();
          break;
        case 2:
          message.imageSequenceSize = reader.int32();
          break;
        case 3:
          message.imageSequenceWebpUrlPattern = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(object) {
    var _a, _b, _c;
    const message = createBasePreview();
    message.imageUrl = (_a = object.imageUrl) !== null && _a !== void 0 ? _a : "";
    message.imageSequenceSize = (_b = object.imageSequenceSize) !== null && _b !== void 0 ? _b : 0;
    message.imageSequenceWebpUrlPattern = (_c = object.imageSequenceWebpUrlPattern) !== null && _c !== void 0 ? _c : "";
    return message;
  }
};
function createBaseLensCreator() {
  return { displayName: "" };
}
var LensCreator = {
  encode(message, writer = import_minimal2.default.Writer.create()) {
    if (message.displayName !== "") {
      writer.uint32(10).string(message.displayName);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal2.default.Reader ? input : new import_minimal2.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseLensCreator();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.displayName = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(object) {
    var _a;
    const message = createBaseLensCreator();
    message.displayName = (_a = object.displayName) !== null && _a !== void 0 ? _a : "";
    return message;
  }
};
function createBaseScannable() {
  return { snapcodeImageUrl: "", snapcodeDeeplink: "" };
}
var Scannable = {
  encode(message, writer = import_minimal2.default.Writer.create()) {
    if (message.snapcodeImageUrl !== "") {
      writer.uint32(10).string(message.snapcodeImageUrl);
    }
    if (message.snapcodeDeeplink !== "") {
      writer.uint32(18).string(message.snapcodeDeeplink);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal2.default.Reader ? input : new import_minimal2.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseScannable();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.snapcodeImageUrl = reader.string();
          break;
        case 2:
          message.snapcodeDeeplink = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(object) {
    var _a, _b;
    const message = createBaseScannable();
    message.snapcodeImageUrl = (_a = object.snapcodeImageUrl) !== null && _a !== void 0 ? _a : "";
    message.snapcodeDeeplink = (_b = object.snapcodeDeeplink) !== null && _b !== void 0 ? _b : "";
    return message;
  }
};
if (import_minimal2.default.util.Long !== import_long2.default) {
  import_minimal2.default.util.Long = import_long2.default;
  import_minimal2.default.configure();
}

// node_modules/@snap/camera-kit/dist/logger/errorLoggingDecorator.js
function errorLoggingDecorator(logger25) {
  const handleError = (error) => logger25.error(error);
  return function validator(target, _context) {
    return function(...args) {
      try {
        const result = target.apply(this, args);
        if (result instanceof Promise) {
          result.catch(handleError);
        }
        return result;
      } catch (error) {
        handleError(error);
        throw error;
      }
    };
  };
}

// node_modules/@snap/camera-kit/dist/handlers/utils.js
function withRequestPriority(request, lowPriority) {
  if (lowPriority) {
    return Object.assign(Object.assign({}, request), { priority: "low" });
  }
  return request;
}

// node_modules/@snap/camera-kit/dist/common/assertions.js
function assertUnreachable(_) {
  throw new Error("Reached unreachable code at runtime.");
}
function assert(condition, error = "Assertion failed") {
  if (!condition) {
    if (error instanceof Error) {
      throw error;
    } else {
      throw new Error(error);
    }
  }
}

// node_modules/@snap/camera-kit/dist/lens/Lens.js
function isLensArray(value) {
  return isArrayOfType(isLens, value);
}
function isLens(value) {
  return isRecord(value) && isString(value.id) && isString(value.name) && (isUndefined(value.iconUrl) || isString(value.iconUrl)) && isRecord(value.vendorData) && predicateRecordValues(isString)(value.vendorData) && isNumber(value.cameraFacingPreference) && (isUndefined(value.preview) || isPreview(value.preview)) && (isUndefined(value.lensCreator) || isLensCreator(value.lensCreator)) && (isUndefined(value.snapcode) || isSnapcode(value.snapcode)) && isAnyArray(value.featureMetadata);
}
function isPreview(value) {
  return isRecord(value) && isString(value.imageUrl);
}
function isLensCreator(value) {
  return isRecord(value) && isString(value.displayName);
}
function isSnapcode(value) {
  return isRecord(value) && isString(value.imageUrl) && isString(value.deepLink);
}
function isAny(value) {
  return isRecord(value) && isString(value.typeUrl) && isTypedArray(value.value);
}
function isAnyArray(value) {
  return isArrayOfType(isAny, value);
}
function toPublicLens({ id, groupId, name, content, vendorData, cameraFacingPreference, lensCreator, scannable, featureMetadata }) {
  var _a;
  assert(isEmptyOrSafeUrl(content === null || content === void 0 ? void 0 : content.iconUrlBolt), "Unsafe icon URL");
  assert(isEmptyOrSafeUrl((_a = content === null || content === void 0 ? void 0 : content.preview) === null || _a === void 0 ? void 0 : _a.imageUrl), "Unsafe preview URL");
  return {
    id,
    groupId,
    name,
    iconUrl: content === null || content === void 0 ? void 0 : content.iconUrlBolt,
    preview: (content === null || content === void 0 ? void 0 : content.preview) ? { imageUrl: content.preview.imageUrl } : void 0,
    vendorData,
    cameraFacingPreference,
    lensCreator,
    snapcode: scannable ? { imageUrl: scannable.snapcodeImageUrl, deepLink: scannable.snapcodeDeeplink } : void 0,
    featureMetadata
  };
}

// node_modules/@snap/camera-kit/dist/metrics/metricsEventTarget.js
var metricsEventTargetFactory = Injectable("metricsEventTarget", () => new TypedEventTarget());

// node_modules/@snap/camera-kit/dist/lens-core-module/lensCoreError.js
var lensCoreErrorValue = {
  LensDeserialization: 0,
  Validation: 1,
  Uncategorized: 2,
  LensExecution: 3,
  Abort: 4,
  Uninitialized: 5
};
var lensCoreErrorName = Object.fromEntries(Object.entries(lensCoreErrorValue).map((entry) => [entry[1], entry[0]]));
function wrapLensCoreError(unknownError, isFrameError) {
  var _a, _b, _c, _d, _e;
  const lcError = ensureError(unknownError);
  const error = new Error(lcError.message.split("\n")[0], {
    cause: lcError.otherExceptions || ((_a = lcError.cause) === null || _a === void 0 ? void 0 : _a.metadata) ? {
      otherExceptions: lcError.otherExceptions,
      metadata: (_b = lcError.cause) === null || _b === void 0 ? void 0 : _b.metadata
    } : void 0
  });
  const lcErrorType = (_d = (_c = lcError.cause) === null || _c === void 0 ? void 0 : _c.type) === null || _d === void 0 ? void 0 : _d.value;
  const name = `LensCore${(_e = lensCoreErrorName[lcErrorType]) !== null && _e !== void 0 ? _e : "Unknown"}Error`;
  error.name = name;
  error.isFrameError = isFrameError;
  if (lcError.stack) {
    const [_, ...stackLines] = lcError.stack.split("\n");
    if (error.stack) {
      stackLines.unshift(error.stack.split("\n")[0]);
    }
    error.stack = stackLines.join("\n");
  }
  return error;
}

// node_modules/@snap/camera-kit/dist/lens-core-module/lensCore.js
var promisifiableMethods = {
  addLens: null,
  clearAllLenses: null,
  imageToYuvBuffer: null,
  pauseCanvas: null,
  processAudioSampleBuffer: null,
  processFrame: null,
  removeLens: null,
  replaceLenses: null,
  setAudioParameters: null,
  setDeviceClass: null,
  setFPSLimit: null,
  setInputTransform: null,
  setOnFrameProcessedCallback: null,
  setRenderLoopMode: null,
  setRenderSize: null,
  teardown: null,
  useMediaElement: null,
  yuvBufferToBitmap: null
};
function createErrorWrapper(isForFrameErrors, errors) {
  return (fn) => {
    return (nativeError) => {
      const error = wrapLensCoreError(nativeError, isForFrameErrors);
      fn(error);
      errors.next(error);
    };
  };
}
function withTryCatch(fn, errors) {
  return function(...args) {
    try {
      return fn.apply(this, args);
    } catch (e2) {
      const error = wrapLensCoreError(e2, false);
      errors.next(error);
      throw error;
    }
  };
}
var errorsFieldName = "errors";
var createLensCore = (lensCoreModule) => {
  const errors = new Subject();
  const errorsObservable = errors.asObservable();
  const getRegularErrorWrapper = createErrorWrapper(false, errors);
  const getFrameErrorWrapper = createErrorWrapper(true, errors);
  const customMethods = {
    initialize(input) {
      return new Promise((onSuccess, onFailure) => {
        var _a;
        return lensCoreModule.initialize(Object.assign(Object.assign({}, input), { exceptionHandler: getFrameErrorWrapper((_a = input.exceptionHandler) !== null && _a !== void 0 ? _a : () => {
        }), onSuccess, onFailure: getRegularErrorWrapper(onFailure) }));
      });
    },
    provideRemoteAssetsResponse(input) {
      var _a;
      return lensCoreModule.provideRemoteAssetsResponse(Object.assign(Object.assign({}, input), { onFailure: getRegularErrorWrapper((_a = input.onFailure) !== null && _a !== void 0 ? _a : () => {
      }) }));
    },
    playCanvas(input) {
      return new Promise((onReady, onFailure) => {
        lensCoreModule.playCanvas(Object.assign(Object.assign({}, input), { onReady, onFailure: getRegularErrorWrapper(onFailure) }));
      });
    }
  };
  return new Proxy(lensCoreModule, {
    get: (target, property, receiver) => {
      if (property === errorsFieldName) {
        return errorsObservable;
      }
      if (property in customMethods) {
        return withTryCatch(customMethods[property], errors);
      }
      const targetProperty = Reflect.get(target, property, receiver);
      if (!targetProperty)
        return targetProperty;
      if (property in promisifiableMethods) {
        return withTryCatch(function(input) {
          return new Promise((onSuccess, onFailure) => targetProperty(Object.assign(Object.assign({}, input), { onSuccess, onFailure: getRegularErrorWrapper(onFailure) })));
        }, errors);
      }
      if (typeof targetProperty === "function") {
        if ("values" in targetProperty) {
          return targetProperty;
        } else {
          return withTryCatch(targetProperty, errors);
        }
      }
      return targetProperty;
    }
  });
};

// node_modules/@snap/camera-kit/dist/common/loadScript.js
function loadScript(scriptUri) {
  return new Promise((resolve, reject) => {
    const scriptElement = document.createElement("script");
    scriptElement.src = scriptUri;
    scriptElement.async = true;
    merge(fromEvent(scriptElement, "load").pipe(tap(() => resolve(scriptElement))), fromEvent(scriptElement, "error").pipe(tap((e2) => reject(e2)))).pipe(take(1)).subscribe();
    document.body.appendChild(scriptElement);
  });
}

// node_modules/@snap/camera-kit/dist/handlers/customLensCoreHandler.js
var createCustomLensCoreHandler = () => {
  return (next) => (input, init) => {
    var _a;
    const url = isString(input) ? input : (_a = input === null || input === void 0 ? void 0 : input.url) !== null && _a !== void 0 ? _a : "";
    if (url.startsWith("https://lens-core-wasm.sc-corp.net/")) {
      return next(input, Object.assign(Object.assign({}, init), { credentials: "include" }));
    }
    return next(input, init);
  };
};

// node_modules/wasm-feature-detect/dist/esm/index.js
var exceptions = async () => WebAssembly.validate(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 2, 1, 0, 10, 8, 1, 6, 0, 6, 64, 25, 11, 11]));
var simd = async () => WebAssembly.validate(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 5, 1, 96, 0, 1, 123, 3, 2, 1, 0, 10, 10, 1, 8, 0, 65, 0, 253, 15, 253, 98, 11]));

// node_modules/@snap/camera-kit/dist/common/memoize.js
function isMemoized(fn) {
  return typeof fn === "function" && typeof fn.delegate === "function";
}
function memoize(delegate) {
  let memo;
  const memoized = (...args) => {
    if (typeof memo !== "undefined")
      return memo;
    memo = delegate(...args);
    return memo;
  };
  memoized.delegate = delegate;
  return memoized;
}

// node_modules/@snap/camera-kit/dist/platform/platformInfo.js
function isNavigatorUAData(value) {
  return isRecord(value) && Array.isArray(value["brands"]) && value["brands"].every((brand) => {
    return isRecord(brand) && typeof brand["brand"] === "string" && typeof brand["version"] === "string";
  }) && typeof value["mobile"] === "boolean" && typeof value["platform"] === "string";
}
function parseDeviceModel(userAgent) {
  const userAgentWithModel = userAgent.match(/;[^;]+?;([^\)]+?)\)/);
  if (userAgentWithModel) {
    return userAgentWithModel[1].trim();
  }
  const userAgentWithModel2 = userAgent.match(/\(([^;]+);/);
  if (userAgentWithModel2) {
    return userAgentWithModel2[1].trim();
  }
  return "unknown";
}
function parseOrigin() {
  var _a, _b, _c;
  if (location.hostname !== "")
    return location.hostname;
  const possibleOrigins = location.ancestorOrigins === void 0 && typeof window !== "undefined" ? [window.parent.origin, (_b = (_a = window.top) === null || _a === void 0 ? void 0 : _a.origin) !== null && _b !== void 0 ? _b : ""] : (_c = location.ancestorOrigins) !== null && _c !== void 0 ? _c : [];
  for (let origin of possibleOrigins) {
    try {
      origin = new URL(origin).hostname;
      if (origin)
        return origin;
    } catch (_) {
    }
  }
  return "unknown";
}
function parseOSName(userAgent) {
  const knownPlatforms = /* @__PURE__ */ new Map([
    ["android", "android"],
    ["linux", "linux"],
    ["iphone os", "ios"],
    ["ipad", "ipados"],
    ["mac os", "macos"],
    ["macos", "macos"],
    ["windows", "windows"]
  ]);
  const normalizedUserAgent = userAgent.toLowerCase();
  for (const [match, platform] of knownPlatforms.entries()) {
    if (normalizedUserAgent.includes(match))
      return platform;
  }
  return "unknown";
}
function parseOSVersion(userAgent) {
  const versionMatch = userAgent.match(/\s([\d][\d_.]*[\d])(;|\)|\s)/);
  if (versionMatch != null) {
    return versionMatch[1].replace(/_/g, ".");
  }
  return "";
}
function parseUserAgentData(userAgent) {
  let brand;
  if (/Chrome/.test(userAgent)) {
    const versionMatch = userAgent.match(/Chrome\/([\d.]+)/);
    brand = {
      brand: "Chrome",
      version: versionMatch !== null ? versionMatch[1] : "unknown"
    };
  } else if (/Safari/.test(userAgent)) {
    let versionMatch = userAgent.match(/Version\/([\d.]+)/);
    if (versionMatch === null)
      versionMatch = userAgent.match(/Safari\/([\d.]+)/);
    brand = {
      brand: "Safari",
      version: versionMatch !== null ? versionMatch[1] : "unknown"
    };
  } else {
    brand = {
      brand: "Firefox",
      version: "0"
    };
  }
  const mobile = false;
  const platform = parseOSName(userAgent);
  return {
    brands: [brand],
    mobile,
    platform
  };
}
function normalizeBrands(brands) {
  const knownBrands = /* @__PURE__ */ new Map([
    ["Google Chrome", "Chrome"],
    ["Chrome", "Chrome"],
    ["Chromium", "Chrome"],
    ["Firefox", "Firefox"],
    ["Microsoft Edge", "Chrome"],
    ["Safari", "Safari"]
  ]);
  const normalizedBrands = brands.filter(({ brand }) => knownBrands.has(brand)).map((brand) => {
    return {
      brand: knownBrands.get(brand.brand),
      version: brand.version
    };
  });
  if (normalizedBrands.length === 0)
    return [{ brand: "Firefox", version: "0" }];
  return normalizedBrands;
}
function normalizeUserAgentData(userAgentData) {
  return {
    brands: normalizeBrands(userAgentData.brands),
    mobile: userAgentData.mobile,
    platform: parseOSName(userAgentData.platform)
  };
}
var getPlatformInfo = memoize(function getPlatformIno() {
  var _a, _b, _c;
  const userAgent = navigator.userAgent;
  const userAgentData = isNavigatorUAData(navigator.userAgentData) ? normalizeUserAgentData(navigator.userAgentData) : parseUserAgentData(userAgent);
  const osVersion = parseOSVersion(userAgent);
  const deviceModel = parseDeviceModel(userAgent);
  const sdkShortVersion = environment_default.PACKAGE_VERSION.replace(/[-+]\S+$/, "");
  const locale = navigator.language;
  const fullLocale = ((_a = navigator.languages) !== null && _a !== void 0 ? _a : []).map((lang, index) => {
    const qvalue = Math.max(0, (10 - index) / 10);
    return `${lang};q=${qvalue.toFixed(1)}`;
  }).join(", ") || locale;
  return {
    sdkShortVersion,
    sdkLongVersion: environment_default.PACKAGE_VERSION,
    lensCore: lensCoreWasmVersions_default,
    browser: userAgentData.brands[0],
    osName: userAgentData.platform,
    osVersion,
    deviceModel,
    locale,
    fullLocale,
    origin: parseOrigin(),
    connectionType: (_c = (_b = navigator.connection) === null || _b === void 0 ? void 0 : _b.type) !== null && _c !== void 0 ? _c : "unknown"
  };
});

// node_modules/@snap/camera-kit/dist/platform/platformCapabilities.js
var minRequiredMaxTextureSize = 1024;
function getWebGlSupport() {
  var _a, _b;
  const ctx = (_a = globalThis.document) === null || _a === void 0 ? void 0 : _a.createElement("canvas").getContext("webgl2");
  if (!ctx) {
    const cause = ((_b = globalThis.document) === null || _b === void 0 ? void 0 : _b.createElement("canvas").getContext("webgl")) ? "platform_not_supported_only_webgl1" : typeof globalThis.WebGLRenderingContext === "function" ? "platform_not_supported_likely_no_hw_accel" : "platform_not_supported_no_webgl_browser_support";
    return {
      supported: false,
      error: platformNotSupportedError("CameraKit requires WebGL2, but this browser does not support WebGL2.", new Error(cause))
    };
  }
  const maxTextureSize = ctx.getParameter(ctx.MAX_TEXTURE_SIZE);
  const supported = maxTextureSize >= minRequiredMaxTextureSize;
  return supported ? { supported, maxTextureSize } : {
    supported,
    error: platformNotSupportedError(`CameraKit requires WebGL's MAX_TEXTURE_SIZE exceed a minimum value of ${minRequiredMaxTextureSize}, but the browser's reported MAX_TEXTURE_SIZE is ${maxTextureSize}.`)
  };
}
var WasmFeatures;
(function(WasmFeatures2) {
  WasmFeatures2[WasmFeatures2["Default"] = 0] = "Default";
  WasmFeatures2[WasmFeatures2["SIMD"] = 1] = "SIMD";
  WasmFeatures2[WasmFeatures2["ExceptionHandling"] = 2] = "ExceptionHandling";
})(WasmFeatures || (WasmFeatures = {}));
function getWebAssemblyCapabilities() {
  return __awaiter(this, void 0, void 0, function* () {
    if (globalThis.WebAssembly === void 0)
      return {
        supported: false,
        error: platformNotSupportedError("CameraKit requires WebAssembly, but this browser does not support WebAssembly.")
      };
    return {
      supported: true,
      wasmFeatures: (yield Promise.all([
        simd().then((supported) => {
          if (getPlatformInfo().browser.brand === "Safari")
            return WasmFeatures.Default;
          return supported ? WasmFeatures.SIMD : WasmFeatures.Default;
        }),
        exceptions().then((supported) => supported ? WasmFeatures.ExceptionHandling : WasmFeatures.Default)
      ])).reduce((features, feature) => features | feature, WasmFeatures.Default)
    };
  });
}
function getGenericWebXrNotSupported(cause) {
  return {
    supported: false,
    error: platformNotSupportedError(`Use of this feature requires WebXR support for immersive AR sessions, but this browser does not support immersive AR sessions.`, cause)
  };
}
function getWebXrCapabilities() {
  return __awaiter(this, void 0, void 0, function* () {
    try {
      if (!isSecureContext || !navigator.xr)
        return getGenericWebXrNotSupported();
      const isImmersiveArSupported = yield navigator.xr.isSessionSupported("immersive-ar");
      return isImmersiveArSupported ? {
        supported: true,
        sixDofSupported: true,
        sceneDepthSupported: true
      } : getGenericWebXrNotSupported();
    } catch (error) {
      if (error instanceof Error && error.name === "SecurityError") {
        return {
          supported: false,
          error: platformNotSupportedError("Failed to check XR capabilities due to permissions or other issues.", error)
        };
      }
      return getGenericWebXrNotSupported(error);
    }
  });
}
var getPlatformCapabilities = memoize(function getPlatformCapabilities2() {
  return __awaiter(this, void 0, void 0, function* () {
    return {
      webgl: getWebGlSupport(),
      wasm: yield getWebAssemblyCapabilities(),
      webxr: yield getWebXrCapabilities()
    };
  });
});

// node_modules/@snap/camera-kit/dist/lens-core-module/loader/bootstrapURLs.js
var wasmCapabilitiesToLensCoreBuildFlavor = {
  [WasmFeatures.Default]: "release",
  [WasmFeatures.ExceptionHandling]: "rel-neh",
  [WasmFeatures.SIMD]: "release-simd",
  [WasmFeatures.ExceptionHandling | WasmFeatures.SIMD]: "rel-simd-neh"
};
var wasmAssets = ["LensCoreWebAssembly.js", "LensCoreWebAssembly.wasm"];
function getRequiredBootstrapURLs(endpointOverride) {
  return __awaiter(this, void 0, void 0, function* () {
    const endpoint = endpointOverride === null || endpointOverride === void 0 ? void 0 : endpointOverride.replace(/[\/]+$/, "");
    const { wasm } = yield getPlatformCapabilities();
    if (!wasm.supported)
      throw wasm.error;
    const { lensCore } = getPlatformInfo();
    const flavor = wasmCapabilitiesToLensCoreBuildFlavor[wasm.wasmFeatures];
    if (!flavor)
      throw new Error(`Could not determine a LensCore build flavor corresponding to the bitstring ${wasm.wasmFeatures.toString(2)}. CameraKit cannot be bootstrapped.`);
    const version = lensCore.version;
    const buildNumber = lensCore.buildNumber;
    return wasmAssets.map((asset) => {
      if (endpoint)
        return `${endpoint}/${asset}`;
      const { origin, pathname, search } = new URL(lensCore.baseUrl);
      return `${origin}${pathname}/${version}/${buildNumber}/${flavor}/${asset}${search}`;
    });
  });
}

// node_modules/@snap/camera-kit/dist/lens-core-module/loader/lensCoreFactory.js
var logger3 = getLogger("lensCoreFactory");
var findMatch = (regex, strings) => strings.find((s2) => regex.test(s2));
var lensCoreFactory = Injectable("lensCore", [defaultFetchHandlerFactory.token, configurationToken], (handler, { lensCoreOverrideUrls, wasmEndpointOverride }) => __awaiter(void 0, void 0, void 0, function* () {
  var _a, _b;
  let lensCoreJS;
  let lensCoreWASM;
  let lensCoreHandler = lensCoreOverrideUrls || wasmEndpointOverride ? new HandlerChainBuilder(handler).map(createCustomLensCoreHandler()).handler : handler;
  if (lensCoreOverrideUrls) {
    lensCoreJS = lensCoreOverrideUrls.js;
    lensCoreWASM = lensCoreOverrideUrls.wasm;
  } else {
    const endpointOverride = wasmEndpointOverride !== null && wasmEndpointOverride !== void 0 ? wasmEndpointOverride : void 0;
    const assetURLs = yield getRequiredBootstrapURLs(endpointOverride);
    lensCoreJS = (_a = findMatch(/\.js/, assetURLs)) !== null && _a !== void 0 ? _a : "";
    lensCoreWASM = (_b = findMatch(/\.wasm/, assetURLs)) !== null && _b !== void 0 ? _b : "";
    if (!lensCoreJS || !lensCoreWASM) {
      throw new Error(`Cannot fetch required LensCore assets. Either the JS or WASM filename is missing from this list: ${assetURLs}.`);
    }
    const glueScript = yield lensCoreHandler(lensCoreJS).then((r2) => r2.blob());
    lensCoreJS = URL.createObjectURL(glueScript);
  }
  const scriptElement = yield loadScript(lensCoreJS);
  const lensCore = yield new Promise((resolve, reject) => {
    let initialModule;
    const moduleInit = globalThis.createLensesModule(initialModule = {
      mainScriptUrlOrBlob: lensCoreJS,
      instantiateWasm: (importObject, receiveInstance) => {
        WebAssembly.instantiateStreaming(lensCoreHandler(lensCoreWASM), importObject).then(function({ instance, module: module2 }) {
          receiveInstance(instance, module2);
          initialModule.compiledModule = module2;
          resolve(moduleInit);
        }).catch(reject);
      }
    });
  });
  scriptElement.remove();
  if (lensCoreWasmVersions_default.version != `${lensCore.getCoreVersion()}`) {
    logger3.warn(`Loaded LensCore version (${lensCore.getCoreVersion()}) differs from expected one (${lensCoreWasmVersions_default.version})`);
  }
  return createLensCore(lensCore);
}));

// node_modules/@snap/camera-kit/dist/generated-proto/pb_schema/cdp/cof/namespace.js
var import_long3 = __toESM(require_long());
var import_minimal3 = __toESM(require_minimal2());
var Namespace;
(function(Namespace2) {
  Namespace2[Namespace2["DEFAULT"] = 0] = "DEFAULT";
  Namespace2[Namespace2["LENS_CORE"] = 64] = "LENS_CORE";
  Namespace2[Namespace2["CAMERA_KIT_CORE"] = 65] = "CAMERA_KIT_CORE";
  Namespace2[Namespace2["LENS_CORE_CONFIG"] = 143] = "LENS_CORE_CONFIG";
  Namespace2[Namespace2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(Namespace || (Namespace = {}));
if (import_minimal3.default.util.Long !== import_long3.default) {
  import_minimal3.default.util.Long = import_long3.default;
  import_minimal3.default.configure();
}

// node_modules/@snap/camera-kit/dist/generated-proto/pb_schema/camera_kit/v3/service.js
var import_long9 = __toESM(require_long());
var import_minimal9 = __toESM(require_minimal2());

// node_modules/@snap/camera-kit/dist/generated-proto/pb_schema/camera_kit/v3/ranking.js
var import_long4 = __toESM(require_long());
var import_minimal4 = __toESM(require_minimal2());
var RankingData_OSType;
(function(RankingData_OSType2) {
  RankingData_OSType2[RankingData_OSType2["OS_TYPE_UNSET"] = 0] = "OS_TYPE_UNSET";
  RankingData_OSType2[RankingData_OSType2["OS_TYPE_ANDROID"] = 1] = "OS_TYPE_ANDROID";
  RankingData_OSType2[RankingData_OSType2["OS_TYPE_IOS"] = 2] = "OS_TYPE_IOS";
  RankingData_OSType2[RankingData_OSType2["OS_TYPE_IPAD_OS"] = 3] = "OS_TYPE_IPAD_OS";
  RankingData_OSType2[RankingData_OSType2["OS_TYPE_MAC_OS"] = 4] = "OS_TYPE_MAC_OS";
  RankingData_OSType2[RankingData_OSType2["OS_TYPE_WINDOWS"] = 5] = "OS_TYPE_WINDOWS";
  RankingData_OSType2[RankingData_OSType2["OS_TYPE_LINUX"] = 6] = "OS_TYPE_LINUX";
  RankingData_OSType2[RankingData_OSType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(RankingData_OSType || (RankingData_OSType = {}));
var RankingData_ConnectivityType;
(function(RankingData_ConnectivityType2) {
  RankingData_ConnectivityType2[RankingData_ConnectivityType2["CONNECTIVITY_TYPE_UNSET"] = 0] = "CONNECTIVITY_TYPE_UNSET";
  RankingData_ConnectivityType2[RankingData_ConnectivityType2["CONNECTIVITY_TYPE_WIFI"] = 1] = "CONNECTIVITY_TYPE_WIFI";
  RankingData_ConnectivityType2[RankingData_ConnectivityType2["CONNECTIVITY_TYPE_MOBILE"] = 2] = "CONNECTIVITY_TYPE_MOBILE";
  RankingData_ConnectivityType2[RankingData_ConnectivityType2["CONNECTIVITY_TYPE_UNREACHABLE"] = 3] = "CONNECTIVITY_TYPE_UNREACHABLE";
  RankingData_ConnectivityType2[RankingData_ConnectivityType2["CONNECTIVITY_TYPE_BLUETOOTH"] = 4] = "CONNECTIVITY_TYPE_BLUETOOTH";
  RankingData_ConnectivityType2[RankingData_ConnectivityType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(RankingData_ConnectivityType || (RankingData_ConnectivityType = {}));
function createBaseRankingData() {
  return { sessionId: "", locale: "", osType: 0, connectivityType: 0 };
}
var RankingData = {
  encode(message, writer = import_minimal4.default.Writer.create()) {
    if (message.sessionId !== "") {
      writer.uint32(10).string(message.sessionId);
    }
    if (message.locale !== "") {
      writer.uint32(18).string(message.locale);
    }
    if (message.osType !== 0) {
      writer.uint32(24).int32(message.osType);
    }
    if (message.connectivityType !== 0) {
      writer.uint32(32).int32(message.connectivityType);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal4.default.Reader ? input : new import_minimal4.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseRankingData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.sessionId = reader.string();
          break;
        case 2:
          message.locale = reader.string();
          break;
        case 3:
          message.osType = reader.int32();
          break;
        case 4:
          message.connectivityType = reader.int32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(object) {
    var _a, _b, _c, _d;
    const message = createBaseRankingData();
    message.sessionId = (_a = object.sessionId) !== null && _a !== void 0 ? _a : "";
    message.locale = (_b = object.locale) !== null && _b !== void 0 ? _b : "";
    message.osType = (_c = object.osType) !== null && _c !== void 0 ? _c : 0;
    message.connectivityType = (_d = object.connectivityType) !== null && _d !== void 0 ? _d : 0;
    return message;
  }
};
if (import_minimal4.default.util.Long !== import_long4.default) {
  import_minimal4.default.util.Long = import_long4.default;
  import_minimal4.default.configure();
}

// node_modules/@snap/camera-kit/dist/generated-proto/pb_schema/camera_kit/v3/legal_prompt.js
var import_long6 = __toESM(require_long());
var import_minimal6 = __toESM(require_minimal2());

// node_modules/@snap/camera-kit/dist/generated-proto/pb_schema/google/protobuf/timestamp.js
var import_long5 = __toESM(require_long());
var import_minimal5 = __toESM(require_minimal2());
function createBaseTimestamp() {
  return { seconds: "0", nanos: 0 };
}
var Timestamp = {
  encode(message, writer = import_minimal5.default.Writer.create()) {
    if (message.seconds !== "0") {
      writer.uint32(8).int64(message.seconds);
    }
    if (message.nanos !== 0) {
      writer.uint32(16).int32(message.nanos);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal5.default.Reader ? input : new import_minimal5.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseTimestamp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.seconds = longToString(reader.int64());
          break;
        case 2:
          message.nanos = reader.int32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(object) {
    var _a, _b;
    const message = createBaseTimestamp();
    message.seconds = (_a = object.seconds) !== null && _a !== void 0 ? _a : "0";
    message.nanos = (_b = object.nanos) !== null && _b !== void 0 ? _b : 0;
    return message;
  }
};
function longToString(long) {
  return long.toString();
}
if (import_minimal5.default.util.Long !== import_long5.default) {
  import_minimal5.default.util.Long = import_long5.default;
  import_minimal5.default.configure();
}

// node_modules/@snap/camera-kit/dist/generated-proto/pb_schema/camera_kit/v3/legal_prompt.js
var LegalDocument_Type;
(function(LegalDocument_Type2) {
  LegalDocument_Type2[LegalDocument_Type2["UNSET"] = 0] = "UNSET";
  LegalDocument_Type2[LegalDocument_Type2["TERMS_OF_SERVICE"] = 1] = "TERMS_OF_SERVICE";
  LegalDocument_Type2[LegalDocument_Type2["PRIVACY_POLICY"] = 2] = "PRIVACY_POLICY";
  LegalDocument_Type2[LegalDocument_Type2["LEARN_MORE"] = 3] = "LEARN_MORE";
  LegalDocument_Type2[LegalDocument_Type2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(LegalDocument_Type || (LegalDocument_Type = {}));
function createBaseLegalPrompt() {
  return { documents: [], disabled: false };
}
var LegalPrompt = {
  encode(message, writer = import_minimal6.default.Writer.create()) {
    for (const v2 of message.documents) {
      LegalDocument.encode(v2, writer.uint32(10).fork()).ldelim();
    }
    if (message.disabled === true) {
      writer.uint32(16).bool(message.disabled);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal6.default.Reader ? input : new import_minimal6.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseLegalPrompt();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.documents.push(LegalDocument.decode(reader, reader.uint32()));
          break;
        case 2:
          message.disabled = reader.bool();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(object) {
    var _a, _b;
    const message = createBaseLegalPrompt();
    message.documents = ((_a = object.documents) === null || _a === void 0 ? void 0 : _a.map((e2) => LegalDocument.fromPartial(e2))) || [];
    message.disabled = (_b = object.disabled) !== null && _b !== void 0 ? _b : false;
    return message;
  }
};
function createBaseLegalDocument() {
  return { type: 0, webUrl: "", version: "", timestamp: void 0 };
}
var LegalDocument = {
  encode(message, writer = import_minimal6.default.Writer.create()) {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.webUrl !== "") {
      writer.uint32(18).string(message.webUrl);
    }
    if (message.version !== "") {
      writer.uint32(26).string(message.version);
    }
    if (message.timestamp !== void 0) {
      Timestamp.encode(toTimestamp(message.timestamp), writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal6.default.Reader ? input : new import_minimal6.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseLegalDocument();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.type = reader.int32();
          break;
        case 2:
          message.webUrl = reader.string();
          break;
        case 3:
          message.version = reader.string();
          break;
        case 4:
          message.timestamp = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(object) {
    var _a, _b, _c, _d;
    const message = createBaseLegalDocument();
    message.type = (_a = object.type) !== null && _a !== void 0 ? _a : 0;
    message.webUrl = (_b = object.webUrl) !== null && _b !== void 0 ? _b : "";
    message.version = (_c = object.version) !== null && _c !== void 0 ? _c : "";
    message.timestamp = (_d = object.timestamp) !== null && _d !== void 0 ? _d : void 0;
    return message;
  }
};
function toTimestamp(date) {
  const seconds = Math.trunc(date.getTime() / 1e3).toString();
  const nanos = date.getTime() % 1e3 * 1e6;
  return { seconds, nanos };
}
function fromTimestamp(t2) {
  let millis = Number(t2.seconds) * 1e3;
  millis += t2.nanos / 1e6;
  return new Date(millis);
}
if (import_minimal6.default.util.Long !== import_long6.default) {
  import_minimal6.default.util.Long = import_long6.default;
  import_minimal6.default.configure();
}

// node_modules/@snap/camera-kit/dist/generated-proto/pb_schema/camera_kit/v3/operational_metrics.js
var import_long7 = __toESM(require_long());
var import_minimal7 = __toESM(require_minimal2());
function createBaseOperationalMetric() {
  return { name: "", timestamp: void 0, metric: void 0 };
}
var OperationalMetric = {
  encode(message, writer = import_minimal7.default.Writer.create()) {
    var _a, _b, _c;
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.timestamp !== void 0) {
      Timestamp.encode(toTimestamp2(message.timestamp), writer.uint32(18).fork()).ldelim();
    }
    if (((_a = message.metric) === null || _a === void 0 ? void 0 : _a.$case) === "count") {
      writer.uint32(24).uint64(message.metric.count);
    }
    if (((_b = message.metric) === null || _b === void 0 ? void 0 : _b.$case) === "latencyMillis") {
      writer.uint32(32).uint64(message.metric.latencyMillis);
    }
    if (((_c = message.metric) === null || _c === void 0 ? void 0 : _c.$case) === "histogram") {
      writer.uint32(40).int64(message.metric.histogram);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal7.default.Reader ? input : new import_minimal7.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseOperationalMetric();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.name = reader.string();
          break;
        case 2:
          message.timestamp = fromTimestamp2(Timestamp.decode(reader, reader.uint32()));
          break;
        case 3:
          message.metric = { $case: "count", count: longToString2(reader.uint64()) };
          break;
        case 4:
          message.metric = { $case: "latencyMillis", latencyMillis: longToString2(reader.uint64()) };
          break;
        case 5:
          message.metric = { $case: "histogram", histogram: longToString2(reader.int64()) };
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(object) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
    const message = createBaseOperationalMetric();
    message.name = (_a = object.name) !== null && _a !== void 0 ? _a : "";
    message.timestamp = (_b = object.timestamp) !== null && _b !== void 0 ? _b : void 0;
    if (((_c = object.metric) === null || _c === void 0 ? void 0 : _c.$case) === "count" && ((_d = object.metric) === null || _d === void 0 ? void 0 : _d.count) !== void 0 && ((_e = object.metric) === null || _e === void 0 ? void 0 : _e.count) !== null) {
      message.metric = { $case: "count", count: object.metric.count };
    }
    if (((_f = object.metric) === null || _f === void 0 ? void 0 : _f.$case) === "latencyMillis" && ((_g = object.metric) === null || _g === void 0 ? void 0 : _g.latencyMillis) !== void 0 && ((_h = object.metric) === null || _h === void 0 ? void 0 : _h.latencyMillis) !== null) {
      message.metric = { $case: "latencyMillis", latencyMillis: object.metric.latencyMillis };
    }
    if (((_j = object.metric) === null || _j === void 0 ? void 0 : _j.$case) === "histogram" && ((_k = object.metric) === null || _k === void 0 ? void 0 : _k.histogram) !== void 0 && ((_l = object.metric) === null || _l === void 0 ? void 0 : _l.histogram) !== null) {
      message.metric = { $case: "histogram", histogram: object.metric.histogram };
    }
    return message;
  }
};
function createBaseOperationalMetricsBundle() {
  return { metrics: [] };
}
var OperationalMetricsBundle = {
  encode(message, writer = import_minimal7.default.Writer.create()) {
    for (const v2 of message.metrics) {
      OperationalMetric.encode(v2, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal7.default.Reader ? input : new import_minimal7.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseOperationalMetricsBundle();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.metrics.push(OperationalMetric.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(object) {
    var _a;
    const message = createBaseOperationalMetricsBundle();
    message.metrics = ((_a = object.metrics) === null || _a === void 0 ? void 0 : _a.map((e2) => OperationalMetric.fromPartial(e2))) || [];
    return message;
  }
};
function toTimestamp2(date) {
  const seconds = Math.trunc(date.getTime() / 1e3).toString();
  const nanos = date.getTime() % 1e3 * 1e6;
  return { seconds, nanos };
}
function fromTimestamp2(t2) {
  let millis = Number(t2.seconds) * 1e3;
  millis += t2.nanos / 1e6;
  return new Date(millis);
}
function longToString2(long) {
  return long.toString();
}
if (import_minimal7.default.util.Long !== import_long7.default) {
  import_minimal7.default.util.Long = import_long7.default;
  import_minimal7.default.configure();
}

// node_modules/@snap/camera-kit/dist/generated-proto/pb_schema/camera_kit/v3/business_events.js
var import_long8 = __toESM(require_long());
var import_minimal8 = __toESM(require_minimal2());
var CameraKitFlavor;
(function(CameraKitFlavor3) {
  CameraKitFlavor3[CameraKitFlavor3["CAMERA_KIT_FLAVOR_UNSET"] = 0] = "CAMERA_KIT_FLAVOR_UNSET";
  CameraKitFlavor3[CameraKitFlavor3["CAMERA_KIT_FLAVOR_DEBUG"] = 1] = "CAMERA_KIT_FLAVOR_DEBUG";
  CameraKitFlavor3[CameraKitFlavor3["CAMERA_KIT_FLAVOR_RELEASE"] = 2] = "CAMERA_KIT_FLAVOR_RELEASE";
  CameraKitFlavor3[CameraKitFlavor3["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(CameraKitFlavor || (CameraKitFlavor = {}));
var CameraKitConnectivityType;
(function(CameraKitConnectivityType3) {
  CameraKitConnectivityType3[CameraKitConnectivityType3["CAMERA_KIT_CONNECTIVITY_TYPE_UNSET"] = 0] = "CAMERA_KIT_CONNECTIVITY_TYPE_UNSET";
  CameraKitConnectivityType3[CameraKitConnectivityType3["CAMERA_KIT_CONNECTIVITY_TYPE_WIFI"] = 1] = "CAMERA_KIT_CONNECTIVITY_TYPE_WIFI";
  CameraKitConnectivityType3[CameraKitConnectivityType3["CAMERA_KIT_CONNECTIVITY_TYPE_MOBILE"] = 2] = "CAMERA_KIT_CONNECTIVITY_TYPE_MOBILE";
  CameraKitConnectivityType3[CameraKitConnectivityType3["CAMERA_KIT_CONNECTIVITY_TYPE_UNREACHABLE"] = 3] = "CAMERA_KIT_CONNECTIVITY_TYPE_UNREACHABLE";
  CameraKitConnectivityType3[CameraKitConnectivityType3["CAMERA_KIT_CONNECTIVITY_TYPE_BLUETOOTH"] = 4] = "CAMERA_KIT_CONNECTIVITY_TYPE_BLUETOOTH";
  CameraKitConnectivityType3[CameraKitConnectivityType3["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(CameraKitConnectivityType || (CameraKitConnectivityType = {}));
var CameraKitEnvironment;
(function(CameraKitEnvironment3) {
  CameraKitEnvironment3[CameraKitEnvironment3["CAMERA_KIT_ENVIRONMENT_UNSET"] = 0] = "CAMERA_KIT_ENVIRONMENT_UNSET";
  CameraKitEnvironment3[CameraKitEnvironment3["CAMERA_KIT_ENVIRONMENT_STAGING"] = 1] = "CAMERA_KIT_ENVIRONMENT_STAGING";
  CameraKitEnvironment3[CameraKitEnvironment3["CAMERA_KIT_ENVIRONMENT_PRODUCTION"] = 2] = "CAMERA_KIT_ENVIRONMENT_PRODUCTION";
  CameraKitEnvironment3[CameraKitEnvironment3["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(CameraKitEnvironment || (CameraKitEnvironment = {}));
function createBaseExtensionEventBase() {
  return {
    extensionName: "",
    extensionVersion: "",
    deviceCluster: "0",
    cameraKitVersion: "",
    lensCoreVersion: "",
    deviceModel: "",
    cameraKitFlavor: 0,
    appId: "",
    deviceConnectivity: 0,
    sessionId: "",
    cameraKitEnvironment: 0
  };
}
var ExtensionEventBase = {
  encode(message, writer = import_minimal8.default.Writer.create()) {
    if (message.extensionName !== "") {
      writer.uint32(10).string(message.extensionName);
    }
    if (message.extensionVersion !== "") {
      writer.uint32(18).string(message.extensionVersion);
    }
    if (message.deviceCluster !== "0") {
      writer.uint32(24).int64(message.deviceCluster);
    }
    if (message.cameraKitVersion !== "") {
      writer.uint32(34).string(message.cameraKitVersion);
    }
    if (message.lensCoreVersion !== "") {
      writer.uint32(42).string(message.lensCoreVersion);
    }
    if (message.deviceModel !== "") {
      writer.uint32(50).string(message.deviceModel);
    }
    if (message.cameraKitFlavor !== 0) {
      writer.uint32(56).int32(message.cameraKitFlavor);
    }
    if (message.appId !== "") {
      writer.uint32(66).string(message.appId);
    }
    if (message.deviceConnectivity !== 0) {
      writer.uint32(72).int32(message.deviceConnectivity);
    }
    if (message.sessionId !== "") {
      writer.uint32(82).string(message.sessionId);
    }
    if (message.cameraKitEnvironment !== 0) {
      writer.uint32(88).int32(message.cameraKitEnvironment);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal8.default.Reader ? input : new import_minimal8.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseExtensionEventBase();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.extensionName = reader.string();
          break;
        case 2:
          message.extensionVersion = reader.string();
          break;
        case 3:
          message.deviceCluster = longToString3(reader.int64());
          break;
        case 4:
          message.cameraKitVersion = reader.string();
          break;
        case 5:
          message.lensCoreVersion = reader.string();
          break;
        case 6:
          message.deviceModel = reader.string();
          break;
        case 7:
          message.cameraKitFlavor = reader.int32();
          break;
        case 8:
          message.appId = reader.string();
          break;
        case 9:
          message.deviceConnectivity = reader.int32();
          break;
        case 10:
          message.sessionId = reader.string();
          break;
        case 11:
          message.cameraKitEnvironment = reader.int32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(object) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
    const message = createBaseExtensionEventBase();
    message.extensionName = (_a = object.extensionName) !== null && _a !== void 0 ? _a : "";
    message.extensionVersion = (_b = object.extensionVersion) !== null && _b !== void 0 ? _b : "";
    message.deviceCluster = (_c = object.deviceCluster) !== null && _c !== void 0 ? _c : "0";
    message.cameraKitVersion = (_d = object.cameraKitVersion) !== null && _d !== void 0 ? _d : "";
    message.lensCoreVersion = (_e = object.lensCoreVersion) !== null && _e !== void 0 ? _e : "";
    message.deviceModel = (_f = object.deviceModel) !== null && _f !== void 0 ? _f : "";
    message.cameraKitFlavor = (_g = object.cameraKitFlavor) !== null && _g !== void 0 ? _g : 0;
    message.appId = (_h = object.appId) !== null && _h !== void 0 ? _h : "";
    message.deviceConnectivity = (_j = object.deviceConnectivity) !== null && _j !== void 0 ? _j : 0;
    message.sessionId = (_k = object.sessionId) !== null && _k !== void 0 ? _k : "";
    message.cameraKitEnvironment = (_l = object.cameraKitEnvironment) !== null && _l !== void 0 ? _l : 0;
    return message;
  }
};
function longToString3(long) {
  return long.toString();
}
if (import_minimal8.default.util.Long !== import_long8.default) {
  import_minimal8.default.util.Long = import_long8.default;
  import_minimal8.default.configure();
}

// node_modules/@snap/camera-kit/dist/generated-proto/pb_schema/camera_kit/v3/service.js
function createBaseGetGroupRequest() {
  return { id: "", rankingData: void 0 };
}
var GetGroupRequest = {
  encode(message, writer = import_minimal9.default.Writer.create()) {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.rankingData !== void 0) {
      RankingData.encode(message.rankingData, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal9.default.Reader ? input : new import_minimal9.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetGroupRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.id = reader.string();
          break;
        case 2:
          message.rankingData = RankingData.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(object) {
    var _a;
    const message = createBaseGetGroupRequest();
    message.id = (_a = object.id) !== null && _a !== void 0 ? _a : "";
    message.rankingData = object.rankingData !== void 0 && object.rankingData !== null ? RankingData.fromPartial(object.rankingData) : void 0;
    return message;
  }
};
function createBaseGetGroupResponse() {
  return { id: "", lenses: [] };
}
var GetGroupResponse = {
  encode(message, writer = import_minimal9.default.Writer.create()) {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    for (const v2 of message.lenses) {
      Lens.encode(v2, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal9.default.Reader ? input : new import_minimal9.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetGroupResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.id = reader.string();
          break;
        case 2:
          message.lenses.push(Lens.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(object) {
    var _a, _b;
    const message = createBaseGetGroupResponse();
    message.id = (_a = object.id) !== null && _a !== void 0 ? _a : "";
    message.lenses = ((_b = object.lenses) === null || _b === void 0 ? void 0 : _b.map((e2) => Lens.fromPartial(e2))) || [];
    return message;
  }
};
function createBaseGetGroupLensRequest() {
  return { lensId: "", groupId: "" };
}
var GetGroupLensRequest = {
  encode(message, writer = import_minimal9.default.Writer.create()) {
    if (message.lensId !== "") {
      writer.uint32(10).string(message.lensId);
    }
    if (message.groupId !== "") {
      writer.uint32(18).string(message.groupId);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal9.default.Reader ? input : new import_minimal9.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetGroupLensRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.lensId = reader.string();
          break;
        case 2:
          message.groupId = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(object) {
    var _a, _b;
    const message = createBaseGetGroupLensRequest();
    message.lensId = (_a = object.lensId) !== null && _a !== void 0 ? _a : "";
    message.groupId = (_b = object.groupId) !== null && _b !== void 0 ? _b : "";
    return message;
  }
};
function createBaseGetGroupLensResponse() {
  return { lens: void 0, groupId: "" };
}
var GetGroupLensResponse = {
  encode(message, writer = import_minimal9.default.Writer.create()) {
    if (message.lens !== void 0) {
      Lens.encode(message.lens, writer.uint32(10).fork()).ldelim();
    }
    if (message.groupId !== "") {
      writer.uint32(18).string(message.groupId);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal9.default.Reader ? input : new import_minimal9.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetGroupLensResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.lens = Lens.decode(reader, reader.uint32());
          break;
        case 2:
          message.groupId = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(object) {
    var _a;
    const message = createBaseGetGroupLensResponse();
    message.lens = object.lens !== void 0 && object.lens !== null ? Lens.fromPartial(object.lens) : void 0;
    message.groupId = (_a = object.groupId) !== null && _a !== void 0 ? _a : "";
    return message;
  }
};
function createBaseBatchGetGroupLensRequest() {
  return { getRequests: [] };
}
var BatchGetGroupLensRequest = {
  encode(message, writer = import_minimal9.default.Writer.create()) {
    for (const v2 of message.getRequests) {
      GetGroupLensRequest.encode(v2, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal9.default.Reader ? input : new import_minimal9.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseBatchGetGroupLensRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.getRequests.push(GetGroupLensRequest.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(object) {
    var _a;
    const message = createBaseBatchGetGroupLensRequest();
    message.getRequests = ((_a = object.getRequests) === null || _a === void 0 ? void 0 : _a.map((e2) => GetGroupLensRequest.fromPartial(e2))) || [];
    return message;
  }
};
function createBaseBatchGetGroupLensResponse() {
  return { getResponses: [] };
}
var BatchGetGroupLensResponse = {
  encode(message, writer = import_minimal9.default.Writer.create()) {
    for (const v2 of message.getResponses) {
      GetGroupLensResponse.encode(v2, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal9.default.Reader ? input : new import_minimal9.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseBatchGetGroupLensResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.getResponses.push(GetGroupLensResponse.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(object) {
    var _a;
    const message = createBaseBatchGetGroupLensResponse();
    message.getResponses = ((_a = object.getResponses) === null || _a === void 0 ? void 0 : _a.map((e2) => GetGroupLensResponse.fromPartial(e2))) || [];
    return message;
  }
};
function createBaseGetPlaceholderConfigRequest() {
  return {};
}
var GetPlaceholderConfigRequest = {
  encode(_, writer = import_minimal9.default.Writer.create()) {
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal9.default.Reader ? input : new import_minimal9.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetPlaceholderConfigRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(_) {
    const message = createBaseGetPlaceholderConfigRequest();
    return message;
  }
};
function createBaseGetPlaceholderConfigResponse() {
  return { configs: {} };
}
var GetPlaceholderConfigResponse = {
  encode(message, writer = import_minimal9.default.Writer.create()) {
    Object.entries(message.configs).forEach(([key, value]) => {
      GetPlaceholderConfigResponse_ConfigsEntry.encode({ key, value }, writer.uint32(10).fork()).ldelim();
    });
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal9.default.Reader ? input : new import_minimal9.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetPlaceholderConfigResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          const entry1 = GetPlaceholderConfigResponse_ConfigsEntry.decode(reader, reader.uint32());
          if (entry1.value !== void 0) {
            message.configs[entry1.key] = entry1.value;
          }
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(object) {
    var _a;
    const message = createBaseGetPlaceholderConfigResponse();
    message.configs = Object.entries((_a = object.configs) !== null && _a !== void 0 ? _a : {}).reduce((acc, [key, value]) => {
      if (value !== void 0) {
        acc[key] = String(value);
      }
      return acc;
    }, {});
    return message;
  }
};
function createBaseGetPlaceholderConfigResponse_ConfigsEntry() {
  return { key: "", value: "" };
}
var GetPlaceholderConfigResponse_ConfigsEntry = {
  encode(message, writer = import_minimal9.default.Writer.create()) {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal9.default.Reader ? input : new import_minimal9.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetPlaceholderConfigResponse_ConfigsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.key = reader.string();
          break;
        case 2:
          message.value = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(object) {
    var _a, _b;
    const message = createBaseGetPlaceholderConfigResponse_ConfigsEntry();
    message.key = (_a = object.key) !== null && _a !== void 0 ? _a : "";
    message.value = (_b = object.value) !== null && _b !== void 0 ? _b : "";
    return message;
  }
};
function createBaseGetInitializationConfigRequest() {
  return {};
}
var GetInitializationConfigRequest = {
  encode(_, writer = import_minimal9.default.Writer.create()) {
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal9.default.Reader ? input : new import_minimal9.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetInitializationConfigRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(_) {
    const message = createBaseGetInitializationConfigRequest();
    return message;
  }
};
function createBaseGetInitializationConfigResponse() {
  return {
    appVendorUuidOptIn: false,
    watermarkEnabled: false,
    childrenProtectionActRestricted: false,
    legalPrompt: void 0
  };
}
var GetInitializationConfigResponse = {
  encode(message, writer = import_minimal9.default.Writer.create()) {
    if (message.appVendorUuidOptIn === true) {
      writer.uint32(8).bool(message.appVendorUuidOptIn);
    }
    if (message.watermarkEnabled === true) {
      writer.uint32(16).bool(message.watermarkEnabled);
    }
    if (message.childrenProtectionActRestricted === true) {
      writer.uint32(24).bool(message.childrenProtectionActRestricted);
    }
    if (message.legalPrompt !== void 0) {
      LegalPrompt.encode(message.legalPrompt, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal9.default.Reader ? input : new import_minimal9.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetInitializationConfigResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.appVendorUuidOptIn = reader.bool();
          break;
        case 2:
          message.watermarkEnabled = reader.bool();
          break;
        case 3:
          message.childrenProtectionActRestricted = reader.bool();
          break;
        case 4:
          message.legalPrompt = LegalPrompt.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(object) {
    var _a, _b, _c;
    const message = createBaseGetInitializationConfigResponse();
    message.appVendorUuidOptIn = (_a = object.appVendorUuidOptIn) !== null && _a !== void 0 ? _a : false;
    message.watermarkEnabled = (_b = object.watermarkEnabled) !== null && _b !== void 0 ? _b : false;
    message.childrenProtectionActRestricted = (_c = object.childrenProtectionActRestricted) !== null && _c !== void 0 ? _c : false;
    message.legalPrompt = object.legalPrompt !== void 0 && object.legalPrompt !== null ? LegalPrompt.fromPartial(object.legalPrompt) : void 0;
    return message;
  }
};
function createBaseSetOperationalMetricsRequest() {
  return { metrics: void 0 };
}
var SetOperationalMetricsRequest = {
  encode(message, writer = import_minimal9.default.Writer.create()) {
    if (message.metrics !== void 0) {
      OperationalMetricsBundle.encode(message.metrics, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal9.default.Reader ? input : new import_minimal9.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSetOperationalMetricsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.metrics = OperationalMetricsBundle.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(object) {
    const message = createBaseSetOperationalMetricsRequest();
    message.metrics = object.metrics !== void 0 && object.metrics !== null ? OperationalMetricsBundle.fromPartial(object.metrics) : void 0;
    return message;
  }
};
function createBaseSetOperationalMetricsResponse() {
  return {};
}
var SetOperationalMetricsResponse = {
  encode(_, writer = import_minimal9.default.Writer.create()) {
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal9.default.Reader ? input : new import_minimal9.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSetOperationalMetricsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(_) {
    const message = createBaseSetOperationalMetricsResponse();
    return message;
  }
};
function createBaseSetBusinessEventsRequest() {
  return { batchEvents: void 0 };
}
var SetBusinessEventsRequest = {
  encode(message, writer = import_minimal9.default.Writer.create()) {
    if (message.batchEvents !== void 0) {
      Any.encode(message.batchEvents, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal9.default.Reader ? input : new import_minimal9.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSetBusinessEventsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.batchEvents = Any.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(object) {
    const message = createBaseSetBusinessEventsRequest();
    message.batchEvents = object.batchEvents !== void 0 && object.batchEvents !== null ? Any.fromPartial(object.batchEvents) : void 0;
    return message;
  }
};
function createBaseSetBusinessEventsResponse() {
  return {};
}
var SetBusinessEventsResponse = {
  encode(_, writer = import_minimal9.default.Writer.create()) {
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal9.default.Reader ? input : new import_minimal9.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSetBusinessEventsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(_) {
    const message = createBaseSetBusinessEventsResponse();
    return message;
  }
};
function createBaseSetExtensionBusinessEventsRequest() {
  return { events: [], extensionEventBase: void 0 };
}
var SetExtensionBusinessEventsRequest = {
  encode(message, writer = import_minimal9.default.Writer.create()) {
    for (const v2 of message.events) {
      Any.encode(v2, writer.uint32(10).fork()).ldelim();
    }
    if (message.extensionEventBase !== void 0) {
      ExtensionEventBase.encode(message.extensionEventBase, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal9.default.Reader ? input : new import_minimal9.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSetExtensionBusinessEventsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.events.push(Any.decode(reader, reader.uint32()));
          break;
        case 2:
          message.extensionEventBase = ExtensionEventBase.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(object) {
    var _a;
    const message = createBaseSetExtensionBusinessEventsRequest();
    message.events = ((_a = object.events) === null || _a === void 0 ? void 0 : _a.map((e2) => Any.fromPartial(e2))) || [];
    message.extensionEventBase = object.extensionEventBase !== void 0 && object.extensionEventBase !== null ? ExtensionEventBase.fromPartial(object.extensionEventBase) : void 0;
    return message;
  }
};
function createBaseSetExtensionBusinessEventsResponse() {
  return {};
}
var SetExtensionBusinessEventsResponse = {
  encode(_, writer = import_minimal9.default.Writer.create()) {
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal9.default.Reader ? input : new import_minimal9.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSetExtensionBusinessEventsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(_) {
    const message = createBaseSetExtensionBusinessEventsResponse();
    return message;
  }
};
var LensesDefinition = {
  name: "Lenses",
  fullName: "com.snap.camerakit.v3.Lenses",
  methods: {
    getGroup: {
      name: "GetGroup",
      requestType: GetGroupRequest,
      requestStream: false,
      responseType: GetGroupResponse,
      responseStream: false,
      options: {
        idempotencyLevel: "NO_SIDE_EFFECTS"
      }
    },
    getGroupLens: {
      name: "GetGroupLens",
      requestType: GetGroupLensRequest,
      requestStream: false,
      responseType: GetGroupLensResponse,
      responseStream: false,
      options: {
        idempotencyLevel: "NO_SIDE_EFFECTS"
      }
    },
    batchGetGroupLens: {
      name: "BatchGetGroupLens",
      requestType: BatchGetGroupLensRequest,
      requestStream: false,
      responseType: BatchGetGroupLensResponse,
      responseStream: false,
      options: {
        idempotencyLevel: "NO_SIDE_EFFECTS"
      }
    },
    getPlaceholderConfig: {
      name: "GetPlaceholderConfig",
      requestType: GetPlaceholderConfigRequest,
      requestStream: false,
      responseType: GetPlaceholderConfigResponse,
      responseStream: false,
      options: {
        idempotencyLevel: "NO_SIDE_EFFECTS"
      }
    }
  }
};
var MetricsDefinition = {
  name: "Metrics",
  fullName: "com.snap.camerakit.v3.Metrics",
  methods: {
    setOperationalMetrics: {
      name: "SetOperationalMetrics",
      requestType: SetOperationalMetricsRequest,
      requestStream: false,
      responseType: SetOperationalMetricsResponse,
      responseStream: false,
      options: {}
    },
    setBusinessEvents: {
      name: "SetBusinessEvents",
      requestType: SetBusinessEventsRequest,
      requestStream: false,
      responseType: SetBusinessEventsResponse,
      responseStream: false,
      options: {}
    },
    setExtensionBusinessEvents: {
      name: "SetExtensionBusinessEvents",
      requestType: SetExtensionBusinessEventsRequest,
      requestStream: false,
      responseType: SetExtensionBusinessEventsResponse,
      responseStream: false,
      options: {}
    },
    getInitializationConfig: {
      name: "GetInitializationConfig",
      requestType: GetInitializationConfigRequest,
      requestStream: false,
      responseType: GetInitializationConfigResponse,
      responseStream: false,
      options: {
        idempotencyLevel: "NO_SIDE_EFFECTS"
      }
    }
  }
};
if (import_minimal9.default.util.Long !== import_long9.default) {
  import_minimal9.default.util.Long = import_long9.default;
  import_minimal9.default.configure();
}

// node_modules/@snap/camera-kit/dist/clients/grpcHandler.js
var import_grpc_web = __toESM(require_grpc_web_client_umd());

// node_modules/@snap/camera-kit/dist/common/result.js
var OkResult = class _OkResult {
  constructor(value) {
    this.value = value;
    this.ok = true;
  }
  unwrap() {
    return this.value;
  }
  unwrapErr() {
    throw new Error("Ok Result cannot unwrapErr.");
  }
  map(m2) {
    return new _OkResult(m2(this.value));
  }
  flatMap(m2) {
    return m2(this.value);
  }
};
var Ok = (value) => new OkResult(value);
var ErrResult = class {
  constructor(value) {
    this.value = value;
    this.ok = false;
  }
  unwrap() {
    throw this.value;
  }
  unwrapErr() {
    return this.value;
  }
  map() {
    return this;
  }
  flatMap() {
    return this;
  }
};
var Err = (value) => new ErrResult(value);

// node_modules/@snap/camera-kit/dist/platform/cameraKitUserAgent.js
var getCameraKitUserAgent = memoize(function getCameraKitUserAgent2() {
  var _a;
  const { browser, deviceModel, origin, osName, osVersion, sdkShortVersion, lensCore } = getPlatformInfo();
  const { userAgentFlavor } = (_a = getConfigurationOverrides()) !== null && _a !== void 0 ? _a : { userAgentFlavor: "release" };
  const flavor = userAgentFlavor === "release" ? "" : "DEBUG ";
  return `CameraKitWeb/${sdkShortVersion} ${flavor}(${deviceModel}; ${osName} ${osVersion}) ${browser.brand}/${browser.version} Core/${lensCore.version} AppId/${origin}`;
});

// node_modules/@snap/camera-kit/dist/handlers/headersModifyingFetchHandler.js
var createHeadersModifyingFetchHandler = (modifyHeaders) => (next) => (input, init) => {
  const headers = init && init.headers ? new Headers(init.headers) : typeof input === "string" ? new Headers() : input.headers;
  const modifiedHeaders = modifyHeaders(headers);
  return next(input, Object.assign(Object.assign({}, init), { headers: modifiedHeaders }));
};

// node_modules/@snap/camera-kit/dist/handlers/cameraKitServiceFetchHandlerFactory.js
var cameraKitServiceFetchHandlerFactory = Injectable("cameraKitServiceFetchHandler", [configurationToken, defaultFetchHandlerFactory.token], ({ apiToken }, defaultFetchHandler) => {
  return new HandlerChainBuilder(defaultFetchHandler).map(createHeadersModifyingFetchHandler((headers) => {
    headers.append("x-snap-client-user-agent", getCameraKitUserAgent());
    headers.append("authorization", `Bearer ${apiToken}`);
    return headers;
  })).handler;
});

// node_modules/@snap/camera-kit/dist/clients/grpcHandler.js
var grpcHandlerFactory = Injectable("grpcHandlerFactory", [configurationToken, cameraKitServiceFetchHandlerFactory.token], (configuration, handler) => {
  const host = `https://${configuration.apiHostname}`;
  const transport = (options) => {
    let metadata = void 0;
    const controller = globalThis.AbortController ? new AbortController() : void 0;
    let cancelled = false;
    return {
      sendMessage(msgBytes) {
        var _a;
        handler(options.url, {
          headers: (_a = metadata === null || metadata === void 0 ? void 0 : metadata.toHeaders()) !== null && _a !== void 0 ? _a : {},
          method: "POST",
          body: msgBytes,
          signal: controller === null || controller === void 0 ? void 0 : controller.signal
        }).then((response) => {
          options.onHeaders(new import_grpc_web.grpc.Metadata(response.headers), response.status);
          return response.arrayBuffer();
        }).then((body) => {
          if (cancelled)
            return;
          options.onChunk(new Uint8Array(body));
          options.onEnd();
        }).catch((error) => {
          if (cancelled)
            return;
          cancelled = true;
          options.onEnd(error);
        });
      },
      start(m2) {
        metadata = m2;
      },
      finishSend() {
      },
      cancel() {
        if (cancelled)
          return;
        cancelled = true;
        controller === null || controller === void 0 ? void 0 : controller.abort();
      }
    };
  };
  return (request) => __awaiter(void 0, void 0, void 0, function* () {
    return new Promise((resolve) => {
      import_grpc_web.grpc.unary({
        methodName: request.methodName,
        service: { serviceName: request.serviceName },
        requestStream: false,
        responseStream: false,
        requestType: request.requestType,
        responseType: request.responseType
      }, {
        request: new request.requestType(),
        host,
        onEnd: (response) => {
          if (isUnaryOutputOk(response)) {
            resolve(Ok(response));
          } else {
            resolve(Err(response));
          }
        },
        transport
      });
    });
  });
});
function isUnaryOutputOk(value) {
  return value.status === import_grpc_web.grpc.Code.OK;
}

// node_modules/@snap/camera-kit/dist/clients/createTsProtoClient.js
function messageClass(message, data) {
  return class Message {
    constructor() {
      Object.assign(this, message.fromPartial(data));
    }
    static deserializeBinary(data2) {
      return new (messageClass(message, message.decode(data2)))();
    }
    serializeBinary() {
      return message.encode(this).finish();
    }
    toObject() {
      return this;
    }
  };
}
function createTsProtoClient(serviceDefinition, handler) {
  return fromEntries(entries(serviceDefinition.methods).map(([methodName, methodDefinition]) => {
    return [
      methodName,
      (request) => __awaiter(this, void 0, void 0, function* () {
        const requestType = messageClass(methodDefinition.requestType, request);
        const responseType = messageClass(methodDefinition.responseType, {});
        return handler({
          serviceName: serviceDefinition.fullName,
          methodName: methodDefinition.name,
          requestType,
          responseType
        });
      })
    ];
  }));
}

// node_modules/@snap/camera-kit/dist/remote-configuration/cofHandler.js
var import_browser_headers2 = __toESM(require_browser_headers_umd());

// node_modules/@snap/camera-kit/dist/common/unionBy.js
function unionBy(iteratee, ...arrays) {
  const throwIterateeError = () => {
    throw new Error("Iteratee must be a function or a valid property key of the item");
  };
  const seen = /* @__PURE__ */ new Map();
  for (const item of arrays.flat()) {
    const key = typeof iteratee === "function" ? iteratee(item) : typeof item === "object" && item !== null && iteratee in item ? item[iteratee] : throwIterateeError();
    seen.set(key, item);
  }
  return Array.from(seen.values());
}

// node_modules/@snap/camera-kit/dist/generated-proto/pb_schema/cdp/cof/circumstance_service.js
var import_long18 = __toESM(require_long());
var import_grpc_web2 = __toESM(require_grpc_web_client_umd());
var import_minimal18 = __toESM(require_minimal2());

// node_modules/@snap/camera-kit/dist/generated-proto/pb_schema/cdp/cof/config_request.js
var import_long13 = __toESM(require_long());
var import_minimal13 = __toESM(require_minimal2());

// node_modules/@snap/camera-kit/dist/generated-proto/pb_schema/cdp/cof/benchmark.js
var import_long10 = __toESM(require_long());
var import_minimal10 = __toESM(require_minimal2());
function createBaseBenchmarkValue() {
  return { intValue: void 0, longValue: void 0, boolValue: void 0, floatValue: void 0 };
}
var BenchmarkValue = {
  encode(message, writer = import_minimal10.default.Writer.create()) {
    if (message.intValue !== void 0) {
      writer.uint32(8).int32(message.intValue);
    }
    if (message.longValue !== void 0) {
      writer.uint32(16).int64(message.longValue);
    }
    if (message.boolValue !== void 0) {
      writer.uint32(24).bool(message.boolValue);
    }
    if (message.floatValue !== void 0) {
      writer.uint32(37).float(message.floatValue);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal10.default.Reader ? input : new import_minimal10.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseBenchmarkValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.intValue = reader.int32();
          break;
        case 2:
          message.longValue = longToString4(reader.int64());
          break;
        case 3:
          message.boolValue = reader.bool();
          break;
        case 4:
          message.floatValue = reader.float();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(object) {
    var _a, _b, _c, _d;
    const message = createBaseBenchmarkValue();
    message.intValue = (_a = object.intValue) !== null && _a !== void 0 ? _a : void 0;
    message.longValue = (_b = object.longValue) !== null && _b !== void 0 ? _b : void 0;
    message.boolValue = (_c = object.boolValue) !== null && _c !== void 0 ? _c : void 0;
    message.floatValue = (_d = object.floatValue) !== null && _d !== void 0 ? _d : void 0;
    return message;
  }
};
function createBaseBenchmarkRequest() {
  return { benchmarkNames: [], expirationTimestamp: void 0 };
}
var BenchmarkRequest = {
  encode(message, writer = import_minimal10.default.Writer.create()) {
    writer.uint32(10).fork();
    for (const v2 of message.benchmarkNames) {
      writer.int32(v2);
    }
    writer.ldelim();
    if (message.expirationTimestamp !== void 0) {
      Timestamp.encode(toTimestamp3(message.expirationTimestamp), writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal10.default.Reader ? input : new import_minimal10.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseBenchmarkRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if ((tag & 7) === 2) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.benchmarkNames.push(reader.int32());
            }
          } else {
            message.benchmarkNames.push(reader.int32());
          }
          break;
        case 2:
          message.expirationTimestamp = fromTimestamp3(Timestamp.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(object) {
    var _a, _b;
    const message = createBaseBenchmarkRequest();
    message.benchmarkNames = ((_a = object.benchmarkNames) === null || _a === void 0 ? void 0 : _a.map((e2) => e2)) || [];
    message.expirationTimestamp = (_b = object.expirationTimestamp) !== null && _b !== void 0 ? _b : void 0;
    return message;
  }
};
function createBaseBenchmarkResult() {
  return { name: 0, value: void 0 };
}
var BenchmarkResult = {
  encode(message, writer = import_minimal10.default.Writer.create()) {
    if (message.name !== 0) {
      writer.uint32(8).int32(message.name);
    }
    if (message.value !== void 0) {
      BenchmarkValue.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal10.default.Reader ? input : new import_minimal10.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseBenchmarkResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.name = reader.int32();
          break;
        case 2:
          message.value = BenchmarkValue.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(object) {
    var _a;
    const message = createBaseBenchmarkResult();
    message.name = (_a = object.name) !== null && _a !== void 0 ? _a : 0;
    message.value = object.value !== void 0 && object.value !== null ? BenchmarkValue.fromPartial(object.value) : void 0;
    return message;
  }
};
function toTimestamp3(date) {
  const seconds = Math.trunc(date.getTime() / 1e3).toString();
  const nanos = date.getTime() % 1e3 * 1e6;
  return { seconds, nanos };
}
function fromTimestamp3(t2) {
  let millis = Number(t2.seconds) * 1e3;
  millis += t2.nanos / 1e6;
  return new Date(millis);
}
function longToString4(long) {
  return long.toString();
}
if (import_minimal10.default.util.Long !== import_long10.default) {
  import_minimal10.default.util.Long = import_long10.default;
  import_minimal10.default.configure();
}

// node_modules/@snap/camera-kit/dist/generated-proto/pb_schema/common/ruid.js
var import_long11 = __toESM(require_long());
var import_minimal11 = __toESM(require_minimal2());
var Ruid_Type;
(function(Ruid_Type2) {
  Ruid_Type2[Ruid_Type2["UNSET"] = 0] = "UNSET";
  Ruid_Type2[Ruid_Type2["USER"] = 1] = "USER";
  Ruid_Type2[Ruid_Type2["DEVICE"] = 2] = "DEVICE";
  Ruid_Type2[Ruid_Type2["WEB_CLIENT"] = 3] = "WEB_CLIENT";
  Ruid_Type2[Ruid_Type2["AD_ACCOUNT"] = 4] = "AD_ACCOUNT";
  Ruid_Type2[Ruid_Type2["USERNAME"] = 5] = "USERNAME";
  Ruid_Type2[Ruid_Type2["AD_MODERATION_AD"] = 6] = "AD_MODERATION_AD";
  Ruid_Type2[Ruid_Type2["WEB_SNAPCHAT_USER"] = 7] = "WEB_SNAPCHAT_USER";
  Ruid_Type2[Ruid_Type2["INTERNAL"] = 8] = "INTERNAL";
  Ruid_Type2[Ruid_Type2["AM_ORGANIZATION"] = 9] = "AM_ORGANIZATION";
  Ruid_Type2[Ruid_Type2["AM_MEMBER"] = 10] = "AM_MEMBER";
  Ruid_Type2[Ruid_Type2["AM_SESSION"] = 11] = "AM_SESSION";
  Ruid_Type2[Ruid_Type2["AM_PROFILE"] = 12] = "AM_PROFILE";
  Ruid_Type2[Ruid_Type2["AM_SNAPCHAT_USER"] = 13] = "AM_SNAPCHAT_USER";
  Ruid_Type2[Ruid_Type2["SNAPCHAT_ADVERTISING"] = 14] = "SNAPCHAT_ADVERTISING";
  Ruid_Type2[Ruid_Type2["AM_CLIENT"] = 15] = "AM_CLIENT";
  Ruid_Type2[Ruid_Type2["MISCHIEF"] = 16] = "MISCHIEF";
  Ruid_Type2[Ruid_Type2["ARES_VISITOR"] = 17] = "ARES_VISITOR";
  Ruid_Type2[Ruid_Type2["POD_NAME"] = 18] = "POD_NAME";
  Ruid_Type2[Ruid_Type2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(Ruid_Type || (Ruid_Type = {}));
function createBaseRuid() {
  return { type: 0, stringValue: "", loggingIdValue: "" };
}
var Ruid = {
  encode(message, writer = import_minimal11.default.Writer.create()) {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.stringValue !== "") {
      writer.uint32(18).string(message.stringValue);
    }
    if (message.loggingIdValue !== "") {
      writer.uint32(26).string(message.loggingIdValue);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal11.default.Reader ? input : new import_minimal11.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseRuid();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.type = reader.int32();
          break;
        case 2:
          message.stringValue = reader.string();
          break;
        case 3:
          message.loggingIdValue = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(object) {
    var _a, _b, _c;
    const message = createBaseRuid();
    message.type = (_a = object.type) !== null && _a !== void 0 ? _a : 0;
    message.stringValue = (_b = object.stringValue) !== null && _b !== void 0 ? _b : "";
    message.loggingIdValue = (_c = object.loggingIdValue) !== null && _c !== void 0 ? _c : "";
    return message;
  }
};
if (import_minimal11.default.util.Long !== import_long11.default) {
  import_minimal11.default.util.Long = import_long11.default;
  import_minimal11.default.configure();
}

// node_modules/@snap/camera-kit/dist/generated-proto/pb_schema/google/protobuf/wrappers.js
var import_long12 = __toESM(require_long());
var import_minimal12 = __toESM(require_minimal2());
function createBaseBoolValue() {
  return { value: false };
}
var BoolValue = {
  encode(message, writer = import_minimal12.default.Writer.create()) {
    if (message.value === true) {
      writer.uint32(8).bool(message.value);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal12.default.Reader ? input : new import_minimal12.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseBoolValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.value = reader.bool();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(object) {
    var _a;
    const message = createBaseBoolValue();
    message.value = (_a = object.value) !== null && _a !== void 0 ? _a : false;
    return message;
  }
};
if (import_minimal12.default.util.Long !== import_long12.default) {
  import_minimal12.default.util.Long = import_long12.default;
  import_minimal12.default.configure();
}

// node_modules/@snap/camera-kit/dist/generated-proto/pb_schema/cdp/cof/config_request.js
var ConfigTargetingTriggerEventType;
(function(ConfigTargetingTriggerEventType2) {
  ConfigTargetingTriggerEventType2[ConfigTargetingTriggerEventType2["UNKNOWN_EVENT_TYPE"] = 0] = "UNKNOWN_EVENT_TYPE";
  ConfigTargetingTriggerEventType2[ConfigTargetingTriggerEventType2["COLD_START"] = 1] = "COLD_START";
  ConfigTargetingTriggerEventType2[ConfigTargetingTriggerEventType2["WARM_START"] = 2] = "WARM_START";
  ConfigTargetingTriggerEventType2[ConfigTargetingTriggerEventType2["FOREGROUND_TRIGGER"] = 3] = "FOREGROUND_TRIGGER";
  ConfigTargetingTriggerEventType2[ConfigTargetingTriggerEventType2["BACKGROUND_TRIGGER"] = 4] = "BACKGROUND_TRIGGER";
  ConfigTargetingTriggerEventType2[ConfigTargetingTriggerEventType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(ConfigTargetingTriggerEventType || (ConfigTargetingTriggerEventType = {}));
var ConfigTargetingAppState;
(function(ConfigTargetingAppState2) {
  ConfigTargetingAppState2[ConfigTargetingAppState2["UNKNOWN_APP_STATE"] = 0] = "UNKNOWN_APP_STATE";
  ConfigTargetingAppState2[ConfigTargetingAppState2["FOREGROUND"] = 1] = "FOREGROUND";
  ConfigTargetingAppState2[ConfigTargetingAppState2["BACKGROUND"] = 2] = "BACKGROUND";
  ConfigTargetingAppState2[ConfigTargetingAppState2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(ConfigTargetingAppState || (ConfigTargetingAppState = {}));
var ConfigTargetingInstrumentation;
(function(ConfigTargetingInstrumentation2) {
  ConfigTargetingInstrumentation2[ConfigTargetingInstrumentation2["DEFAULT_INSTRUMENTATION"] = 0] = "DEFAULT_INSTRUMENTATION";
  ConfigTargetingInstrumentation2[ConfigTargetingInstrumentation2["USER_AUTHENTICATION"] = 1] = "USER_AUTHENTICATION";
  ConfigTargetingInstrumentation2[ConfigTargetingInstrumentation2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(ConfigTargetingInstrumentation || (ConfigTargetingInstrumentation = {}));
var Connectivity_NetworkType;
(function(Connectivity_NetworkType2) {
  Connectivity_NetworkType2[Connectivity_NetworkType2["UNKNOWN_NETWORK_TYPE"] = 0] = "UNKNOWN_NETWORK_TYPE";
  Connectivity_NetworkType2[Connectivity_NetworkType2["CELLULAR"] = 1] = "CELLULAR";
  Connectivity_NetworkType2[Connectivity_NetworkType2["WIFI"] = 2] = "WIFI";
  Connectivity_NetworkType2[Connectivity_NetworkType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(Connectivity_NetworkType || (Connectivity_NetworkType = {}));
function createBaseConfigTargetingRequest() {
  return {
    configResultsEtag: "",
    namespaces: [],
    ghostId: "",
    countryCode: "",
    screenWidth: 0,
    screenHeight: 0,
    connectivity: void 0,
    maxVideoWidthPx: 0,
    maxVideoHeightPx: 0,
    benchmarkResults: [],
    deltaSync: false,
    userAgent: "",
    triggerEventType: 0,
    appState: 0,
    locale: "",
    deviceId: "",
    userId: "",
    clientIp: "",
    isUnAuthorized: false,
    appLocale: "",
    instrumentation: 0,
    lastSuccessfulSync: "0",
    isLogout: false,
    packageInstaller: "",
    syncTriggerBlizzardSessionId: "",
    syncExecutionBlizzardSessionId: "",
    cofSyncTriggerDelayFromStartupMs: 0,
    cofSyncExecutionDelayFromStartupMs: 0,
    syncTriggerTime: "0",
    decoderEncoderAvailability: void 0,
    snapkitAppId: "",
    lenscoreVersion: 0,
    ruid: void 0,
    configNames: [],
    includeTestUserTreatments: false,
    disableExposureLogging: false,
    lensClusterOrig4: 0,
    clientId: ""
  };
}
var ConfigTargetingRequest = {
  encode(message, writer = import_minimal13.default.Writer.create()) {
    if (message.configResultsEtag !== "") {
      writer.uint32(10).string(message.configResultsEtag);
    }
    writer.uint32(18).fork();
    for (const v2 of message.namespaces) {
      writer.int32(v2);
    }
    writer.ldelim();
    if (message.ghostId !== "") {
      writer.uint32(26).string(message.ghostId);
    }
    if (message.countryCode !== "") {
      writer.uint32(34).string(message.countryCode);
    }
    if (message.screenWidth !== 0) {
      writer.uint32(40).int32(message.screenWidth);
    }
    if (message.screenHeight !== 0) {
      writer.uint32(48).int32(message.screenHeight);
    }
    if (message.connectivity !== void 0) {
      Connectivity.encode(message.connectivity, writer.uint32(58).fork()).ldelim();
    }
    if (message.maxVideoWidthPx !== 0) {
      writer.uint32(64).int32(message.maxVideoWidthPx);
    }
    if (message.maxVideoHeightPx !== 0) {
      writer.uint32(72).int32(message.maxVideoHeightPx);
    }
    for (const v2 of message.benchmarkResults) {
      BenchmarkResult.encode(v2, writer.uint32(82).fork()).ldelim();
    }
    if (message.deltaSync === true) {
      writer.uint32(88).bool(message.deltaSync);
    }
    if (message.userAgent !== "") {
      writer.uint32(98).string(message.userAgent);
    }
    if (message.triggerEventType !== 0) {
      writer.uint32(104).int32(message.triggerEventType);
    }
    if (message.appState !== 0) {
      writer.uint32(112).int32(message.appState);
    }
    if (message.locale !== "") {
      writer.uint32(122).string(message.locale);
    }
    if (message.deviceId !== "") {
      writer.uint32(130).string(message.deviceId);
    }
    if (message.userId !== "") {
      writer.uint32(138).string(message.userId);
    }
    if (message.clientIp !== "") {
      writer.uint32(146).string(message.clientIp);
    }
    if (message.isUnAuthorized === true) {
      writer.uint32(152).bool(message.isUnAuthorized);
    }
    if (message.appLocale !== "") {
      writer.uint32(162).string(message.appLocale);
    }
    if (message.instrumentation !== 0) {
      writer.uint32(168).int32(message.instrumentation);
    }
    if (message.lastSuccessfulSync !== "0") {
      writer.uint32(176).int64(message.lastSuccessfulSync);
    }
    if (message.isLogout === true) {
      writer.uint32(184).bool(message.isLogout);
    }
    if (message.packageInstaller !== "") {
      writer.uint32(194).string(message.packageInstaller);
    }
    if (message.syncTriggerBlizzardSessionId !== "") {
      writer.uint32(202).string(message.syncTriggerBlizzardSessionId);
    }
    if (message.syncExecutionBlizzardSessionId !== "") {
      writer.uint32(210).string(message.syncExecutionBlizzardSessionId);
    }
    if (message.cofSyncTriggerDelayFromStartupMs !== 0) {
      writer.uint32(216).int32(message.cofSyncTriggerDelayFromStartupMs);
    }
    if (message.cofSyncExecutionDelayFromStartupMs !== 0) {
      writer.uint32(224).int32(message.cofSyncExecutionDelayFromStartupMs);
    }
    if (message.syncTriggerTime !== "0") {
      writer.uint32(232).int64(message.syncTriggerTime);
    }
    if (message.decoderEncoderAvailability !== void 0) {
      DecoderEncoderAvailablity.encode(message.decoderEncoderAvailability, writer.uint32(242).fork()).ldelim();
    }
    if (message.snapkitAppId !== "") {
      writer.uint32(250).string(message.snapkitAppId);
    }
    if (message.lenscoreVersion !== 0) {
      writer.uint32(256).int32(message.lenscoreVersion);
    }
    if (message.ruid !== void 0) {
      Ruid.encode(message.ruid, writer.uint32(266).fork()).ldelim();
    }
    for (const v2 of message.configNames) {
      writer.uint32(274).string(v2);
    }
    if (message.includeTestUserTreatments === true) {
      writer.uint32(288).bool(message.includeTestUserTreatments);
    }
    if (message.disableExposureLogging === true) {
      writer.uint32(296).bool(message.disableExposureLogging);
    }
    if (message.lensClusterOrig4 !== 0) {
      writer.uint32(304).int32(message.lensClusterOrig4);
    }
    if (message.clientId !== "") {
      writer.uint32(314).string(message.clientId);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal13.default.Reader ? input : new import_minimal13.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseConfigTargetingRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.configResultsEtag = reader.string();
          break;
        case 2:
          if ((tag & 7) === 2) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.namespaces.push(reader.int32());
            }
          } else {
            message.namespaces.push(reader.int32());
          }
          break;
        case 3:
          message.ghostId = reader.string();
          break;
        case 4:
          message.countryCode = reader.string();
          break;
        case 5:
          message.screenWidth = reader.int32();
          break;
        case 6:
          message.screenHeight = reader.int32();
          break;
        case 7:
          message.connectivity = Connectivity.decode(reader, reader.uint32());
          break;
        case 8:
          message.maxVideoWidthPx = reader.int32();
          break;
        case 9:
          message.maxVideoHeightPx = reader.int32();
          break;
        case 10:
          message.benchmarkResults.push(BenchmarkResult.decode(reader, reader.uint32()));
          break;
        case 11:
          message.deltaSync = reader.bool();
          break;
        case 12:
          message.userAgent = reader.string();
          break;
        case 13:
          message.triggerEventType = reader.int32();
          break;
        case 14:
          message.appState = reader.int32();
          break;
        case 15:
          message.locale = reader.string();
          break;
        case 16:
          message.deviceId = reader.string();
          break;
        case 17:
          message.userId = reader.string();
          break;
        case 18:
          message.clientIp = reader.string();
          break;
        case 19:
          message.isUnAuthorized = reader.bool();
          break;
        case 20:
          message.appLocale = reader.string();
          break;
        case 21:
          message.instrumentation = reader.int32();
          break;
        case 22:
          message.lastSuccessfulSync = longToString5(reader.int64());
          break;
        case 23:
          message.isLogout = reader.bool();
          break;
        case 24:
          message.packageInstaller = reader.string();
          break;
        case 25:
          message.syncTriggerBlizzardSessionId = reader.string();
          break;
        case 26:
          message.syncExecutionBlizzardSessionId = reader.string();
          break;
        case 27:
          message.cofSyncTriggerDelayFromStartupMs = reader.int32();
          break;
        case 28:
          message.cofSyncExecutionDelayFromStartupMs = reader.int32();
          break;
        case 29:
          message.syncTriggerTime = longToString5(reader.int64());
          break;
        case 30:
          message.decoderEncoderAvailability = DecoderEncoderAvailablity.decode(reader, reader.uint32());
          break;
        case 31:
          message.snapkitAppId = reader.string();
          break;
        case 32:
          message.lenscoreVersion = reader.int32();
          break;
        case 33:
          message.ruid = Ruid.decode(reader, reader.uint32());
          break;
        case 34:
          message.configNames.push(reader.string());
          break;
        case 36:
          message.includeTestUserTreatments = reader.bool();
          break;
        case 37:
          message.disableExposureLogging = reader.bool();
          break;
        case 38:
          message.lensClusterOrig4 = reader.int32();
          break;
        case 39:
          message.clientId = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(object) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10;
    const message = createBaseConfigTargetingRequest();
    message.configResultsEtag = (_a = object.configResultsEtag) !== null && _a !== void 0 ? _a : "";
    message.namespaces = ((_b = object.namespaces) === null || _b === void 0 ? void 0 : _b.map((e2) => e2)) || [];
    message.ghostId = (_c = object.ghostId) !== null && _c !== void 0 ? _c : "";
    message.countryCode = (_d = object.countryCode) !== null && _d !== void 0 ? _d : "";
    message.screenWidth = (_e = object.screenWidth) !== null && _e !== void 0 ? _e : 0;
    message.screenHeight = (_f = object.screenHeight) !== null && _f !== void 0 ? _f : 0;
    message.connectivity = object.connectivity !== void 0 && object.connectivity !== null ? Connectivity.fromPartial(object.connectivity) : void 0;
    message.maxVideoWidthPx = (_g = object.maxVideoWidthPx) !== null && _g !== void 0 ? _g : 0;
    message.maxVideoHeightPx = (_h = object.maxVideoHeightPx) !== null && _h !== void 0 ? _h : 0;
    message.benchmarkResults = ((_j = object.benchmarkResults) === null || _j === void 0 ? void 0 : _j.map((e2) => BenchmarkResult.fromPartial(e2))) || [];
    message.deltaSync = (_k = object.deltaSync) !== null && _k !== void 0 ? _k : false;
    message.userAgent = (_l = object.userAgent) !== null && _l !== void 0 ? _l : "";
    message.triggerEventType = (_m = object.triggerEventType) !== null && _m !== void 0 ? _m : 0;
    message.appState = (_o = object.appState) !== null && _o !== void 0 ? _o : 0;
    message.locale = (_p = object.locale) !== null && _p !== void 0 ? _p : "";
    message.deviceId = (_q = object.deviceId) !== null && _q !== void 0 ? _q : "";
    message.userId = (_r = object.userId) !== null && _r !== void 0 ? _r : "";
    message.clientIp = (_s = object.clientIp) !== null && _s !== void 0 ? _s : "";
    message.isUnAuthorized = (_t = object.isUnAuthorized) !== null && _t !== void 0 ? _t : false;
    message.appLocale = (_u = object.appLocale) !== null && _u !== void 0 ? _u : "";
    message.instrumentation = (_v = object.instrumentation) !== null && _v !== void 0 ? _v : 0;
    message.lastSuccessfulSync = (_w = object.lastSuccessfulSync) !== null && _w !== void 0 ? _w : "0";
    message.isLogout = (_x = object.isLogout) !== null && _x !== void 0 ? _x : false;
    message.packageInstaller = (_y = object.packageInstaller) !== null && _y !== void 0 ? _y : "";
    message.syncTriggerBlizzardSessionId = (_z = object.syncTriggerBlizzardSessionId) !== null && _z !== void 0 ? _z : "";
    message.syncExecutionBlizzardSessionId = (_0 = object.syncExecutionBlizzardSessionId) !== null && _0 !== void 0 ? _0 : "";
    message.cofSyncTriggerDelayFromStartupMs = (_1 = object.cofSyncTriggerDelayFromStartupMs) !== null && _1 !== void 0 ? _1 : 0;
    message.cofSyncExecutionDelayFromStartupMs = (_2 = object.cofSyncExecutionDelayFromStartupMs) !== null && _2 !== void 0 ? _2 : 0;
    message.syncTriggerTime = (_3 = object.syncTriggerTime) !== null && _3 !== void 0 ? _3 : "0";
    message.decoderEncoderAvailability = object.decoderEncoderAvailability !== void 0 && object.decoderEncoderAvailability !== null ? DecoderEncoderAvailablity.fromPartial(object.decoderEncoderAvailability) : void 0;
    message.snapkitAppId = (_4 = object.snapkitAppId) !== null && _4 !== void 0 ? _4 : "";
    message.lenscoreVersion = (_5 = object.lenscoreVersion) !== null && _5 !== void 0 ? _5 : 0;
    message.ruid = object.ruid !== void 0 && object.ruid !== null ? Ruid.fromPartial(object.ruid) : void 0;
    message.configNames = ((_6 = object.configNames) === null || _6 === void 0 ? void 0 : _6.map((e2) => e2)) || [];
    message.includeTestUserTreatments = (_7 = object.includeTestUserTreatments) !== null && _7 !== void 0 ? _7 : false;
    message.disableExposureLogging = (_8 = object.disableExposureLogging) !== null && _8 !== void 0 ? _8 : false;
    message.lensClusterOrig4 = (_9 = object.lensClusterOrig4) !== null && _9 !== void 0 ? _9 : 0;
    message.clientId = (_10 = object.clientId) !== null && _10 !== void 0 ? _10 : "";
    return message;
  }
};
function createBaseConnectivity() {
  return { networkType: 0, isMetered: void 0, isRoaming: void 0, carrier: "" };
}
var Connectivity = {
  encode(message, writer = import_minimal13.default.Writer.create()) {
    if (message.networkType !== 0) {
      writer.uint32(8).int32(message.networkType);
    }
    if (message.isMetered !== void 0) {
      BoolValue.encode({ value: message.isMetered }, writer.uint32(18).fork()).ldelim();
    }
    if (message.isRoaming !== void 0) {
      BoolValue.encode({ value: message.isRoaming }, writer.uint32(26).fork()).ldelim();
    }
    if (message.carrier !== "") {
      writer.uint32(34).string(message.carrier);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal13.default.Reader ? input : new import_minimal13.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseConnectivity();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.networkType = reader.int32();
          break;
        case 2:
          message.isMetered = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 3:
          message.isRoaming = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 4:
          message.carrier = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(object) {
    var _a, _b, _c, _d;
    const message = createBaseConnectivity();
    message.networkType = (_a = object.networkType) !== null && _a !== void 0 ? _a : 0;
    message.isMetered = (_b = object.isMetered) !== null && _b !== void 0 ? _b : void 0;
    message.isRoaming = (_c = object.isRoaming) !== null && _c !== void 0 ? _c : void 0;
    message.carrier = (_d = object.carrier) !== null && _d !== void 0 ? _d : "";
    return message;
  }
};
function createBaseDecoderEncoderAvailablity() {
  return { isSnapVp9DecoderAvailable: false, isSnapAv1DecoderAvailable: false };
}
var DecoderEncoderAvailablity = {
  encode(message, writer = import_minimal13.default.Writer.create()) {
    if (message.isSnapVp9DecoderAvailable === true) {
      writer.uint32(8).bool(message.isSnapVp9DecoderAvailable);
    }
    if (message.isSnapAv1DecoderAvailable === true) {
      writer.uint32(16).bool(message.isSnapAv1DecoderAvailable);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal13.default.Reader ? input : new import_minimal13.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseDecoderEncoderAvailablity();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.isSnapVp9DecoderAvailable = reader.bool();
          break;
        case 2:
          message.isSnapAv1DecoderAvailable = reader.bool();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(object) {
    var _a, _b;
    const message = createBaseDecoderEncoderAvailablity();
    message.isSnapVp9DecoderAvailable = (_a = object.isSnapVp9DecoderAvailable) !== null && _a !== void 0 ? _a : false;
    message.isSnapAv1DecoderAvailable = (_b = object.isSnapAv1DecoderAvailable) !== null && _b !== void 0 ? _b : false;
    return message;
  }
};
function longToString5(long) {
  return long.toString();
}
if (import_minimal13.default.util.Long !== import_long13.default) {
  import_minimal13.default.util.Long = import_long13.default;
  import_minimal13.default.configure();
}

// node_modules/@snap/camera-kit/dist/generated-proto/pb_schema/cdp/cof/config_response.js
var import_long16 = __toESM(require_long());
var import_minimal16 = __toESM(require_minimal2());

// node_modules/@snap/camera-kit/dist/generated-proto/pb_schema/cdp/cof/config_result.js
var import_long15 = __toESM(require_long());
var import_minimal15 = __toESM(require_minimal2());

// node_modules/@snap/camera-kit/dist/generated-proto/pb_schema/common/value.js
var import_long14 = __toESM(require_long());
var import_minimal14 = __toESM(require_minimal2());
function createBaseMapRecord() {
  return { key: "", value: "" };
}
var MapRecord = {
  encode(message, writer = import_minimal14.default.Writer.create()) {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal14.default.Reader ? input : new import_minimal14.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseMapRecord();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.key = reader.string();
          break;
        case 2:
          message.value = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(object) {
    var _a, _b;
    const message = createBaseMapRecord();
    message.key = (_a = object.key) !== null && _a !== void 0 ? _a : "";
    message.value = (_b = object.value) !== null && _b !== void 0 ? _b : "";
    return message;
  }
};
function createBaseMapRecords() {
  return { records: [] };
}
var MapRecords = {
  encode(message, writer = import_minimal14.default.Writer.create()) {
    for (const v2 of message.records) {
      MapRecord.encode(v2, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal14.default.Reader ? input : new import_minimal14.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseMapRecords();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.records.push(MapRecord.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(object) {
    var _a;
    const message = createBaseMapRecords();
    message.records = ((_a = object.records) === null || _a === void 0 ? void 0 : _a.map((e2) => MapRecord.fromPartial(e2))) || [];
    return message;
  }
};
function createBaseStringArray() {
  return { value: [] };
}
var StringArray = {
  encode(message, writer = import_minimal14.default.Writer.create()) {
    for (const v2 of message.value) {
      writer.uint32(10).string(v2);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal14.default.Reader ? input : new import_minimal14.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseStringArray();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.value.push(reader.string());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(object) {
    var _a;
    const message = createBaseStringArray();
    message.value = ((_a = object.value) === null || _a === void 0 ? void 0 : _a.map((e2) => e2)) || [];
    return message;
  }
};
function createBaseValue() {
  return {
    intValue: void 0,
    longValue: void 0,
    floatValue: void 0,
    doubleValue: void 0,
    boolValue: void 0,
    stringValue: void 0,
    anyValue: void 0,
    mapValue: void 0,
    intPairValue: void 0,
    stringArrayValue: void 0
  };
}
var Value = {
  encode(message, writer = import_minimal14.default.Writer.create()) {
    if (message.intValue !== void 0) {
      writer.uint32(8).int32(message.intValue);
    }
    if (message.longValue !== void 0) {
      writer.uint32(16).int64(message.longValue);
    }
    if (message.floatValue !== void 0) {
      writer.uint32(29).float(message.floatValue);
    }
    if (message.doubleValue !== void 0) {
      writer.uint32(73).double(message.doubleValue);
    }
    if (message.boolValue !== void 0) {
      writer.uint32(32).bool(message.boolValue);
    }
    if (message.stringValue !== void 0) {
      writer.uint32(42).string(message.stringValue);
    }
    if (message.anyValue !== void 0) {
      Any.encode(message.anyValue, writer.uint32(50).fork()).ldelim();
    }
    if (message.mapValue !== void 0) {
      MapRecords.encode(message.mapValue, writer.uint32(58).fork()).ldelim();
    }
    if (message.intPairValue !== void 0) {
      writer.uint32(65).fixed64(message.intPairValue);
    }
    if (message.stringArrayValue !== void 0) {
      StringArray.encode(message.stringArrayValue, writer.uint32(82).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal14.default.Reader ? input : new import_minimal14.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.intValue = reader.int32();
          break;
        case 2:
          message.longValue = longToString6(reader.int64());
          break;
        case 3:
          message.floatValue = reader.float();
          break;
        case 9:
          message.doubleValue = reader.double();
          break;
        case 4:
          message.boolValue = reader.bool();
          break;
        case 5:
          message.stringValue = reader.string();
          break;
        case 6:
          message.anyValue = Any.decode(reader, reader.uint32());
          break;
        case 7:
          message.mapValue = MapRecords.decode(reader, reader.uint32());
          break;
        case 8:
          message.intPairValue = longToString6(reader.fixed64());
          break;
        case 10:
          message.stringArrayValue = StringArray.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(object) {
    var _a, _b, _c, _d, _e, _f, _g;
    const message = createBaseValue();
    message.intValue = (_a = object.intValue) !== null && _a !== void 0 ? _a : void 0;
    message.longValue = (_b = object.longValue) !== null && _b !== void 0 ? _b : void 0;
    message.floatValue = (_c = object.floatValue) !== null && _c !== void 0 ? _c : void 0;
    message.doubleValue = (_d = object.doubleValue) !== null && _d !== void 0 ? _d : void 0;
    message.boolValue = (_e = object.boolValue) !== null && _e !== void 0 ? _e : void 0;
    message.stringValue = (_f = object.stringValue) !== null && _f !== void 0 ? _f : void 0;
    message.anyValue = object.anyValue !== void 0 && object.anyValue !== null ? Any.fromPartial(object.anyValue) : void 0;
    message.mapValue = object.mapValue !== void 0 && object.mapValue !== null ? MapRecords.fromPartial(object.mapValue) : void 0;
    message.intPairValue = (_g = object.intPairValue) !== null && _g !== void 0 ? _g : void 0;
    message.stringArrayValue = object.stringArrayValue !== void 0 && object.stringArrayValue !== null ? StringArray.fromPartial(object.stringArrayValue) : void 0;
    return message;
  }
};
function longToString6(long) {
  return long.toString();
}
if (import_minimal14.default.util.Long !== import_long14.default) {
  import_minimal14.default.util.Long = import_long14.default;
  import_minimal14.default.configure();
}

// node_modules/@snap/camera-kit/dist/generated-proto/pb_schema/cdp/cof/config_result.js
var ConfigResult_ServePlatform;
(function(ConfigResult_ServePlatform2) {
  ConfigResult_ServePlatform2[ConfigResult_ServePlatform2["UNKNOWN_CONTEXT_PLATFORM"] = 0] = "UNKNOWN_CONTEXT_PLATFORM";
  ConfigResult_ServePlatform2[ConfigResult_ServePlatform2["IOS_PLATFORM"] = 1] = "IOS_PLATFORM";
  ConfigResult_ServePlatform2[ConfigResult_ServePlatform2["ANDROID_PLATFORM"] = 2] = "ANDROID_PLATFORM";
  ConfigResult_ServePlatform2[ConfigResult_ServePlatform2["SERVER_PLATFORM"] = 3] = "SERVER_PLATFORM";
  ConfigResult_ServePlatform2[ConfigResult_ServePlatform2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(ConfigResult_ServePlatform || (ConfigResult_ServePlatform = {}));
var ClientTargetingExpression_Operator;
(function(ClientTargetingExpression_Operator2) {
  ClientTargetingExpression_Operator2[ClientTargetingExpression_Operator2["UNKNOWN_OPERATOR"] = 0] = "UNKNOWN_OPERATOR";
  ClientTargetingExpression_Operator2[ClientTargetingExpression_Operator2["AND"] = 1] = "AND";
  ClientTargetingExpression_Operator2[ClientTargetingExpression_Operator2["OR"] = 2] = "OR";
  ClientTargetingExpression_Operator2[ClientTargetingExpression_Operator2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(ClientTargetingExpression_Operator || (ClientTargetingExpression_Operator = {}));
var ClientTargetingExpression_PredicateOperator;
(function(ClientTargetingExpression_PredicateOperator2) {
  ClientTargetingExpression_PredicateOperator2[ClientTargetingExpression_PredicateOperator2["UNKNOWN_PREDICATE_OPERATOR"] = 0] = "UNKNOWN_PREDICATE_OPERATOR";
  ClientTargetingExpression_PredicateOperator2[ClientTargetingExpression_PredicateOperator2["EQUAL"] = 1] = "EQUAL";
  ClientTargetingExpression_PredicateOperator2[ClientTargetingExpression_PredicateOperator2["NOT_EQUAL"] = 2] = "NOT_EQUAL";
  ClientTargetingExpression_PredicateOperator2[ClientTargetingExpression_PredicateOperator2["GREATER_THAN_OR_EQUAL_TO"] = 3] = "GREATER_THAN_OR_EQUAL_TO";
  ClientTargetingExpression_PredicateOperator2[ClientTargetingExpression_PredicateOperator2["LESS_THAN_OR_EQUAL_TO"] = 4] = "LESS_THAN_OR_EQUAL_TO";
  ClientTargetingExpression_PredicateOperator2[ClientTargetingExpression_PredicateOperator2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(ClientTargetingExpression_PredicateOperator || (ClientTargetingExpression_PredicateOperator = {}));
var ClientTargetingExpression_Property;
(function(ClientTargetingExpression_Property2) {
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["UNKNOWN_PROPERTY"] = 0] = "UNKNOWN_PROPERTY";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["BATTERY_LEVEL"] = 1] = "BATTERY_LEVEL";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["IS_OFFLINE"] = 2] = "IS_OFFLINE";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["IS_CHARGING"] = 3] = "IS_CHARGING";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["BANDWIDTH"] = 4] = "BANDWIDTH";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["DISK_SIZE"] = 5] = "DISK_SIZE";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["DISK_AVAILABLE"] = 6] = "DISK_AVAILABLE";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["MEDIA_TYPE_DEPRECATED"] = 7] = "MEDIA_TYPE_DEPRECATED";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["IS_PUBLIC_STORY"] = 8] = "IS_PUBLIC_STORY";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["IS_OFFICIAL_STORY"] = 9] = "IS_OFFICIAL_STORY";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["CAMERA_DIRECTION"] = 10] = "CAMERA_DIRECTION";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["CAMERA_CONTEXT"] = 11] = "CAMERA_CONTEXT";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["CAMERA_API"] = 12] = "CAMERA_API";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["CAMERA_FLASH_STATE"] = 13] = "CAMERA_FLASH_STATE";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["SNAP_SOURCE"] = 14] = "SNAP_SOURCE";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["LEGACY_MUSHROOM_CONTENT_TYPE"] = 15] = "LEGACY_MUSHROOM_CONTENT_TYPE";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["UPLOAD_BANDWIDTH"] = 16] = "UPLOAD_BANDWIDTH";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["CAMERA2_LEVEL"] = 17] = "CAMERA2_LEVEL";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["CAMERA_NIGHT_MODE_STATE"] = 18] = "CAMERA_NIGHT_MODE_STATE";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["USER_LANGUAGE"] = 19] = "USER_LANGUAGE";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["VIDEO_DURATION"] = 20] = "VIDEO_DURATION";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["REALTIME_MOBILE_NETWORK_GENERATION"] = 21] = "REALTIME_MOBILE_NETWORK_GENERATION";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["REALTIME_NETWORK_TYPE"] = 22] = "REALTIME_NETWORK_TYPE";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["REALTIME_NETWORK_IS_METERED"] = 23] = "REALTIME_NETWORK_IS_METERED";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["REALTIME_NETWORK_IS_ROAMING"] = 24] = "REALTIME_NETWORK_IS_ROAMING";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["CAMERA_IS_FIRST_CAPTURE"] = 25] = "CAMERA_IS_FIRST_CAPTURE";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["PICTURE_MODE"] = 26] = "PICTURE_MODE";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["BOLT_USE_CASE"] = 27] = "BOLT_USE_CASE";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["BOLT_CDN_EXPERIMENTATION_ID"] = 28] = "BOLT_CDN_EXPERIMENTATION_ID";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["MINS_SINCE_LAST_LENS_ACTIVATION"] = 29] = "MINS_SINCE_LAST_LENS_ACTIVATION";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["MINS_SINCE_LAST_SNAPPABLE_LENS_ACTIVATION"] = 30] = "MINS_SINCE_LAST_SNAPPABLE_LENS_ACTIVATION";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["DAYS_SINCE_LAST_LOGIN_OR_OPEN"] = 31] = "DAYS_SINCE_LAST_LOGIN_OR_OPEN";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["SPECTACLES_VERSION"] = 32] = "SPECTACLES_VERSION";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["STICKY_MAX_CONNECTION_TYPE"] = 33] = "STICKY_MAX_CONNECTION_TYPE";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["WITH_ANIMATED_OVERLAY"] = 34] = "WITH_ANIMATED_OVERLAY";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["ESTIMATED_DURATION_FOR_EVENT_MS"] = 35] = "ESTIMATED_DURATION_FOR_EVENT_MS";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["URL"] = 36] = "URL";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["MEDIA_SOURCE"] = 37] = "MEDIA_SOURCE";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["ASSET_TYPE"] = 38] = "ASSET_TYPE";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["BOLT_IS_CONTENT_POPULAR"] = 39] = "BOLT_IS_CONTENT_POPULAR";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["CAPTURE_MODE"] = 40] = "CAPTURE_MODE";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["VP9_SOFTWARE_DECODING_SUPPORTED"] = 41] = "VP9_SOFTWARE_DECODING_SUPPORTED";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["AV1_SOFTWARE_DECODING_SUPPORTED"] = 42] = "AV1_SOFTWARE_DECODING_SUPPORTED";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["WITH_MUSIC"] = 43] = "WITH_MUSIC";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["FEATURE_PROVIDED_SIZE"] = 44] = "FEATURE_PROVIDED_SIZE";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["MEDIA_TYPE"] = 45] = "MEDIA_TYPE";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["SCANNED_CATEGORY_IDS"] = 46] = "SCANNED_CATEGORY_IDS";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["CONTENT_VIEW_SOURCE"] = 47] = "CONTENT_VIEW_SOURCE";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["RECIPIENTS_SUPPORT_HEVC"] = 48] = "RECIPIENTS_SUPPORT_HEVC";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["COGNAC_APP_ID"] = 49] = "COGNAC_APP_ID";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["EMAIL_VERIFIED"] = 50] = "EMAIL_VERIFIED";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["PHONE_VERIFIED"] = 51] = "PHONE_VERIFIED";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["NOTIFICATION_PERM_GRANTED"] = 52] = "NOTIFICATION_PERM_GRANTED";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["CONTACT_PERM_GRANTED"] = 53] = "CONTACT_PERM_GRANTED";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["MUTUAL_FRIENDS_COUNT"] = 54] = "MUTUAL_FRIENDS_COUNT";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["GROUPS_COUNT"] = 55] = "GROUPS_COUNT";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["HAS_NON_TEAM_SNAPCHAT_CONVERSATIONS"] = 56] = "HAS_NON_TEAM_SNAPCHAT_CONVERSATIONS";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["PLAYBACK_ITEM_TYPE"] = 57] = "PLAYBACK_ITEM_TYPE";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["SUP_BOOLEAN_PROPERTY"] = 58] = "SUP_BOOLEAN_PROPERTY";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["SUP_INTEGER_PROPERTY"] = 59] = "SUP_INTEGER_PROPERTY";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["SUP_LONG_PROPERTY"] = 60] = "SUP_LONG_PROPERTY";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["SUP_STRING_PROPERTY"] = 61] = "SUP_STRING_PROPERTY";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["SUP_DOUBLE_PROPERTY"] = 62] = "SUP_DOUBLE_PROPERTY";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["SUP_MILLIS_PROPERTY_TO_NOW"] = 63] = "SUP_MILLIS_PROPERTY_TO_NOW";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["HAS_USED_SPECTACLES"] = 64] = "HAS_USED_SPECTACLES";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["SUP_SECS_PROPERTY_TO_NOW"] = 65] = "SUP_SECS_PROPERTY_TO_NOW";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["BOLT_CLIENT_APP_STATE"] = 66] = "BOLT_CLIENT_APP_STATE";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["EMAIL_SET"] = 67] = "EMAIL_SET";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["BITMOJI_SET"] = 68] = "BITMOJI_SET";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["QUICK_TAP_CAMERA_SUPPORTED_ENABLED"] = 69] = "QUICK_TAP_CAMERA_SUPPORTED_ENABLED";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["HAS_ADD_FRIENDS_REQUEST"] = 70] = "HAS_ADD_FRIENDS_REQUEST";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["APP_LAUNCH_FROM_PUSH"] = 71] = "APP_LAUNCH_FROM_PUSH";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["APP_LAUNCH_TYPE"] = 72] = "APP_LAUNCH_TYPE";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["BILLBOARD_CAMPAIGN_LOCAL_IMPRESSION_COUNT"] = 73] = "BILLBOARD_CAMPAIGN_LOCAL_IMPRESSION_COUNT";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["BILLBOARD_CAMPAIGN_LOCAL_LAST_IMPRESSION_TIME_SECS_TO_NOW"] = 74] = "BILLBOARD_CAMPAIGN_LOCAL_LAST_IMPRESSION_TIME_SECS_TO_NOW";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["BILLBOARD_CAMPAIGN_LOCAL_CONTINUOUS_DISMISS_COUNT"] = 75] = "BILLBOARD_CAMPAIGN_LOCAL_CONTINUOUS_DISMISS_COUNT";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["FST_NUM_IN_APP_WARNINGS"] = 76] = "FST_NUM_IN_APP_WARNINGS";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["FST_SHOULD_CHANGE_PASSWORD"] = 77] = "FST_SHOULD_CHANGE_PASSWORD";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["FST_IS_BACKGROUND_CHECK"] = 78] = "FST_IS_BACKGROUND_CHECK";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["AUDIO_RECORD_PERM_GRANTED"] = 79] = "AUDIO_RECORD_PERM_GRANTED";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["MUTUAL_FRIENDS_WITH_BIRTHDAY_COUNT"] = 80] = "MUTUAL_FRIENDS_WITH_BIRTHDAY_COUNT";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["BILLBOARD_CAMPAIGN_LOCAL_DISMISS_COUNT"] = 81] = "BILLBOARD_CAMPAIGN_LOCAL_DISMISS_COUNT";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["USE_VERTICAL_NAVIGATION"] = 82] = "USE_VERTICAL_NAVIGATION";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["FREEABLE_DISK_AVAILABLE"] = 83] = "FREEABLE_DISK_AVAILABLE";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["MEMORIES_COUNT"] = 84] = "MEMORIES_COUNT";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["DEVICE_MODEL"] = 85] = "DEVICE_MODEL";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["COUNTRY"] = 86] = "COUNTRY";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["OS"] = 87] = "OS";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["OS_VERSION"] = 88] = "OS_VERSION";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["APP_VERSION"] = 89] = "APP_VERSION";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["BUILD_FLAVOR"] = 90] = "BUILD_FLAVOR";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["USER_ID"] = 91] = "USER_ID";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["LOCALE"] = 92] = "LOCALE";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["DEVICE_CLUSTER"] = 93] = "DEVICE_CLUSTER";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["DEVICE_BRAND"] = 94] = "DEVICE_BRAND";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["IS_EMPLOYEE"] = 95] = "IS_EMPLOYEE";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["USERNAME"] = 96] = "USERNAME";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["IS_TEST_USER"] = 97] = "IS_TEST_USER";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["USER_PROFILE"] = 98] = "USER_PROFILE";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["SCREEN_WIDTH"] = 99] = "SCREEN_WIDTH";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["SCREEN_HEIGHT"] = 100] = "SCREEN_HEIGHT";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["HEVC_SUPPORT"] = 101] = "HEVC_SUPPORT";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["NETWORK_TYPE"] = 102] = "NETWORK_TYPE";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["MAX_VIDEO_WIDTH"] = 103] = "MAX_VIDEO_WIDTH";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["MAX_VIDEO_HEIGHT"] = 104] = "MAX_VIDEO_HEIGHT";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["IS_NETWORK_METERED"] = 105] = "IS_NETWORK_METERED";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["IS_ROAMING"] = 106] = "IS_ROAMING";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["APP_ENGAGEMENT_LEVEL"] = 107] = "APP_ENGAGEMENT_LEVEL";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["COMMUNICATION_ENGAGEMENT_LEVEL"] = 108] = "COMMUNICATION_ENGAGEMENT_LEVEL";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["FRIEND_STORY_ENGAGEMENT_LEVEL"] = 109] = "FRIEND_STORY_ENGAGEMENT_LEVEL";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["PUBLIC_USER_STORY_ENGAGEMENT_LEVEL"] = 110] = "PUBLIC_USER_STORY_ENGAGEMENT_LEVEL";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["PUBLISHER_STORY_ENGAGEMENT_LEVEL"] = 111] = "PUBLISHER_STORY_ENGAGEMENT_LEVEL";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["LENS_ENGAGEMENT_LEVEL"] = 112] = "LENS_ENGAGEMENT_LEVEL";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["NON_FRIEND_STORY_ENGAGEMENT_LEVEL"] = 113] = "NON_FRIEND_STORY_ENGAGEMENT_LEVEL";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["FOLLOWER_SIZE_LEVEL"] = 114] = "FOLLOWER_SIZE_LEVEL";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["DAYS_SINCE_CREATION"] = 115] = "DAYS_SINCE_CREATION";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["USER_PERSONA"] = 116] = "USER_PERSONA";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["USER_CREATION_TIME"] = 117] = "USER_CREATION_TIME";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["MOBILE_NETWORK_TYPE"] = 118] = "MOBILE_NETWORK_TYPE";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["AGGREGATED_USER_BANDWIDTH"] = 119] = "AGGREGATED_USER_BANDWIDTH";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["LENS_CLUSTER_BIASED"] = 120] = "LENS_CLUSTER_BIASED";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["LENS_CLUSTER_LOG"] = 121] = "LENS_CLUSTER_LOG";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["LENS_CLUSTER_ORIG"] = 122] = "LENS_CLUSTER_ORIG";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["LENS_CLUSTER_ORIG_4"] = 123] = "LENS_CLUSTER_ORIG_4";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["LENS_CLUSTER_BIASED_LOG"] = 124] = "LENS_CLUSTER_BIASED_LOG";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["APP_LOCALE"] = 125] = "APP_LOCALE";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["DEVICE_COMMON_NAME"] = 126] = "DEVICE_COMMON_NAME";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["USER_FRIEND_COUNT"] = 127] = "USER_FRIEND_COUNT";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["L90_COUNTRY"] = 128] = "L90_COUNTRY";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["STUB"] = 129] = "STUB";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["IS_TRUE"] = 130] = "IS_TRUE";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["STORY_POST_RATIO"] = 131] = "STORY_POST_RATIO";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["GENDER"] = 132] = "GENDER";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["INFERRED_AGE_BUCKET"] = 133] = "INFERRED_AGE_BUCKET";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["STORIES"] = 134] = "STORIES";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["SENDS"] = 135] = "SENDS";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["SNAP_CREATE_L7"] = 136] = "SNAP_CREATE_L7";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["STORY_POST_L7"] = 137] = "STORY_POST_L7";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["COMMUNICATION_L7"] = 138] = "COMMUNICATION_L7";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["DF_L7"] = 139] = "DF_L7";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["APP_L7"] = 140] = "APP_L7";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["DAYS_SINCE_CREATION_BUCKET"] = 141] = "DAYS_SINCE_CREATION_BUCKET";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["BIDIRECTIONAL_FRIEND_STATUS"] = 142] = "BIDIRECTIONAL_FRIEND_STATUS";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["STORY_POST_PREDICTION"] = 143] = "STORY_POST_PREDICTION";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["APP_OPENS"] = 144] = "APP_OPENS";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["LENS_SWIPES"] = 145] = "LENS_SWIPES";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["LENS_SNAPS"] = 146] = "LENS_SNAPS";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["LENS_OPS"] = 147] = "LENS_OPS";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["W1_APP_OPENS"] = 148] = "W1_APP_OPENS";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["W1_LENS_SWIPES"] = 149] = "W1_LENS_SWIPES";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["W1_LENS_SNAPS"] = 150] = "W1_LENS_SNAPS";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["W1_LENS_OPS"] = 151] = "W1_LENS_OPS";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["W2_APP_OPENS"] = 152] = "W2_APP_OPENS";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["W2_LENS_SWIPES"] = 153] = "W2_LENS_SWIPES";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["W2_LENS_SNAPS"] = 154] = "W2_LENS_SNAPS";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["W2_LENS_OPS"] = 155] = "W2_LENS_OPS";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["W34_APP_OPENS"] = 156] = "W34_APP_OPENS";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["W34_LENS_SWIPES"] = 157] = "W34_LENS_SWIPES";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["W34_LENS_SNAPS"] = 158] = "W34_LENS_SNAPS";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["W34_LENS_OPS"] = 159] = "W34_LENS_OPS";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["LENS_SWIPES_PREDICTION"] = 160] = "LENS_SWIPES_PREDICTION";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["REGISTRATION_COUNTRY"] = 161] = "REGISTRATION_COUNTRY";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["IP_ASN"] = 162] = "IP_ASN";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["IP_REGION"] = 163] = "IP_REGION";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["IP_CITY"] = 164] = "IP_CITY";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["HAS_USER_ID"] = 165] = "HAS_USER_ID";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["HAS_BITMOJI"] = 166] = "HAS_BITMOJI";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["NUM_APP_OPENS_LAST_8_DAYS"] = 167] = "NUM_APP_OPENS_LAST_8_DAYS";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["NUM_FEATURE_STORY_VIEW_DAYS_L7"] = 168] = "NUM_FEATURE_STORY_VIEW_DAYS_L7";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["NUM_FEATURE_STORY_SYNC_DAYS_L7"] = 169] = "NUM_FEATURE_STORY_SYNC_DAYS_L7";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["HEXAGON_NN_SUPPORTED_VERSION"] = 170] = "HEXAGON_NN_SUPPORTED_VERSION";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["NETWORK_QUALITY"] = 171] = "NETWORK_QUALITY";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["DEVICE_MEMORY_MB"] = 172] = "DEVICE_MEMORY_MB";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["DEVICE_GL_VERSION"] = 173] = "DEVICE_GL_VERSION";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["SNAP_PRO_STATUS"] = 174] = "SNAP_PRO_STATUS";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["DEVICE_VP9_DECODING_SUPPORT"] = 175] = "DEVICE_VP9_DECODING_SUPPORT";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["AVG_FRIEND_STORY_VIEW_COUNT_L7"] = 176] = "AVG_FRIEND_STORY_VIEW_COUNT_L7";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["GAME_JOIN_TIME"] = 177] = "GAME_JOIN_TIME";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["GAME_LAST_ACTIVE_TIME"] = 178] = "GAME_LAST_ACTIVE_TIME";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["DAYS_SINCE_FIRST_GAME_ACTIVITY"] = 179] = "DAYS_SINCE_FIRST_GAME_ACTIVITY";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["DAYS_SINCE_LAST_GAME_ACTIVITY"] = 180] = "DAYS_SINCE_LAST_GAME_ACTIVITY";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["PF_PAGE_SESSIONS_WITH_LONG_IMP"] = 181] = "PF_PAGE_SESSIONS_WITH_LONG_IMP";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["WIRELESS_CARRIER"] = 182] = "WIRELESS_CARRIER";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["MINIS_JOIN_TIME"] = 183] = "MINIS_JOIN_TIME";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["MINIS_LAST_ACTIVE_TIME"] = 184] = "MINIS_LAST_ACTIVE_TIME";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["DAYS_SINCE_FIRST_MINIS_ACTIVITY"] = 185] = "DAYS_SINCE_FIRST_MINIS_ACTIVITY";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["DAYS_SINCE_LAST_MINIS_ACTIVITY"] = 186] = "DAYS_SINCE_LAST_MINIS_ACTIVITY";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["DEVICE_AV1_DECODING_SUPPORT"] = 187] = "DEVICE_AV1_DECODING_SUPPORT";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["APP_PACKAGE_INSTALLER"] = 188] = "APP_PACKAGE_INSTALLER";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["STORY_VIEWS_5TH_TAB_ENGAGEMENT_LEVEL"] = 189] = "STORY_VIEWS_5TH_TAB_ENGAGEMENT_LEVEL";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["REPORTED_AGE"] = 190] = "REPORTED_AGE";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["ANDROID_MOBILE_SERVICES_PROVIDER"] = 191] = "ANDROID_MOBILE_SERVICES_PROVIDER";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["IS_ACQUIRED_USER"] = 192] = "IS_ACQUIRED_USER";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["YDPI"] = 193] = "YDPI";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["BIDIRECTIONAL_FRIEND_STATUS_VELLUM"] = 194] = "BIDIRECTIONAL_FRIEND_STATUS_VELLUM";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["ORIGIN"] = 195] = "ORIGIN";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["LENSCORE_VERSION"] = 196] = "LENSCORE_VERSION";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["SNAPKIT_APP_ID"] = 197] = "SNAPKIT_APP_ID";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["GPU"] = 198] = "GPU";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["CHIPSET_NAME"] = 199] = "CHIPSET_NAME";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["CHIPSET_VERSION"] = 200] = "CHIPSET_VERSION";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["HAS_ZERO_IDFA"] = 201] = "HAS_ZERO_IDFA";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["LIMIT_AD_TRACKING"] = 202] = "LIMIT_AD_TRACKING";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["ATT_AUTH_STATUS"] = 203] = "ATT_AUTH_STATUS";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["CAMERA2_FRONT_SS_GAIN_OVER_TPA"] = 204] = "CAMERA2_FRONT_SS_GAIN_OVER_TPA";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["ATTACHMENT_TOOL_V2"] = 205] = "ATTACHMENT_TOOL_V2";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["USER_PERSONA_V3"] = 206] = "USER_PERSONA_V3";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["SNAPS_SEND_WITH_HEVC"] = 207] = "SNAPS_SEND_WITH_HEVC";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["SNAPS_SEND_WITHOUT_HEVC"] = 208] = "SNAPS_SEND_WITHOUT_HEVC";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["CAMERA2_NATIVE_CRASH_OVER_CAMERA1"] = 209] = "CAMERA2_NATIVE_CRASH_OVER_CAMERA1";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["CAMERA2_G2S_LATENCY_OVER_CAMERA1"] = 210] = "CAMERA2_G2S_LATENCY_OVER_CAMERA1";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["IS_INTERNAL"] = 211] = "IS_INTERNAL";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["IS_WEB"] = 212] = "IS_WEB";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["APP_OPEN_TO_MAP"] = 213] = "APP_OPEN_TO_MAP";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["APP_OPEN_TO_FRIENDSFEED"] = 214] = "APP_OPEN_TO_FRIENDSFEED";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["APP_OPEN_TO_LENSES"] = 215] = "APP_OPEN_TO_LENSES";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["APP_OPEN_TO_MEMORIES"] = 216] = "APP_OPEN_TO_MEMORIES";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["APP_OPEN_TO_COMMUNITY"] = 217] = "APP_OPEN_TO_COMMUNITY";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["APP_OPEN_TO_SPOTLIGHT"] = 218] = "APP_OPEN_TO_SPOTLIGHT";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["IS_IMPACTED_BY_PINC_893"] = 219] = "IS_IMPACTED_BY_PINC_893";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["DAYS_BEFORE_BIRTHDAY"] = 220] = "DAYS_BEFORE_BIRTHDAY";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["HAS_BIPA"] = 221] = "HAS_BIPA";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["SPOTLIGHT_STORY_ENGAGEMENT_STATUS"] = 222] = "SPOTLIGHT_STORY_ENGAGEMENT_STATUS";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["INCLUSION_PANEL_MEMBER"] = 223] = "INCLUSION_PANEL_MEMBER";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["HEVC_HW_DECODER"] = 224] = "HEVC_HW_DECODER";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["HEVC_SW_DECODER"] = 225] = "HEVC_SW_DECODER";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["HASH_MURMUR3_128_MOD_100"] = 226] = "HASH_MURMUR3_128_MOD_100";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["HAS_ACTIVE_SNAPCHAT_PLUS"] = 227] = "HAS_ACTIVE_SNAPCHAT_PLUS";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["SNAP_KIT_OAUTH_ID"] = 228] = "SNAP_KIT_OAUTH_ID";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["ORGANIZATION_TYPE"] = 229] = "ORGANIZATION_TYPE";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["CHUNK_UPLOAD_SUPPORT_REQUIRED"] = 230] = "CHUNK_UPLOAD_SUPPORT_REQUIRED";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["CLOUDFRONT_POP"] = 231] = "CLOUDFRONT_POP";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["BILLBOARD_CAMPAIGN_LOCAL_FIRST_IMPRESSION_TIME_SECS_TO_NOW"] = 232] = "BILLBOARD_CAMPAIGN_LOCAL_FIRST_IMPRESSION_TIME_SECS_TO_NOW";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["BILLBOARD_CAMPAIGN_LOCAL_CLICK_COUNT"] = 233] = "BILLBOARD_CAMPAIGN_LOCAL_CLICK_COUNT";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["BILLBOARD_CAMPAIGN_LOCAL_INTERACTION_COUNT"] = 234] = "BILLBOARD_CAMPAIGN_LOCAL_INTERACTION_COUNT";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["BILLBOARD_CAMPAIGN_LOCAL_LAST_INTERACTION_TIME_SECS_TO_NOW"] = 235] = "BILLBOARD_CAMPAIGN_LOCAL_LAST_INTERACTION_TIME_SECS_TO_NOW";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["FST_LOCK_SCREEN_WIDGET_BILLBOARD_LAUNCHED_FROM_PUSH"] = 236] = "FST_LOCK_SCREEN_WIDGET_BILLBOARD_LAUNCHED_FROM_PUSH";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["WEB_SCREEN_WIDTH"] = 237] = "WEB_SCREEN_WIDTH";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["WEB_SCREEN_HEIGHT"] = 238] = "WEB_SCREEN_HEIGHT";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["SUP_IOS_LOCK_SCREEN_WIDGET_ENABLED"] = 239] = "SUP_IOS_LOCK_SCREEN_WIDGET_ENABLED";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["SNAP_PRIVACY"] = 240] = "SNAP_PRIVACY";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["ADS_INTERFACES_IS_NEW_ORGANIZATION"] = 241] = "ADS_INTERFACES_IS_NEW_ORGANIZATION";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["SERVER_ONLY"] = 242] = "SERVER_ONLY";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["GHE_ORGANIZATION"] = 243] = "GHE_ORGANIZATION";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["GHE_REPOSITORY"] = 244] = "GHE_REPOSITORY";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["GHE_USER_EMAIL"] = 245] = "GHE_USER_EMAIL";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["BUILD_DEFINITION_ID"] = 246] = "BUILD_DEFINITION_ID";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["BUILD_DEFINITION_NAME"] = 247] = "BUILD_DEFINITION_NAME";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["LCA_PRINCIPAL"] = 248] = "LCA_PRINCIPAL";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["MEDIA_PERFORMANCE_CLASS"] = 249] = "MEDIA_PERFORMANCE_CLASS";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["COMMUNITY_COUNT"] = 250] = "COMMUNITY_COUNT";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["RECIPIENTS_SUPPORT_FMP4"] = 251] = "RECIPIENTS_SUPPORT_FMP4";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["SCREEN_ASPECT_RATIO"] = 252] = "SCREEN_ASPECT_RATIO";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["USER_GROUP"] = 253] = "USER_GROUP";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["USER_HAS_DENIED_CAMERA_PERM"] = 254] = "USER_HAS_DENIED_CAMERA_PERM";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["CAMEOS_ENGAGEMENT_LEVEL"] = 255] = "CAMEOS_ENGAGEMENT_LEVEL";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["HAS_CAMEOS"] = 256] = "HAS_CAMEOS";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["IS_ACTIVE_LENS_VIDEO_CHAT_USER"] = 257] = "IS_ACTIVE_LENS_VIDEO_CHAT_USER";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["NUM_SPOTLIGHT_POSTS_L7"] = 258] = "NUM_SPOTLIGHT_POSTS_L7";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["NUM_MAP_POSTS_L7"] = 259] = "NUM_MAP_POSTS_L7";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["HAS_CREATED_PUBLIC_PROFILE"] = 260] = "HAS_CREATED_PUBLIC_PROFILE";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["HAS_PUBLIC_PROFILE_ACCESS_VIA_ROLE"] = 261] = "HAS_PUBLIC_PROFILE_ACCESS_VIA_ROLE";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["DAYS_SINCE_LAST_CAMERA_PERM_DENY"] = 262] = "DAYS_SINCE_LAST_CAMERA_PERM_DENY";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["DAYS_SINCE_AD_ORG_JOIN"] = 263] = "DAYS_SINCE_AD_ORG_JOIN";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["DAYS_SINCE_FIRST_AD_CREATE"] = 264] = "DAYS_SINCE_FIRST_AD_CREATE";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["ORGANIZATION_COUNTRY"] = 265] = "ORGANIZATION_COUNTRY";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["DAYS_SINCE_FIRST_DWEB_VISIT"] = 266] = "DAYS_SINCE_FIRST_DWEB_VISIT";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["DAYS_SINCE_LAST_DWEB_VISIT"] = 267] = "DAYS_SINCE_LAST_DWEB_VISIT";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["WEEKS_SINCE_USING_DWEB"] = 268] = "WEEKS_SINCE_USING_DWEB";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["HAS_LENS"] = 269] = "HAS_LENS";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["BILLBOARD_SERVER_IMPRESSION_COUNT"] = 270] = "BILLBOARD_SERVER_IMPRESSION_COUNT";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["BILLBOARD_SERVER_CLICK_COUNT"] = 271] = "BILLBOARD_SERVER_CLICK_COUNT";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["BILLBOARD_SERVER_DISMISS_COUNT"] = 272] = "BILLBOARD_SERVER_DISMISS_COUNT";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["BILLBOARD_SERVER_INTERACTION_COUNT"] = 273] = "BILLBOARD_SERVER_INTERACTION_COUNT";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["BILLBOARD_SERVER_FIRST_IMPRESSION_TIME_SECS_TO_NOW"] = 274] = "BILLBOARD_SERVER_FIRST_IMPRESSION_TIME_SECS_TO_NOW";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["BILLBOARD_SERVER_LAST_IMPRESSION_TIME_SECS_TO_NOW"] = 275] = "BILLBOARD_SERVER_LAST_IMPRESSION_TIME_SECS_TO_NOW";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["BILLBOARD_SERVER_FIRST_CLICK_TIME_SECS_TO_NOW"] = 276] = "BILLBOARD_SERVER_FIRST_CLICK_TIME_SECS_TO_NOW";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["BILLBOARD_SERVER_LAST_CLICK_TIME_SECS_TO_NOW"] = 277] = "BILLBOARD_SERVER_LAST_CLICK_TIME_SECS_TO_NOW";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["BILLBOARD_SERVER_FIRST_DISMISS_TIME_SECS_TO_NOW"] = 278] = "BILLBOARD_SERVER_FIRST_DISMISS_TIME_SECS_TO_NOW";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["BILLBOARD_SERVER_LAST_DISMISS_TIME_SECS_TO_NOW"] = 279] = "BILLBOARD_SERVER_LAST_DISMISS_TIME_SECS_TO_NOW";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["BILLBOARD_SERVER_FIRST_INTERACTION_TIME_SECS_TO_NOW"] = 280] = "BILLBOARD_SERVER_FIRST_INTERACTION_TIME_SECS_TO_NOW";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["BILLBOARD_SERVER_LAST_INTERACTION_TIME_SECS_TO_NOW"] = 281] = "BILLBOARD_SERVER_LAST_INTERACTION_TIME_SECS_TO_NOW";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["BILLBOARD_SERVER_CONTINUOUS_DISMISS_COUNT"] = 282] = "BILLBOARD_SERVER_CONTINUOUS_DISMISS_COUNT";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["BILLBOARD_CAMPAIGN_LOCAL_FIRST_CLICK_TIME_SECS_TO_NOW"] = 283] = "BILLBOARD_CAMPAIGN_LOCAL_FIRST_CLICK_TIME_SECS_TO_NOW";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["BILLBOARD_CAMPAIGN_LOCAL_LAST_CLICK_TIME_SECS_TO_NOW"] = 284] = "BILLBOARD_CAMPAIGN_LOCAL_LAST_CLICK_TIME_SECS_TO_NOW";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["BILLBOARD_CAMPAIGN_LOCAL_FIRST_DISMISS_TIME_SECS_TO_NOW"] = 285] = "BILLBOARD_CAMPAIGN_LOCAL_FIRST_DISMISS_TIME_SECS_TO_NOW";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["BILLBOARD_CAMPAIGN_LOCAL_LAST_DISMISS_TIME_SECS_TO_NOW"] = 286] = "BILLBOARD_CAMPAIGN_LOCAL_LAST_DISMISS_TIME_SECS_TO_NOW";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["BILLBOARD_CAMPAIGN_LOCAL_FIRST_INTERACTION_TIME_SECS_TO_NOW"] = 287] = "BILLBOARD_CAMPAIGN_LOCAL_FIRST_INTERACTION_TIME_SECS_TO_NOW";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["DAYS_SINCE_FIRST_AD_SPEND"] = 288] = "DAYS_SINCE_FIRST_AD_SPEND";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["DAYS_SINCE_LAST_AD_SPEND"] = 289] = "DAYS_SINCE_LAST_AD_SPEND";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["SPOTLIGHT_2_PLUS_STORY_SESSION_7D_STATUS_DETAILED"] = 290] = "SPOTLIGHT_2_PLUS_STORY_SESSION_7D_STATUS_DETAILED";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["SPOTLIGHT_5_PLUS_STORY_SESSION_7D_STATUS_DETAILED"] = 291] = "SPOTLIGHT_5_PLUS_STORY_SESSION_7D_STATUS_DETAILED";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["SPOTLIGHT_STORY_VIEW_7D_STATUS_DETAILED"] = 292] = "SPOTLIGHT_STORY_VIEW_7D_STATUS_DETAILED";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["LAST_USER_ACCEPTED_TOS"] = 293] = "LAST_USER_ACCEPTED_TOS";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["UPDATED_DEVICE_CLUSTER"] = 294] = "UPDATED_DEVICE_CLUSTER";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["CREATOR_TIER"] = 295] = "CREATOR_TIER";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["AV1_SW_DECODER"] = 296] = "AV1_SW_DECODER";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["AV1_HW_DECODER"] = 297] = "AV1_HW_DECODER";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["HAS_EXPLICIT_PUBLIC_PROFILE"] = 298] = "HAS_EXPLICIT_PUBLIC_PROFILE";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["LARGER_TEXT_DISPLAY_OPTION_ENABLED"] = 299] = "LARGER_TEXT_DISPLAY_OPTION_ENABLED";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["IS_PUBLIC_POSTING_PREFERRED_USER"] = 300] = "IS_PUBLIC_POSTING_PREFERRED_USER";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["RUID"] = 301] = "RUID";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["MUTABLE_USERNAME"] = 302] = "MUTABLE_USERNAME";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["BUDGET_GROUP_ID"] = 303] = "BUDGET_GROUP_ID";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["AB_POPULATION_RANGE_HASH_FUNC"] = 304] = "AB_POPULATION_RANGE_HASH_FUNC";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["AB_TREATMENT_RANGE_HASH_FUNC"] = 305] = "AB_TREATMENT_RANGE_HASH_FUNC";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["REGISTRATION_IP_REGION"] = 306] = "REGISTRATION_IP_REGION";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["RUID_TYPE"] = 307] = "RUID_TYPE";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["PLUS_INTERNAL_ONLY"] = 308] = "PLUS_INTERNAL_ONLY";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["COF_ROLLOUT_RANGE_HASH_FUNC"] = 309] = "COF_ROLLOUT_RANGE_HASH_FUNC";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["HAS_AI_SELFIE"] = 341] = "HAS_AI_SELFIE";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["HAS_DREAMS"] = 342] = "HAS_DREAMS";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["DAYS_SINCE_LAST_ACTIVITY"] = 343] = "DAYS_SINCE_LAST_ACTIVITY";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["CONTACT_PERM_OS_GRANTED"] = 344] = "CONTACT_PERM_OS_GRANTED";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["CONTACT_PERM_USER_GRANTED"] = 345] = "CONTACT_PERM_USER_GRANTED";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["LENS_CLUSTER_GPU_V2"] = 346] = "LENS_CLUSTER_GPU_V2";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["CAN_ACCESS_ADS_TAB"] = 347] = "CAN_ACCESS_ADS_TAB";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["GOOGLE_CDN_POP"] = 348] = "GOOGLE_CDN_POP";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["NUM_STRONG_RELATIONSHIPS_V3"] = 349] = "NUM_STRONG_RELATIONSHIPS_V3";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["NUM_CLOSE_PLUS_RELATIONSHIPS_V3"] = 350] = "NUM_CLOSE_PLUS_RELATIONSHIPS_V3";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["NUM_ACQUAINTANCE_PLUS_RELATIONSHIPS_V3"] = 351] = "NUM_ACQUAINTANCE_PLUS_RELATIONSHIPS_V3";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["DREAMS_ENGAGEMENT_STATUS"] = 352] = "DREAMS_ENGAGEMENT_STATUS";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["IS_LOW_LIGHT"] = 353] = "IS_LOW_LIGHT";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["GALLERY_HAS_2023_YEAR_END_STORY"] = 354] = "GALLERY_HAS_2023_YEAR_END_STORY";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["CHUNK_UPLOAD_PREFERENCE"] = 355] = "CHUNK_UPLOAD_PREFERENCE";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(ClientTargetingExpression_Property || (ClientTargetingExpression_Property = {}));
var ClientTargetingExpression_PropertyMetadata_SignalToHash;
(function(ClientTargetingExpression_PropertyMetadata_SignalToHash2) {
  ClientTargetingExpression_PropertyMetadata_SignalToHash2[ClientTargetingExpression_PropertyMetadata_SignalToHash2["UNKNOWN_SIGNAL_TO_HASH"] = 0] = "UNKNOWN_SIGNAL_TO_HASH";
  ClientTargetingExpression_PropertyMetadata_SignalToHash2[ClientTargetingExpression_PropertyMetadata_SignalToHash2["HASH_SEED_AND_USER_ID"] = 1] = "HASH_SEED_AND_USER_ID";
  ClientTargetingExpression_PropertyMetadata_SignalToHash2[ClientTargetingExpression_PropertyMetadata_SignalToHash2["HASH_USER_ID_AND_NAMESPACE"] = 2] = "HASH_USER_ID_AND_NAMESPACE";
  ClientTargetingExpression_PropertyMetadata_SignalToHash2[ClientTargetingExpression_PropertyMetadata_SignalToHash2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(ClientTargetingExpression_PropertyMetadata_SignalToHash || (ClientTargetingExpression_PropertyMetadata_SignalToHash = {}));
function createBaseConfigResult() {
  return {
    configId: "",
    value: void 0,
    targetingExpression: void 0,
    ttlSeconds: "0",
    configRuleUuidBytes: new Uint8Array(),
    priority: 0,
    namespace: 0,
    studyName: "",
    experimentId: 0,
    delete: false,
    servePlatforms: [],
    sequenceId: 0,
    ruidType: 0,
    segmentOrdinal: 0,
    generatedFromAbAllowlists: false,
    internalFields: void 0
  };
}
var ConfigResult = {
  encode(message, writer = import_minimal15.default.Writer.create()) {
    if (message.configId !== "") {
      writer.uint32(10).string(message.configId);
    }
    if (message.value !== void 0) {
      Value.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    if (message.targetingExpression !== void 0) {
      ClientTargetingExpression.encode(message.targetingExpression, writer.uint32(26).fork()).ldelim();
    }
    if (message.ttlSeconds !== "0") {
      writer.uint32(32).int64(message.ttlSeconds);
    }
    if (message.configRuleUuidBytes.length !== 0) {
      writer.uint32(42).bytes(message.configRuleUuidBytes);
    }
    if (message.priority !== 0) {
      writer.uint32(48).int32(message.priority);
    }
    if (message.namespace !== 0) {
      writer.uint32(56).int32(message.namespace);
    }
    if (message.studyName !== "") {
      writer.uint32(66).string(message.studyName);
    }
    if (message.experimentId !== 0) {
      writer.uint32(72).int32(message.experimentId);
    }
    if (message.delete === true) {
      writer.uint32(80).bool(message.delete);
    }
    writer.uint32(90).fork();
    for (const v2 of message.servePlatforms) {
      writer.int32(v2);
    }
    writer.ldelim();
    if (message.sequenceId !== 0) {
      writer.uint32(96).int32(message.sequenceId);
    }
    if (message.ruidType !== 0) {
      writer.uint32(104).int32(message.ruidType);
    }
    if (message.segmentOrdinal !== 0) {
      writer.uint32(112).int32(message.segmentOrdinal);
    }
    if (message.generatedFromAbAllowlists === true) {
      writer.uint32(120).bool(message.generatedFromAbAllowlists);
    }
    if (message.internalFields !== void 0) {
      ConfigResult_InternalFields.encode(message.internalFields, writer.uint32(130).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal15.default.Reader ? input : new import_minimal15.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseConfigResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.configId = reader.string();
          break;
        case 2:
          message.value = Value.decode(reader, reader.uint32());
          break;
        case 3:
          message.targetingExpression = ClientTargetingExpression.decode(reader, reader.uint32());
          break;
        case 4:
          message.ttlSeconds = longToString7(reader.int64());
          break;
        case 5:
          message.configRuleUuidBytes = reader.bytes();
          break;
        case 6:
          message.priority = reader.int32();
          break;
        case 7:
          message.namespace = reader.int32();
          break;
        case 8:
          message.studyName = reader.string();
          break;
        case 9:
          message.experimentId = reader.int32();
          break;
        case 10:
          message.delete = reader.bool();
          break;
        case 11:
          if ((tag & 7) === 2) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.servePlatforms.push(reader.int32());
            }
          } else {
            message.servePlatforms.push(reader.int32());
          }
          break;
        case 12:
          message.sequenceId = reader.int32();
          break;
        case 13:
          message.ruidType = reader.int32();
          break;
        case 14:
          message.segmentOrdinal = reader.int32();
          break;
        case 15:
          message.generatedFromAbAllowlists = reader.bool();
          break;
        case 16:
          message.internalFields = ConfigResult_InternalFields.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(object) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o;
    const message = createBaseConfigResult();
    message.configId = (_a = object.configId) !== null && _a !== void 0 ? _a : "";
    message.value = object.value !== void 0 && object.value !== null ? Value.fromPartial(object.value) : void 0;
    message.targetingExpression = object.targetingExpression !== void 0 && object.targetingExpression !== null ? ClientTargetingExpression.fromPartial(object.targetingExpression) : void 0;
    message.ttlSeconds = (_b = object.ttlSeconds) !== null && _b !== void 0 ? _b : "0";
    message.configRuleUuidBytes = (_c = object.configRuleUuidBytes) !== null && _c !== void 0 ? _c : new Uint8Array();
    message.priority = (_d = object.priority) !== null && _d !== void 0 ? _d : 0;
    message.namespace = (_e = object.namespace) !== null && _e !== void 0 ? _e : 0;
    message.studyName = (_f = object.studyName) !== null && _f !== void 0 ? _f : "";
    message.experimentId = (_g = object.experimentId) !== null && _g !== void 0 ? _g : 0;
    message.delete = (_h = object.delete) !== null && _h !== void 0 ? _h : false;
    message.servePlatforms = ((_j = object.servePlatforms) === null || _j === void 0 ? void 0 : _j.map((e2) => e2)) || [];
    message.sequenceId = (_k = object.sequenceId) !== null && _k !== void 0 ? _k : 0;
    message.ruidType = (_l = object.ruidType) !== null && _l !== void 0 ? _l : 0;
    message.segmentOrdinal = (_m = object.segmentOrdinal) !== null && _m !== void 0 ? _m : 0;
    message.generatedFromAbAllowlists = (_o = object.generatedFromAbAllowlists) !== null && _o !== void 0 ? _o : false;
    message.internalFields = object.internalFields !== void 0 && object.internalFields !== null ? ConfigResult_InternalFields.fromPartial(object.internalFields) : void 0;
    return message;
  }
};
function createBaseConfigResult_InternalFields() {
  return {
    configBitmapIndex: 0,
    configResultBitmapIndex: 0,
    hasServerPropertiesOnly: false,
    globalPriority: 0,
    sequenceIds: [],
    studySegmentOrdinal: 0,
    experimentGuid: "0",
    isAbStudyStatusCompleted: false
  };
}
var ConfigResult_InternalFields = {
  encode(message, writer = import_minimal15.default.Writer.create()) {
    if (message.configBitmapIndex !== 0) {
      writer.uint32(8).int32(message.configBitmapIndex);
    }
    if (message.configResultBitmapIndex !== 0) {
      writer.uint32(16).int32(message.configResultBitmapIndex);
    }
    if (message.hasServerPropertiesOnly === true) {
      writer.uint32(24).bool(message.hasServerPropertiesOnly);
    }
    if (message.globalPriority !== 0) {
      writer.uint32(32).int32(message.globalPriority);
    }
    for (const v2 of message.sequenceIds) {
      ConfigResult_InternalFields_SequenceIdCandidate.encode(v2, writer.uint32(42).fork()).ldelim();
    }
    if (message.studySegmentOrdinal !== 0) {
      writer.uint32(48).int32(message.studySegmentOrdinal);
    }
    if (message.experimentGuid !== "0") {
      writer.uint32(56).uint64(message.experimentGuid);
    }
    if (message.isAbStudyStatusCompleted === true) {
      writer.uint32(64).bool(message.isAbStudyStatusCompleted);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal15.default.Reader ? input : new import_minimal15.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseConfigResult_InternalFields();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.configBitmapIndex = reader.int32();
          break;
        case 2:
          message.configResultBitmapIndex = reader.int32();
          break;
        case 3:
          message.hasServerPropertiesOnly = reader.bool();
          break;
        case 4:
          message.globalPriority = reader.int32();
          break;
        case 5:
          message.sequenceIds.push(ConfigResult_InternalFields_SequenceIdCandidate.decode(reader, reader.uint32()));
          break;
        case 6:
          message.studySegmentOrdinal = reader.int32();
          break;
        case 7:
          message.experimentGuid = longToString7(reader.uint64());
          break;
        case 8:
          message.isAbStudyStatusCompleted = reader.bool();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(object) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    const message = createBaseConfigResult_InternalFields();
    message.configBitmapIndex = (_a = object.configBitmapIndex) !== null && _a !== void 0 ? _a : 0;
    message.configResultBitmapIndex = (_b = object.configResultBitmapIndex) !== null && _b !== void 0 ? _b : 0;
    message.hasServerPropertiesOnly = (_c = object.hasServerPropertiesOnly) !== null && _c !== void 0 ? _c : false;
    message.globalPriority = (_d = object.globalPriority) !== null && _d !== void 0 ? _d : 0;
    message.sequenceIds = ((_e = object.sequenceIds) === null || _e === void 0 ? void 0 : _e.map((e2) => ConfigResult_InternalFields_SequenceIdCandidate.fromPartial(e2))) || [];
    message.studySegmentOrdinal = (_f = object.studySegmentOrdinal) !== null && _f !== void 0 ? _f : 0;
    message.experimentGuid = (_g = object.experimentGuid) !== null && _g !== void 0 ? _g : "0";
    message.isAbStudyStatusCompleted = (_h = object.isAbStudyStatusCompleted) !== null && _h !== void 0 ? _h : false;
    return message;
  }
};
function createBaseConfigResult_InternalFields_SequenceIdCandidate() {
  return { targetingExpression: void 0, sequenceId: 0 };
}
var ConfigResult_InternalFields_SequenceIdCandidate = {
  encode(message, writer = import_minimal15.default.Writer.create()) {
    if (message.targetingExpression !== void 0) {
      ClientTargetingExpression.encode(message.targetingExpression, writer.uint32(10).fork()).ldelim();
    }
    if (message.sequenceId !== 0) {
      writer.uint32(16).int32(message.sequenceId);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal15.default.Reader ? input : new import_minimal15.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseConfigResult_InternalFields_SequenceIdCandidate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.targetingExpression = ClientTargetingExpression.decode(reader, reader.uint32());
          break;
        case 2:
          message.sequenceId = reader.int32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(object) {
    var _a;
    const message = createBaseConfigResult_InternalFields_SequenceIdCandidate();
    message.targetingExpression = object.targetingExpression !== void 0 && object.targetingExpression !== null ? ClientTargetingExpression.fromPartial(object.targetingExpression) : void 0;
    message.sequenceId = (_a = object.sequenceId) !== null && _a !== void 0 ? _a : 0;
    return message;
  }
};
function createBaseClientTargetingExpression() {
  return {
    operator: 0,
    children: [],
    property: 0,
    predicateOperator: 0,
    value: void 0,
    propertyMetadata: void 0
  };
}
var ClientTargetingExpression = {
  encode(message, writer = import_minimal15.default.Writer.create()) {
    if (message.operator !== 0) {
      writer.uint32(8).int32(message.operator);
    }
    for (const v2 of message.children) {
      ClientTargetingExpression.encode(v2, writer.uint32(18).fork()).ldelim();
    }
    if (message.property !== 0) {
      writer.uint32(24).int32(message.property);
    }
    if (message.predicateOperator !== 0) {
      writer.uint32(32).int32(message.predicateOperator);
    }
    if (message.value !== void 0) {
      Value.encode(message.value, writer.uint32(42).fork()).ldelim();
    }
    if (message.propertyMetadata !== void 0) {
      ClientTargetingExpression_PropertyMetadata.encode(message.propertyMetadata, writer.uint32(50).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal15.default.Reader ? input : new import_minimal15.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseClientTargetingExpression();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.operator = reader.int32();
          break;
        case 2:
          message.children.push(ClientTargetingExpression.decode(reader, reader.uint32()));
          break;
        case 3:
          message.property = reader.int32();
          break;
        case 4:
          message.predicateOperator = reader.int32();
          break;
        case 5:
          message.value = Value.decode(reader, reader.uint32());
          break;
        case 6:
          message.propertyMetadata = ClientTargetingExpression_PropertyMetadata.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(object) {
    var _a, _b, _c, _d;
    const message = createBaseClientTargetingExpression();
    message.operator = (_a = object.operator) !== null && _a !== void 0 ? _a : 0;
    message.children = ((_b = object.children) === null || _b === void 0 ? void 0 : _b.map((e2) => ClientTargetingExpression.fromPartial(e2))) || [];
    message.property = (_c = object.property) !== null && _c !== void 0 ? _c : 0;
    message.predicateOperator = (_d = object.predicateOperator) !== null && _d !== void 0 ? _d : 0;
    message.value = object.value !== void 0 && object.value !== null ? Value.fromPartial(object.value) : void 0;
    message.propertyMetadata = object.propertyMetadata !== void 0 && object.propertyMetadata !== null ? ClientTargetingExpression_PropertyMetadata.fromPartial(object.propertyMetadata) : void 0;
    return message;
  }
};
function createBaseClientTargetingExpression_PropertyMetadata() {
  return {
    itemId: 0,
    signalToHash: 0,
    abNamespaceForHashing: "",
    abSeedForHashing: "",
    ruidType: void 0,
    cofRolloutSeedForHashing: ""
  };
}
var ClientTargetingExpression_PropertyMetadata = {
  encode(message, writer = import_minimal15.default.Writer.create()) {
    if (message.itemId !== 0) {
      writer.uint32(8).int32(message.itemId);
    }
    if (message.signalToHash !== 0) {
      writer.uint32(16).int32(message.signalToHash);
    }
    if (message.abNamespaceForHashing !== "") {
      writer.uint32(26).string(message.abNamespaceForHashing);
    }
    if (message.abSeedForHashing !== "") {
      writer.uint32(34).string(message.abSeedForHashing);
    }
    if (message.ruidType !== void 0) {
      writer.uint32(40).int32(message.ruidType);
    }
    if (message.cofRolloutSeedForHashing !== "") {
      writer.uint32(50).string(message.cofRolloutSeedForHashing);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal15.default.Reader ? input : new import_minimal15.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseClientTargetingExpression_PropertyMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.itemId = reader.int32();
          break;
        case 2:
          message.signalToHash = reader.int32();
          break;
        case 3:
          message.abNamespaceForHashing = reader.string();
          break;
        case 4:
          message.abSeedForHashing = reader.string();
          break;
        case 5:
          message.ruidType = reader.int32();
          break;
        case 6:
          message.cofRolloutSeedForHashing = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(object) {
    var _a, _b, _c, _d, _e, _f;
    const message = createBaseClientTargetingExpression_PropertyMetadata();
    message.itemId = (_a = object.itemId) !== null && _a !== void 0 ? _a : 0;
    message.signalToHash = (_b = object.signalToHash) !== null && _b !== void 0 ? _b : 0;
    message.abNamespaceForHashing = (_c = object.abNamespaceForHashing) !== null && _c !== void 0 ? _c : "";
    message.abSeedForHashing = (_d = object.abSeedForHashing) !== null && _d !== void 0 ? _d : "";
    message.ruidType = (_e = object.ruidType) !== null && _e !== void 0 ? _e : void 0;
    message.cofRolloutSeedForHashing = (_f = object.cofRolloutSeedForHashing) !== null && _f !== void 0 ? _f : "";
    return message;
  }
};
function longToString7(long) {
  return long.toString();
}
if (import_minimal15.default.util.Long !== import_long15.default) {
  import_minimal15.default.util.Long = import_long15.default;
  import_minimal15.default.configure();
}

// node_modules/@snap/camera-kit/dist/generated-proto/pb_schema/cdp/cof/config_response.js
function createBaseConfigTargetingResponseDebugData() {
  return { abResultChecksumInput: "" };
}
var ConfigTargetingResponseDebugData = {
  encode(message, writer = import_minimal16.default.Writer.create()) {
    if (message.abResultChecksumInput !== "") {
      writer.uint32(10).string(message.abResultChecksumInput);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal16.default.Reader ? input : new import_minimal16.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseConfigTargetingResponseDebugData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.abResultChecksumInput = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(object) {
    var _a;
    const message = createBaseConfigTargetingResponseDebugData();
    message.abResultChecksumInput = (_a = object.abResultChecksumInput) !== null && _a !== void 0 ? _a : "";
    return message;
  }
};
function createBaseConfigTargetingResponse() {
  return {
    configResults: [],
    configResultsEtag: "",
    benchmarkRequest: void 0,
    fullResults: false,
    abResultChecksum: 0,
    iso3166Alpha2CountryCodeFromRequestIp: "",
    debugData: void 0
  };
}
var ConfigTargetingResponse = {
  encode(message, writer = import_minimal16.default.Writer.create()) {
    for (const v2 of message.configResults) {
      ConfigResult.encode(v2, writer.uint32(10).fork()).ldelim();
    }
    if (message.configResultsEtag !== "") {
      writer.uint32(18).string(message.configResultsEtag);
    }
    if (message.benchmarkRequest !== void 0) {
      BenchmarkRequest.encode(message.benchmarkRequest, writer.uint32(26).fork()).ldelim();
    }
    if (message.fullResults === true) {
      writer.uint32(32).bool(message.fullResults);
    }
    if (message.abResultChecksum !== 0) {
      writer.uint32(40).int32(message.abResultChecksum);
    }
    if (message.iso3166Alpha2CountryCodeFromRequestIp !== "") {
      writer.uint32(50).string(message.iso3166Alpha2CountryCodeFromRequestIp);
    }
    if (message.debugData !== void 0) {
      ConfigTargetingResponseDebugData.encode(message.debugData, writer.uint32(58).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal16.default.Reader ? input : new import_minimal16.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseConfigTargetingResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.configResults.push(ConfigResult.decode(reader, reader.uint32()));
          break;
        case 2:
          message.configResultsEtag = reader.string();
          break;
        case 3:
          message.benchmarkRequest = BenchmarkRequest.decode(reader, reader.uint32());
          break;
        case 4:
          message.fullResults = reader.bool();
          break;
        case 5:
          message.abResultChecksum = reader.int32();
          break;
        case 6:
          message.iso3166Alpha2CountryCodeFromRequestIp = reader.string();
          break;
        case 7:
          message.debugData = ConfigTargetingResponseDebugData.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(object) {
    var _a, _b, _c, _d, _e;
    const message = createBaseConfigTargetingResponse();
    message.configResults = ((_a = object.configResults) === null || _a === void 0 ? void 0 : _a.map((e2) => ConfigResult.fromPartial(e2))) || [];
    message.configResultsEtag = (_b = object.configResultsEtag) !== null && _b !== void 0 ? _b : "";
    message.benchmarkRequest = object.benchmarkRequest !== void 0 && object.benchmarkRequest !== null ? BenchmarkRequest.fromPartial(object.benchmarkRequest) : void 0;
    message.fullResults = (_c = object.fullResults) !== null && _c !== void 0 ? _c : false;
    message.abResultChecksum = (_d = object.abResultChecksum) !== null && _d !== void 0 ? _d : 0;
    message.iso3166Alpha2CountryCodeFromRequestIp = (_e = object.iso3166Alpha2CountryCodeFromRequestIp) !== null && _e !== void 0 ? _e : "";
    message.debugData = object.debugData !== void 0 && object.debugData !== null ? ConfigTargetingResponseDebugData.fromPartial(object.debugData) : void 0;
    return message;
  }
};
if (import_minimal16.default.util.Long !== import_long16.default) {
  import_minimal16.default.util.Long = import_long16.default;
  import_minimal16.default.configure();
}

// node_modules/@snap/camera-kit/dist/generated-proto/pb_schema/cdp/cof/circumstance_service.js
var import_browser_headers = __toESM(require_browser_headers_umd());

// node_modules/@snap/camera-kit/dist/generated-proto/pb_schema/cdp/cof/debug_info.js
var import_long17 = __toESM(require_long());
var import_minimal17 = __toESM(require_minimal2());
var AbStep;
(function(AbStep2) {
  AbStep2[AbStep2["USER_WHITELISTED"] = 0] = "USER_WHITELISTED";
  AbStep2[AbStep2["USER_GROUP_WHITELISTED"] = 1] = "USER_GROUP_WHITELISTED";
  AbStep2[AbStep2["FILTER_CONDITIONS"] = 2] = "FILTER_CONDITIONS";
  AbStep2[AbStep2["SLICE_RANGE"] = 3] = "SLICE_RANGE";
  AbStep2[AbStep2["TRAFFIC_ALLOCATED"] = 4] = "TRAFFIC_ALLOCATED";
  AbStep2[AbStep2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(AbStep || (AbStep = {}));
var CofStep;
(function(CofStep2) {
  CofStep2[CofStep2["VALIDATE_REQUEST"] = 0] = "VALIDATE_REQUEST";
  CofStep2[CofStep2["REQUEST_ATLAS"] = 1] = "REQUEST_ATLAS";
  CofStep2[CofStep2["BUILD_TARGETING_INFO"] = 2] = "BUILD_TARGETING_INFO";
  CofStep2[CofStep2["QUERY_INDEX"] = 3] = "QUERY_INDEX";
  CofStep2[CofStep2["REQUEST_AB"] = 4] = "REQUEST_AB";
  CofStep2[CofStep2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(CofStep || (CofStep = {}));
function createBaseAbStepInfo() {
  return { abStep: 0, info: "" };
}
var AbStepInfo = {
  encode(message, writer = import_minimal17.default.Writer.create()) {
    if (message.abStep !== 0) {
      writer.uint32(8).int32(message.abStep);
    }
    if (message.info !== "") {
      writer.uint32(18).string(message.info);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal17.default.Reader ? input : new import_minimal17.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAbStepInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.abStep = reader.int32();
          break;
        case 2:
          message.info = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(object) {
    var _a, _b;
    const message = createBaseAbStepInfo();
    message.abStep = (_a = object.abStep) !== null && _a !== void 0 ? _a : 0;
    message.info = (_b = object.info) !== null && _b !== void 0 ? _b : "";
    return message;
  }
};
function createBaseCofStepInfo() {
  return { cofStep: 0, info: "" };
}
var CofStepInfo = {
  encode(message, writer = import_minimal17.default.Writer.create()) {
    if (message.cofStep !== 0) {
      writer.uint32(8).int32(message.cofStep);
    }
    if (message.info !== "") {
      writer.uint32(18).string(message.info);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal17.default.Reader ? input : new import_minimal17.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseCofStepInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.cofStep = reader.int32();
          break;
        case 2:
          message.info = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(object) {
    var _a, _b;
    const message = createBaseCofStepInfo();
    message.cofStep = (_a = object.cofStep) !== null && _a !== void 0 ? _a : 0;
    message.info = (_b = object.info) !== null && _b !== void 0 ? _b : "";
    return message;
  }
};
function createBaseDebugTrace() {
  return { lastCofStep: void 0, lastAbStep: void 0, budgetGroupId: 0 };
}
var DebugTrace = {
  encode(message, writer = import_minimal17.default.Writer.create()) {
    if (message.lastCofStep !== void 0) {
      CofStepInfo.encode(message.lastCofStep, writer.uint32(10).fork()).ldelim();
    }
    if (message.lastAbStep !== void 0) {
      AbStepInfo.encode(message.lastAbStep, writer.uint32(18).fork()).ldelim();
    }
    if (message.budgetGroupId !== 0) {
      writer.uint32(24).uint32(message.budgetGroupId);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal17.default.Reader ? input : new import_minimal17.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseDebugTrace();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.lastCofStep = CofStepInfo.decode(reader, reader.uint32());
          break;
        case 2:
          message.lastAbStep = AbStepInfo.decode(reader, reader.uint32());
          break;
        case 3:
          message.budgetGroupId = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(object) {
    var _a;
    const message = createBaseDebugTrace();
    message.lastCofStep = object.lastCofStep !== void 0 && object.lastCofStep !== null ? CofStepInfo.fromPartial(object.lastCofStep) : void 0;
    message.lastAbStep = object.lastAbStep !== void 0 && object.lastAbStep !== null ? AbStepInfo.fromPartial(object.lastAbStep) : void 0;
    message.budgetGroupId = (_a = object.budgetGroupId) !== null && _a !== void 0 ? _a : 0;
    return message;
  }
};
if (import_minimal17.default.util.Long !== import_long17.default) {
  import_minimal17.default.util.Long = import_long17.default;
  import_minimal17.default.configure();
}

// node_modules/@snap/camera-kit/dist/generated-proto/pb_schema/cdp/cof/circumstance_service.js
function createBaseGetAbConfigValuesRequest() {
  return {
    configNames: [],
    namespaces: [],
    cofConfigNames: [],
    includeAllConfigs: false,
    disableExposureLogging: false,
    enableDebug: false
  };
}
var GetAbConfigValuesRequest = {
  encode(message, writer = import_minimal18.default.Writer.create()) {
    for (const v2 of message.configNames) {
      writer.uint32(10).string(v2);
    }
    writer.uint32(18).fork();
    for (const v2 of message.namespaces) {
      writer.int32(v2);
    }
    writer.ldelim();
    for (const v2 of message.cofConfigNames) {
      writer.uint32(26).string(v2);
    }
    if (message.includeAllConfigs === true) {
      writer.uint32(32).bool(message.includeAllConfigs);
    }
    if (message.disableExposureLogging === true) {
      writer.uint32(40).bool(message.disableExposureLogging);
    }
    if (message.enableDebug === true) {
      writer.uint32(104).bool(message.enableDebug);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal18.default.Reader ? input : new import_minimal18.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetAbConfigValuesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.configNames.push(reader.string());
          break;
        case 2:
          if ((tag & 7) === 2) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.namespaces.push(reader.int32());
            }
          } else {
            message.namespaces.push(reader.int32());
          }
          break;
        case 3:
          message.cofConfigNames.push(reader.string());
          break;
        case 4:
          message.includeAllConfigs = reader.bool();
          break;
        case 5:
          message.disableExposureLogging = reader.bool();
          break;
        case 13:
          message.enableDebug = reader.bool();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(object) {
    var _a, _b, _c, _d, _e, _f;
    const message = createBaseGetAbConfigValuesRequest();
    message.configNames = ((_a = object.configNames) === null || _a === void 0 ? void 0 : _a.map((e2) => e2)) || [];
    message.namespaces = ((_b = object.namespaces) === null || _b === void 0 ? void 0 : _b.map((e2) => e2)) || [];
    message.cofConfigNames = ((_c = object.cofConfigNames) === null || _c === void 0 ? void 0 : _c.map((e2) => e2)) || [];
    message.includeAllConfigs = (_d = object.includeAllConfigs) !== null && _d !== void 0 ? _d : false;
    message.disableExposureLogging = (_e = object.disableExposureLogging) !== null && _e !== void 0 ? _e : false;
    message.enableDebug = (_f = object.enableDebug) !== null && _f !== void 0 ? _f : false;
    return message;
  }
};
function createBaseGetAbConfigValuesResponse() {
  return { configResults: [], debugTrace: void 0 };
}
var GetAbConfigValuesResponse = {
  encode(message, writer = import_minimal18.default.Writer.create()) {
    for (const v2 of message.configResults) {
      ConfigResult.encode(v2, writer.uint32(10).fork()).ldelim();
    }
    if (message.debugTrace !== void 0) {
      DebugTrace.encode(message.debugTrace, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal18.default.Reader ? input : new import_minimal18.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetAbConfigValuesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.configResults.push(ConfigResult.decode(reader, reader.uint32()));
          break;
        case 2:
          message.debugTrace = DebugTrace.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(object) {
    var _a;
    const message = createBaseGetAbConfigValuesResponse();
    message.configResults = ((_a = object.configResults) === null || _a === void 0 ? void 0 : _a.map((e2) => ConfigResult.fromPartial(e2))) || [];
    message.debugTrace = object.debugTrace !== void 0 && object.debugTrace !== null ? DebugTrace.fromPartial(object.debugTrace) : void 0;
    return message;
  }
};
function createBaseConfigSetGenerationRequest() {
  return { targetingParameters: void 0, overrides: [] };
}
var ConfigSetGenerationRequest = {
  encode(message, writer = import_minimal18.default.Writer.create()) {
    if (message.targetingParameters !== void 0) {
      ConfigTargetingRequest.encode(message.targetingParameters, writer.uint32(10).fork()).ldelim();
    }
    for (const v2 of message.overrides) {
      ConfigResult.encode(v2, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal18.default.Reader ? input : new import_minimal18.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseConfigSetGenerationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.targetingParameters = ConfigTargetingRequest.decode(reader, reader.uint32());
          break;
        case 2:
          message.overrides.push(ConfigResult.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(object) {
    var _a;
    const message = createBaseConfigSetGenerationRequest();
    message.targetingParameters = object.targetingParameters !== void 0 && object.targetingParameters !== null ? ConfigTargetingRequest.fromPartial(object.targetingParameters) : void 0;
    message.overrides = ((_a = object.overrides) === null || _a === void 0 ? void 0 : _a.map((e2) => ConfigResult.fromPartial(e2))) || [];
    return message;
  }
};
function createBaseConfigSetGenerationResponse() {
  return { targetingResponse: void 0 };
}
var ConfigSetGenerationResponse = {
  encode(message, writer = import_minimal18.default.Writer.create()) {
    if (message.targetingResponse !== void 0) {
      ConfigTargetingResponse.encode(message.targetingResponse, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal18.default.Reader ? input : new import_minimal18.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseConfigSetGenerationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.targetingResponse = ConfigTargetingResponse.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(object) {
    const message = createBaseConfigSetGenerationResponse();
    message.targetingResponse = object.targetingResponse !== void 0 && object.targetingResponse !== null ? ConfigTargetingResponse.fromPartial(object.targetingResponse) : void 0;
    return message;
  }
};
function createBasePinConfigRequest() {
  return { configSetToken: "", userId: "", ttlSeconds: 0 };
}
var PinConfigRequest = {
  encode(message, writer = import_minimal18.default.Writer.create()) {
    if (message.configSetToken !== "") {
      writer.uint32(10).string(message.configSetToken);
    }
    if (message.userId !== "") {
      writer.uint32(18).string(message.userId);
    }
    if (message.ttlSeconds !== 0) {
      writer.uint32(24).int32(message.ttlSeconds);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal18.default.Reader ? input : new import_minimal18.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBasePinConfigRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.configSetToken = reader.string();
          break;
        case 2:
          message.userId = reader.string();
          break;
        case 3:
          message.ttlSeconds = reader.int32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(object) {
    var _a, _b, _c;
    const message = createBasePinConfigRequest();
    message.configSetToken = (_a = object.configSetToken) !== null && _a !== void 0 ? _a : "";
    message.userId = (_b = object.userId) !== null && _b !== void 0 ? _b : "";
    message.ttlSeconds = (_c = object.ttlSeconds) !== null && _c !== void 0 ? _c : 0;
    return message;
  }
};
function createBasePinConfigResponse() {
  return { debug: "" };
}
var PinConfigResponse = {
  encode(message, writer = import_minimal18.default.Writer.create()) {
    if (message.debug !== "") {
      writer.uint32(10).string(message.debug);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal18.default.Reader ? input : new import_minimal18.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBasePinConfigResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.debug = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(object) {
    var _a;
    const message = createBasePinConfigResponse();
    message.debug = (_a = object.debug) !== null && _a !== void 0 ? _a : "";
    return message;
  }
};
function createBaseUnpinConfigRequest() {
  return { configSetToken: "", userId: "" };
}
var UnpinConfigRequest = {
  encode(message, writer = import_minimal18.default.Writer.create()) {
    if (message.configSetToken !== "") {
      writer.uint32(10).string(message.configSetToken);
    }
    if (message.userId !== "") {
      writer.uint32(18).string(message.userId);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal18.default.Reader ? input : new import_minimal18.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseUnpinConfigRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.configSetToken = reader.string();
          break;
        case 2:
          message.userId = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(object) {
    var _a, _b;
    const message = createBaseUnpinConfigRequest();
    message.configSetToken = (_a = object.configSetToken) !== null && _a !== void 0 ? _a : "";
    message.userId = (_b = object.userId) !== null && _b !== void 0 ? _b : "";
    return message;
  }
};
function createBaseUnpinConfigResponse() {
  return { debug: "" };
}
var UnpinConfigResponse = {
  encode(message, writer = import_minimal18.default.Writer.create()) {
    if (message.debug !== "") {
      writer.uint32(10).string(message.debug);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal18.default.Reader ? input : new import_minimal18.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseUnpinConfigResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.debug = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(object) {
    var _a;
    const message = createBaseUnpinConfigResponse();
    message.debug = (_a = object.debug) !== null && _a !== void 0 ? _a : "";
    return message;
  }
};
function createBaseConfigWithNamespace() {
  return { configName: "", namespace: 0 };
}
var ConfigWithNamespace = {
  encode(message, writer = import_minimal18.default.Writer.create()) {
    if (message.configName !== "") {
      writer.uint32(10).string(message.configName);
    }
    if (message.namespace !== 0) {
      writer.uint32(16).int32(message.namespace);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal18.default.Reader ? input : new import_minimal18.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseConfigWithNamespace();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.configName = reader.string();
          break;
        case 2:
          message.namespace = reader.int32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(object) {
    var _a, _b;
    const message = createBaseConfigWithNamespace();
    message.configName = (_a = object.configName) !== null && _a !== void 0 ? _a : "";
    message.namespace = (_b = object.namespace) !== null && _b !== void 0 ? _b : 0;
    return message;
  }
};
function createBaseGetConfigValuesByTokenRequest() {
  return { token: "", configNames: [], namespaces: [], disableExposureLogging: false, getAllConfigs: false };
}
var GetConfigValuesByTokenRequest = {
  encode(message, writer = import_minimal18.default.Writer.create()) {
    if (message.token !== "") {
      writer.uint32(10).string(message.token);
    }
    for (const v2 of message.configNames) {
      ConfigWithNamespace.encode(v2, writer.uint32(18).fork()).ldelim();
    }
    writer.uint32(26).fork();
    for (const v2 of message.namespaces) {
      writer.int32(v2);
    }
    writer.ldelim();
    if (message.disableExposureLogging === true) {
      writer.uint32(32).bool(message.disableExposureLogging);
    }
    if (message.getAllConfigs === true) {
      writer.uint32(40).bool(message.getAllConfigs);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal18.default.Reader ? input : new import_minimal18.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetConfigValuesByTokenRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.token = reader.string();
          break;
        case 2:
          message.configNames.push(ConfigWithNamespace.decode(reader, reader.uint32()));
          break;
        case 3:
          if ((tag & 7) === 2) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.namespaces.push(reader.int32());
            }
          } else {
            message.namespaces.push(reader.int32());
          }
          break;
        case 4:
          message.disableExposureLogging = reader.bool();
          break;
        case 5:
          message.getAllConfigs = reader.bool();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(object) {
    var _a, _b, _c, _d, _e;
    const message = createBaseGetConfigValuesByTokenRequest();
    message.token = (_a = object.token) !== null && _a !== void 0 ? _a : "";
    message.configNames = ((_b = object.configNames) === null || _b === void 0 ? void 0 : _b.map((e2) => ConfigWithNamespace.fromPartial(e2))) || [];
    message.namespaces = ((_c = object.namespaces) === null || _c === void 0 ? void 0 : _c.map((e2) => e2)) || [];
    message.disableExposureLogging = (_d = object.disableExposureLogging) !== null && _d !== void 0 ? _d : false;
    message.getAllConfigs = (_e = object.getAllConfigs) !== null && _e !== void 0 ? _e : false;
    return message;
  }
};
function createBaseGetConfigValuesByTokenResponse() {
  return { configResults: [] };
}
var GetConfigValuesByTokenResponse = {
  encode(message, writer = import_minimal18.default.Writer.create()) {
    for (const v2 of message.configResults) {
      ConfigResult.encode(v2, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal18.default.Reader ? input : new import_minimal18.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetConfigValuesByTokenResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.configResults.push(ConfigResult.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(object) {
    var _a;
    const message = createBaseGetConfigValuesByTokenResponse();
    message.configResults = ((_a = object.configResults) === null || _a === void 0 ? void 0 : _a.map((e2) => ConfigResult.fromPartial(e2))) || [];
    return message;
  }
};
function createBaseGetCachedConfigResultSequenceIdsRequest() {
  return {};
}
var GetCachedConfigResultSequenceIdsRequest = {
  encode(_, writer = import_minimal18.default.Writer.create()) {
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal18.default.Reader ? input : new import_minimal18.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetCachedConfigResultSequenceIdsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(_) {
    const message = createBaseGetCachedConfigResultSequenceIdsRequest();
    return message;
  }
};
function createBaseGetCachedConfigResultSequenceIdsResponse() {
  return { serializedBitmap: new Uint8Array() };
}
var GetCachedConfigResultSequenceIdsResponse = {
  encode(message, writer = import_minimal18.default.Writer.create()) {
    if (message.serializedBitmap.length !== 0) {
      writer.uint32(10).bytes(message.serializedBitmap);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal18.default.Reader ? input : new import_minimal18.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetCachedConfigResultSequenceIdsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.serializedBitmap = reader.bytes();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(object) {
    var _a;
    const message = createBaseGetCachedConfigResultSequenceIdsResponse();
    message.serializedBitmap = (_a = object.serializedBitmap) !== null && _a !== void 0 ? _a : new Uint8Array();
    return message;
  }
};
function createBaseGetConfigResultsBySequenceIdsRequest() {
  return { sequenceIds: [] };
}
var GetConfigResultsBySequenceIdsRequest = {
  encode(message, writer = import_minimal18.default.Writer.create()) {
    writer.uint32(10).fork();
    for (const v2 of message.sequenceIds) {
      writer.int32(v2);
    }
    writer.ldelim();
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal18.default.Reader ? input : new import_minimal18.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetConfigResultsBySequenceIdsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if ((tag & 7) === 2) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.sequenceIds.push(reader.int32());
            }
          } else {
            message.sequenceIds.push(reader.int32());
          }
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(object) {
    var _a;
    const message = createBaseGetConfigResultsBySequenceIdsRequest();
    message.sequenceIds = ((_a = object.sequenceIds) === null || _a === void 0 ? void 0 : _a.map((e2) => e2)) || [];
    return message;
  }
};
function createBaseConfigResultWithSequenceId() {
  return { sequenceId: 0, configResult: void 0 };
}
var ConfigResultWithSequenceId = {
  encode(message, writer = import_minimal18.default.Writer.create()) {
    if (message.sequenceId !== 0) {
      writer.uint32(8).int32(message.sequenceId);
    }
    if (message.configResult !== void 0) {
      ConfigResult.encode(message.configResult, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal18.default.Reader ? input : new import_minimal18.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseConfigResultWithSequenceId();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.sequenceId = reader.int32();
          break;
        case 2:
          message.configResult = ConfigResult.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(object) {
    var _a;
    const message = createBaseConfigResultWithSequenceId();
    message.sequenceId = (_a = object.sequenceId) !== null && _a !== void 0 ? _a : 0;
    message.configResult = object.configResult !== void 0 && object.configResult !== null ? ConfigResult.fromPartial(object.configResult) : void 0;
    return message;
  }
};
function createBaseGetConfigResultsBySequenceIdsResponse() {
  return { configResultWithSequenceIds: [] };
}
var GetConfigResultsBySequenceIdsResponse = {
  encode(message, writer = import_minimal18.default.Writer.create()) {
    for (const v2 of message.configResultWithSequenceIds) {
      ConfigResultWithSequenceId.encode(v2, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal18.default.Reader ? input : new import_minimal18.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetConfigResultsBySequenceIdsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.configResultWithSequenceIds.push(ConfigResultWithSequenceId.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(object) {
    var _a;
    const message = createBaseGetConfigResultsBySequenceIdsResponse();
    message.configResultWithSequenceIds = ((_a = object.configResultWithSequenceIds) === null || _a === void 0 ? void 0 : _a.map((e2) => ConfigResultWithSequenceId.fromPartial(e2))) || [];
    return message;
  }
};
function createBaseGetBitmapByTokenRequest() {
  return { token: "" };
}
var GetBitmapByTokenRequest = {
  encode(message, writer = import_minimal18.default.Writer.create()) {
    if (message.token !== "") {
      writer.uint32(10).string(message.token);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal18.default.Reader ? input : new import_minimal18.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetBitmapByTokenRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.token = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(object) {
    var _a;
    const message = createBaseGetBitmapByTokenRequest();
    message.token = (_a = object.token) !== null && _a !== void 0 ? _a : "";
    return message;
  }
};
function createBaseGetBitmapByTokenResponse() {
  return { idBitmap: new Uint8Array() };
}
var GetBitmapByTokenResponse = {
  encode(message, writer = import_minimal18.default.Writer.create()) {
    if (message.idBitmap.length !== 0) {
      writer.uint32(10).bytes(message.idBitmap);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal18.default.Reader ? input : new import_minimal18.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetBitmapByTokenResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.idBitmap = reader.bytes();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(object) {
    var _a;
    const message = createBaseGetBitmapByTokenResponse();
    message.idBitmap = (_a = object.idBitmap) !== null && _a !== void 0 ? _a : new Uint8Array();
    return message;
  }
};
function createBaseGetUnevaluatedConfigResultsWithAbTargetingRequest() {
  return { namespaces: [], edgeConfigClientVersion: "" };
}
var GetUnevaluatedConfigResultsWithAbTargetingRequest = {
  encode(message, writer = import_minimal18.default.Writer.create()) {
    writer.uint32(10).fork();
    for (const v2 of message.namespaces) {
      writer.int32(v2);
    }
    writer.ldelim();
    if (message.edgeConfigClientVersion !== "") {
      writer.uint32(18).string(message.edgeConfigClientVersion);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal18.default.Reader ? input : new import_minimal18.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetUnevaluatedConfigResultsWithAbTargetingRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if ((tag & 7) === 2) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.namespaces.push(reader.int32());
            }
          } else {
            message.namespaces.push(reader.int32());
          }
          break;
        case 2:
          message.edgeConfigClientVersion = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(object) {
    var _a, _b;
    const message = createBaseGetUnevaluatedConfigResultsWithAbTargetingRequest();
    message.namespaces = ((_a = object.namespaces) === null || _a === void 0 ? void 0 : _a.map((e2) => e2)) || [];
    message.edgeConfigClientVersion = (_b = object.edgeConfigClientVersion) !== null && _b !== void 0 ? _b : "";
    return message;
  }
};
function createBaseGetUnevaluatedConfigResultsWithAbTargetingResponse() {
  return { configResults: [] };
}
var GetUnevaluatedConfigResultsWithAbTargetingResponse = {
  encode(message, writer = import_minimal18.default.Writer.create()) {
    for (const v2 of message.configResults) {
      ConfigResult.encode(v2, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal18.default.Reader ? input : new import_minimal18.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetUnevaluatedConfigResultsWithAbTargetingResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.configResults.push(ConfigResult.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(object) {
    var _a;
    const message = createBaseGetUnevaluatedConfigResultsWithAbTargetingResponse();
    message.configResults = ((_a = object.configResults) === null || _a === void 0 ? void 0 : _a.map((e2) => ConfigResult.fromPartial(e2))) || [];
    return message;
  }
};
function createBaseAddRuidsForDebuggingRequest() {
  return { ruids: [], configNames: [], maxSnapshots: 0 };
}
var AddRuidsForDebuggingRequest = {
  encode(message, writer = import_minimal18.default.Writer.create()) {
    for (const v2 of message.ruids) {
      Ruid.encode(v2, writer.uint32(10).fork()).ldelim();
    }
    for (const v2 of message.configNames) {
      writer.uint32(18).string(v2);
    }
    if (message.maxSnapshots !== 0) {
      writer.uint32(24).int32(message.maxSnapshots);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal18.default.Reader ? input : new import_minimal18.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAddRuidsForDebuggingRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.ruids.push(Ruid.decode(reader, reader.uint32()));
          break;
        case 2:
          message.configNames.push(reader.string());
          break;
        case 3:
          message.maxSnapshots = reader.int32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(object) {
    var _a, _b, _c;
    const message = createBaseAddRuidsForDebuggingRequest();
    message.ruids = ((_a = object.ruids) === null || _a === void 0 ? void 0 : _a.map((e2) => Ruid.fromPartial(e2))) || [];
    message.configNames = ((_b = object.configNames) === null || _b === void 0 ? void 0 : _b.map((e2) => e2)) || [];
    message.maxSnapshots = (_c = object.maxSnapshots) !== null && _c !== void 0 ? _c : 0;
    return message;
  }
};
function createBaseAddRuidsForDebuggingResponse() {
  return {};
}
var AddRuidsForDebuggingResponse = {
  encode(_, writer = import_minimal18.default.Writer.create()) {
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal18.default.Reader ? input : new import_minimal18.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAddRuidsForDebuggingResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(_) {
    const message = createBaseAddRuidsForDebuggingResponse();
    return message;
  }
};
var CircumstancesServiceClientImpl = class {
  constructor(rpc) {
    this.rpc = rpc;
    this.targetingQuery = this.targetingQuery.bind(this);
    this.getAbConfigValues = this.getAbConfigValues.bind(this);
    this.getConfigValuesByToken = this.getConfigValuesByToken.bind(this);
    this.getConfigResultsBySequenceIds = this.getConfigResultsBySequenceIds.bind(this);
    this.getCachedConfigResultSequenceIds = this.getCachedConfigResultSequenceIds.bind(this);
    this.getBitmapByToken = this.getBitmapByToken.bind(this);
    this.generateConfigSet = this.generateConfigSet.bind(this);
    this.pinConfigSet = this.pinConfigSet.bind(this);
    this.unpinConfigSet = this.unpinConfigSet.bind(this);
    this.getUnevaluatedConfigResultsWithAbTargeting = this.getUnevaluatedConfigResultsWithAbTargeting.bind(this);
    this.addRuidsForDebugging = this.addRuidsForDebugging.bind(this);
  }
  targetingQuery(request, metadata) {
    return this.rpc.unary(CircumstancesServicetargetingQueryDesc, ConfigTargetingRequest.fromPartial(request), metadata);
  }
  getAbConfigValues(request, metadata) {
    return this.rpc.unary(CircumstancesServicegetAbConfigValuesDesc, GetAbConfigValuesRequest.fromPartial(request), metadata);
  }
  getConfigValuesByToken(request, metadata) {
    return this.rpc.unary(CircumstancesServicegetConfigValuesByTokenDesc, GetConfigValuesByTokenRequest.fromPartial(request), metadata);
  }
  getConfigResultsBySequenceIds(request, metadata) {
    return this.rpc.unary(CircumstancesServicegetConfigResultsBySequenceIdsDesc, GetConfigResultsBySequenceIdsRequest.fromPartial(request), metadata);
  }
  getCachedConfigResultSequenceIds(request, metadata) {
    return this.rpc.unary(CircumstancesServicegetCachedConfigResultSequenceIdsDesc, GetCachedConfigResultSequenceIdsRequest.fromPartial(request), metadata);
  }
  getBitmapByToken(request, metadata) {
    return this.rpc.unary(CircumstancesServicegetBitmapByTokenDesc, GetBitmapByTokenRequest.fromPartial(request), metadata);
  }
  generateConfigSet(request, metadata) {
    return this.rpc.unary(CircumstancesServicegenerateConfigSetDesc, ConfigSetGenerationRequest.fromPartial(request), metadata);
  }
  pinConfigSet(request, metadata) {
    return this.rpc.unary(CircumstancesServicepinConfigSetDesc, PinConfigRequest.fromPartial(request), metadata);
  }
  unpinConfigSet(request, metadata) {
    return this.rpc.unary(CircumstancesServiceunpinConfigSetDesc, UnpinConfigRequest.fromPartial(request), metadata);
  }
  getUnevaluatedConfigResultsWithAbTargeting(request, metadata) {
    return this.rpc.unary(CircumstancesServicegetUnevaluatedConfigResultsWithAbTargetingDesc, GetUnevaluatedConfigResultsWithAbTargetingRequest.fromPartial(request), metadata);
  }
  addRuidsForDebugging(request, metadata) {
    return this.rpc.unary(CircumstancesServiceaddRuidsForDebuggingDesc, AddRuidsForDebuggingRequest.fromPartial(request), metadata);
  }
};
var CircumstancesServiceDesc = {
  serviceName: "snapchat.cdp.cof.CircumstancesService"
};
var CircumstancesServicetargetingQueryDesc = {
  methodName: "targetingQuery",
  service: CircumstancesServiceDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return ConfigTargetingRequest.encode(this).finish();
    }
  },
  responseType: {
    deserializeBinary(data) {
      return Object.assign(Object.assign({}, ConfigTargetingResponse.decode(data)), { toObject() {
        return this;
      } });
    }
  }
};
var CircumstancesServicegetAbConfigValuesDesc = {
  methodName: "getAbConfigValues",
  service: CircumstancesServiceDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return GetAbConfigValuesRequest.encode(this).finish();
    }
  },
  responseType: {
    deserializeBinary(data) {
      return Object.assign(Object.assign({}, GetAbConfigValuesResponse.decode(data)), { toObject() {
        return this;
      } });
    }
  }
};
var CircumstancesServicegetConfigValuesByTokenDesc = {
  methodName: "getConfigValuesByToken",
  service: CircumstancesServiceDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return GetConfigValuesByTokenRequest.encode(this).finish();
    }
  },
  responseType: {
    deserializeBinary(data) {
      return Object.assign(Object.assign({}, GetConfigValuesByTokenResponse.decode(data)), { toObject() {
        return this;
      } });
    }
  }
};
var CircumstancesServicegetConfigResultsBySequenceIdsDesc = {
  methodName: "getConfigResultsBySequenceIds",
  service: CircumstancesServiceDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return GetConfigResultsBySequenceIdsRequest.encode(this).finish();
    }
  },
  responseType: {
    deserializeBinary(data) {
      return Object.assign(Object.assign({}, GetConfigResultsBySequenceIdsResponse.decode(data)), { toObject() {
        return this;
      } });
    }
  }
};
var CircumstancesServicegetCachedConfigResultSequenceIdsDesc = {
  methodName: "getCachedConfigResultSequenceIds",
  service: CircumstancesServiceDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return GetCachedConfigResultSequenceIdsRequest.encode(this).finish();
    }
  },
  responseType: {
    deserializeBinary(data) {
      return Object.assign(Object.assign({}, GetCachedConfigResultSequenceIdsResponse.decode(data)), { toObject() {
        return this;
      } });
    }
  }
};
var CircumstancesServicegetBitmapByTokenDesc = {
  methodName: "getBitmapByToken",
  service: CircumstancesServiceDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return GetBitmapByTokenRequest.encode(this).finish();
    }
  },
  responseType: {
    deserializeBinary(data) {
      return Object.assign(Object.assign({}, GetBitmapByTokenResponse.decode(data)), { toObject() {
        return this;
      } });
    }
  }
};
var CircumstancesServicegenerateConfigSetDesc = {
  methodName: "generateConfigSet",
  service: CircumstancesServiceDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return ConfigSetGenerationRequest.encode(this).finish();
    }
  },
  responseType: {
    deserializeBinary(data) {
      return Object.assign(Object.assign({}, ConfigSetGenerationResponse.decode(data)), { toObject() {
        return this;
      } });
    }
  }
};
var CircumstancesServicepinConfigSetDesc = {
  methodName: "pinConfigSet",
  service: CircumstancesServiceDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return PinConfigRequest.encode(this).finish();
    }
  },
  responseType: {
    deserializeBinary(data) {
      return Object.assign(Object.assign({}, PinConfigResponse.decode(data)), { toObject() {
        return this;
      } });
    }
  }
};
var CircumstancesServiceunpinConfigSetDesc = {
  methodName: "unpinConfigSet",
  service: CircumstancesServiceDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return UnpinConfigRequest.encode(this).finish();
    }
  },
  responseType: {
    deserializeBinary(data) {
      return Object.assign(Object.assign({}, UnpinConfigResponse.decode(data)), { toObject() {
        return this;
      } });
    }
  }
};
var CircumstancesServicegetUnevaluatedConfigResultsWithAbTargetingDesc = {
  methodName: "getUnevaluatedConfigResultsWithAbTargeting",
  service: CircumstancesServiceDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return GetUnevaluatedConfigResultsWithAbTargetingRequest.encode(this).finish();
    }
  },
  responseType: {
    deserializeBinary(data) {
      return Object.assign(Object.assign({}, GetUnevaluatedConfigResultsWithAbTargetingResponse.decode(data)), { toObject() {
        return this;
      } });
    }
  }
};
var CircumstancesServiceaddRuidsForDebuggingDesc = {
  methodName: "addRuidsForDebugging",
  service: CircumstancesServiceDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return AddRuidsForDebuggingRequest.encode(this).finish();
    }
  },
  responseType: {
    deserializeBinary(data) {
      return Object.assign(Object.assign({}, AddRuidsForDebuggingResponse.decode(data)), { toObject() {
        return this;
      } });
    }
  }
};
var GrpcWebImpl = class {
  constructor(host, options) {
    this.host = host;
    this.options = options;
  }
  unary(methodDesc, _request, metadata) {
    var _a;
    const request = Object.assign(Object.assign({}, _request), methodDesc.requestType);
    const maybeCombinedMetadata = metadata && this.options.metadata ? new import_browser_headers.BrowserHeaders(Object.assign(Object.assign({}, (_a = this.options) === null || _a === void 0 ? void 0 : _a.metadata.headersMap), metadata === null || metadata === void 0 ? void 0 : metadata.headersMap)) : metadata || this.options.metadata;
    return new Promise((resolve, reject) => {
      import_grpc_web2.grpc.unary(methodDesc, {
        request,
        host: this.host,
        metadata: maybeCombinedMetadata,
        transport: this.options.transport,
        debug: this.options.debug,
        onEnd: function(response) {
          if (response.status === import_grpc_web2.grpc.Code.OK) {
            resolve(response.message);
          } else {
            const err = new Error(response.statusMessage);
            err.code = response.status;
            err.metadata = response.trailers;
            reject(err);
          }
        }
      });
    });
  }
};
if (import_minimal18.default.util.Long !== import_long18.default) {
  import_minimal18.default.util.Long = import_long18.default;
  import_minimal18.default.configure();
}

// node_modules/@snap/camera-kit/dist/handlers/responseCachingHandler.js
var logger4 = getLogger("responseCachingHandler");
var notFound = (key) => cacheKeyNotFoundError(`Response for key ${key} not found in cache.`);
var strategyFailed = (key, cause) => new Error(`Network request and cache lookup for key ${key} both failed.`, { cause });
var staleWhileRevalidateStrategy = (options) => (key, cache, network) => __awaiter(void 0, void 0, void 0, function* () {
  var _c, _d;
  try {
    const cachedResponse = yield cache.retrieve(key);
    if (!cachedResponse)
      throw notFound(key);
    network({ isSideEffect: true }).then((response) => cache.store(key, response)).catch((error) => {
      logger4.warn(`staleWhileRevalidateStrategy failed to retrieve and store key ${key}.`, error);
    });
    (_c = options === null || options === void 0 ? void 0 : options.onHit) === null || _c === void 0 ? void 0 : _c.call(options);
    return cachedResponse;
  } catch (cacheError) {
    (_d = options === null || options === void 0 ? void 0 : options.onMiss) === null || _d === void 0 ? void 0 : _d.call(options);
    try {
      const response = yield network();
      cache.store(key, response).catch((error) => {
        logger4.warn(`staleWhileRevalidateStrategy failed to store key ${key}.`, error);
      });
      logger4.debug(`staleWhileRevalidateStrategy successfully fell back to network for key ${key} after cache error.`, cacheError);
      return response;
    } catch (networkError) {
      const error = ensureError(networkError);
      error.cause = cacheError;
      throw strategyFailed(key, error);
    }
  }
});
var createResponseCachingHandler = (cache, resolveKey, strategy) => {
  return (next) => (request, metadata) => __awaiter(void 0, void 0, void 0, function* () {
    const network = (additionalMetadata = {}) => {
      const m2 = Object.assign(Object.assign({}, metadata), additionalMetadata);
      return next(request, m2);
    };
    let key;
    try {
      key = resolveKey(request, metadata);
    } catch (error) {
      logger4.warn("Cache lookup failed because the cache key could not be resolved.", error);
      return network();
    }
    return strategy(key, cache, network);
  });
};

// node_modules/@snap/camera-kit/dist/persistence/Persistence.js
var isValidKey = (key) => typeof key === "string" || typeof key === "number";

// node_modules/@snap/camera-kit/dist/persistence/IndexedDBPersistence.js
function wrapRequest(request) {
  const p2 = new Promise((resolve, reject) => {
    request.onsuccess = () => resolve(request.result);
    request.onerror = () => reject(request.error);
  });
  p2.request = request;
  return p2;
}
function wrapCursorRequest(request) {
  return new Promise((resolve, reject) => {
    request.onsuccess = () => {
      const cursor = request.result;
      if (!cursor)
        resolve({ cursor: null, continue: () => Promise.reject() });
      else
        resolve({
          cursor,
          continue: () => {
            cursor.continue();
            return wrapCursorRequest(request);
          }
        });
    };
    request.onerror = () => reject(request.error);
  });
}
var IndexedDBPersistence = class {
  constructor(options) {
    var _a;
    this.databaseName = `Snap.CameraKit.${options.databaseName}`;
    this.databaseVersion = options.databaseVersion;
    this.objectStore = (_a = options.objectStore) !== null && _a !== void 0 ? _a : options.databaseName;
    this.db = this.openDatabase(indexedDB.open(this.databaseName, this.databaseVersion));
    this.size = 0;
  }
  retrieve(key) {
    return this.simpleTransaction("readonly", (store) => store.get(key));
  }
  retrieveAll() {
    return __awaiter(this, void 0, void 0, function* () {
      const results = [];
      const { store, done } = yield this.transaction("readonly");
      let request = yield wrapCursorRequest(store.openCursor());
      while (request.cursor) {
        results.push([request.cursor.primaryKey, request.cursor.value]);
        request = yield request.continue();
      }
      yield done;
      return results;
    });
  }
  remove(key) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.simpleTransaction("readwrite", (store) => store.delete(key));
      this.size--;
    });
  }
  removeAll() {
    return __awaiter(this, void 0, void 0, function* () {
      const results = [];
      const { store, done } = yield this.transaction("readwrite");
      let request = yield wrapCursorRequest(store.openCursor());
      const deleteRequests = [];
      while (request.cursor) {
        results.push(request.cursor.value);
        deleteRequests.push(wrapRequest(store.delete(request.cursor.key)));
        request = yield request.continue();
      }
      yield Promise.all(deleteRequests.concat(done));
      this.size = 0;
      return results;
    });
  }
  store(keyOrValue, maybeValue) {
    return __awaiter(this, void 0, void 0, function* () {
      const [key, value] = maybeValue === void 0 ? [void 0, keyOrValue] : [keyOrValue, maybeValue];
      if (!isValidKey(key) && typeof key !== "undefined")
        throw new TypeError(`IndexedDBPersistence failed to store a value. Invalid key type: ${typeof key}`);
      const storedKey = yield this.simpleTransaction("readwrite", (store) => store.put(value, key));
      this.size++;
      return storedKey;
    });
  }
  openDatabase(request) {
    return __awaiter(this, void 0, void 0, function* () {
      const dbPromise = wrapRequest(request);
      dbPromise.request.onupgradeneeded = () => {
        try {
          dbPromise.request.result.createObjectStore(this.objectStore, { autoIncrement: true });
        } catch (error) {
          if (error instanceof DOMException && error.name === "ConstraintError")
            return;
          throw error;
        }
      };
      const db = yield dbPromise;
      db.onclose = () => {
        this.db = this.openDatabase(indexedDB.open(this.databaseName, this.databaseVersion));
      };
      return db;
    });
  }
  simpleTransaction(mode, operation) {
    return __awaiter(this, void 0, void 0, function* () {
      const { store, done } = yield this.transaction(mode);
      const [result] = yield Promise.all([wrapRequest(operation(store)), done]);
      return result;
    });
  }
  transaction(mode) {
    return __awaiter(this, void 0, void 0, function* () {
      const db = yield this.db;
      const tx = db.transaction(this.objectStore, mode);
      const store = tx.objectStore(this.objectStore);
      const done = new Promise((resolve, reject) => {
        tx.oncomplete = () => resolve();
        tx.onerror = () => reject(tx.error);
        tx.onabort = () => reject(new DOMException("The transaction was aborted", "AbortError"));
      });
      return { tx, store, done };
    });
  }
};

// node_modules/@snap/camera-kit/dist/persistence/ExpiringPersistence.js
var logger5 = getLogger("ExpiringPersistence");
var ExpiringPersistence = class {
  constructor(expiration, persistence) {
    this.expiration = expiration;
    this.persistence = persistence;
    this.removeExpired().catch((error) => {
      logger5.warn("Failed to cleanup expired entries on startup.", error);
    });
  }
  get size() {
    return this.persistence.size;
  }
  retrieve(key) {
    var _a;
    return __awaiter(this, void 0, void 0, function* () {
      const [expiry, value] = (_a = yield this.persistence.retrieve(key)) !== null && _a !== void 0 ? _a : [];
      if (value === void 0 || expiry === void 0)
        return void 0;
      if (Date.now() > expiry) {
        yield this.persistence.remove(key).catch((error) => {
          logger5.warn(`Key ${key} is expired, but removing it from persistence failed.`, error);
        });
        return void 0;
      }
      return value;
    });
  }
  retrieveAll() {
    return __awaiter(this, void 0, void 0, function* () {
      const now = Date.now();
      return (yield this.persistence.retrieveAll()).filter(([, [expiry]]) => expiry >= now).map(([, v2]) => v2);
    });
  }
  remove(key) {
    return this.persistence.remove(key);
  }
  removeAll() {
    return __awaiter(this, void 0, void 0, function* () {
      const results = yield this.persistence.removeAll();
      return results.map(([, v2]) => v2);
    });
  }
  removeExpired() {
    return __awaiter(this, void 0, void 0, function* () {
      for (const [key, [expiry]] of yield this.persistence.retrieveAll()) {
        if (Date.now() >= expiry) {
          yield this.persistence.remove(key).catch((error) => logger5.warn(`Failed to remove expired key ${key}.`, error));
        }
      }
    });
  }
  store(keyOrValue, maybeValue) {
    const [key, value] = maybeValue === void 0 ? [void 0, keyOrValue] : [keyOrValue, maybeValue];
    const expiry = Date.now() + this.expiration(value) * 1e3;
    return key === void 0 ? this.persistence.store([expiry, value]) : this.persistence.store(key, [expiry, value]);
  }
};

// node_modules/@snap/camera-kit/dist/common/pageVisibility.js
var PageVisibility = class {
  constructor() {
    this.onHiddenHandlers = /* @__PURE__ */ new Set();
    this.onVisibleHandlers = /* @__PURE__ */ new Set();
    this.previousVisibilityState = document.visibilityState;
    this.visibilityTransition = false;
    this.onVisibilityChange = this.onVisibilityChange.bind(this);
    this.isDuringVisibilityTransition = this.isDuringVisibilityTransition.bind(this);
    this.onPageHidden = this.onPageHidden.bind(this);
    this.onPageVisible = this.onPageVisible.bind(this);
    this.destroy = this.destroy.bind(this);
    document.addEventListener("visibilitychange", this.onVisibilityChange);
  }
  isDuringVisibilityTransition(test) {
    return test === this.visibilityTransition;
  }
  onPageHidden(handler) {
    this.onHiddenHandlers.add(handler);
    return () => this.onHiddenHandlers.delete(handler);
  }
  onPageVisible(handler) {
    this.onVisibleHandlers.add(handler);
    return () => this.onVisibleHandlers.delete(handler);
  }
  destroy() {
    document.removeEventListener("visibilitychange", this.onVisibilityChange);
    this.onHiddenHandlers.clear();
    this.onVisibleHandlers.clear();
  }
  onVisibilityChange() {
    const handlers = this.previousVisibilityState === "visible" && document.visibilityState === "hidden" ? this.onHiddenHandlers : this.previousVisibilityState === "hidden" && document.visibilityState === "visible" ? this.onVisibleHandlers : /* @__PURE__ */ new Set();
    this.visibilityTransition = document.visibilityState;
    for (const handler of handlers) {
      try {
        handler();
      } catch (error) {
        if (typeof window !== "undefined")
          window.dispatchEvent(new CustomEvent("error", { detail: error }));
      }
    }
    this.previousVisibilityState = this.visibilityTransition;
    this.visibilityTransition = false;
  }
};
var pageVisibilityFactory = Injectable("pageVisibility", () => new PageVisibility());

// node_modules/@snap/camera-kit/dist/generated-proto/blizzard/cameraKitEvents.js
var import_minimal19 = __toESM(require_minimal2());
var ServerEventBatch = {
  encode(message, writer = import_minimal19.default.Writer.create()) {
    if (message.serverUploadTs !== 0) {
      writer.uint32(9).double(message.serverUploadTs);
    }
    for (const v2 of message.serverAllUpdateEvents) {
      ServerRequestAllUpdates.encode(v2, writer.uint32(18).fork()).ldelim();
    }
    if (message.maxSequenceIdOnInstance !== "0") {
      writer.uint32(24).uint64(message.maxSequenceIdOnInstance);
    }
    for (const v2 of message.serverEvents) {
      ServerEvent.encode(v2, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },
  fromPartial(object) {
    var _a, _b, _c, _d;
    const message = createBaseServerEventBatch();
    message.serverUploadTs = (_a = object.serverUploadTs) !== null && _a !== void 0 ? _a : 0;
    message.serverAllUpdateEvents = ((_b = object.serverAllUpdateEvents) === null || _b === void 0 ? void 0 : _b.map((e2) => ServerRequestAllUpdates.fromPartial(e2))) || [];
    message.maxSequenceIdOnInstance = (_c = object.maxSequenceIdOnInstance) !== null && _c !== void 0 ? _c : "0";
    message.serverEvents = ((_d = object.serverEvents) === null || _d === void 0 ? void 0 : _d.map((e2) => ServerEvent.fromPartial(e2))) || [];
    return message;
  }
};
function createBaseServerEventBatch() {
  return { serverUploadTs: 0, serverAllUpdateEvents: [], maxSequenceIdOnInstance: "0", serverEvents: [] };
}
var ServerRequestAllUpdates = {
  encode(_, writer = import_minimal19.default.Writer.create()) {
    return writer;
  },
  fromPartial(_) {
    const message = createBaseServerRequestAllUpdates();
    return message;
  }
};
function createBaseServerRequestAllUpdates() {
  return {};
}
var ServerEvent = {
  encode(message, writer = import_minimal19.default.Writer.create()) {
    if (message.eventName !== "") {
      writer.uint32(10).string(message.eventName);
    }
    if (message.serverTs !== 0) {
      writer.uint32(25).double(message.serverTs);
    }
    if (message.userId !== "") {
      writer.uint32(34).string(message.userId);
    }
    if (message.userAgent !== "") {
      writer.uint32(42).string(message.userAgent);
    }
    if (message.country !== "") {
      writer.uint32(50).string(message.country);
    }
    if (message.city !== "") {
      writer.uint32(58).string(message.city);
    }
    if (message.region !== "") {
      writer.uint32(66).string(message.region);
    }
    if (message.eventId !== "") {
      writer.uint32(74).string(message.eventId);
    }
    if (message.instanceId !== "") {
      writer.uint32(82).string(message.instanceId);
    }
    if (message.sequenceId !== "0") {
      writer.uint32(88).uint64(message.sequenceId);
    }
    if (message.osType !== "") {
      writer.uint32(98).string(message.osType);
    }
    if (message.osVersion !== "") {
      writer.uint32(106).string(message.osVersion);
    }
    if (message.appVersion !== "") {
      writer.uint32(114).string(message.appVersion);
    }
    if (message.appBuild !== "") {
      writer.uint32(122).string(message.appBuild);
    }
    if (message.serverUploadTs !== 0) {
      writer.uint32(809).double(message.serverUploadTs);
    }
    if (message.eventTime !== 0) {
      writer.uint32(817).double(message.eventTime);
    }
    if (message.serverReceiptTime !== 0) {
      writer.uint32(825).double(message.serverReceiptTime);
    }
    if (message.maxSequenceIdOnInstance !== "0") {
      writer.uint32(832).uint64(message.maxSequenceIdOnInstance);
    }
    if (message.userGuid !== "") {
      writer.uint32(850).string(message.userGuid);
    }
    if (message.collection !== 0) {
      writer.uint32(872).int32(message.collection);
    }
    if (message.serviceId !== "") {
      writer.uint32(890).string(message.serviceId);
    }
    if (message.appType !== 0) {
      writer.uint32(912).int32(message.appType);
    }
    if (message.spectrumInstanceId !== "") {
      writer.uint32(930).string(message.spectrumInstanceId);
    }
    if (message.spectrumSequenceId !== "0") {
      writer.uint32(944).uint64(message.spectrumSequenceId);
    }
    if (message.eventData !== void 0) {
      ServerEventData.encode(message.eventData, writer.uint32(802).fork()).ldelim();
    }
    return writer;
  },
  fromPartial(object) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z;
    const message = createBaseServerEvent();
    message.eventName = (_a = object.eventName) !== null && _a !== void 0 ? _a : "";
    message.serverTs = (_b = object.serverTs) !== null && _b !== void 0 ? _b : 0;
    message.userId = (_c = object.userId) !== null && _c !== void 0 ? _c : "";
    message.userAgent = (_d = object.userAgent) !== null && _d !== void 0 ? _d : "";
    message.country = (_e = object.country) !== null && _e !== void 0 ? _e : "";
    message.city = (_f = object.city) !== null && _f !== void 0 ? _f : "";
    message.region = (_g = object.region) !== null && _g !== void 0 ? _g : "";
    message.eventId = (_h = object.eventId) !== null && _h !== void 0 ? _h : "";
    message.instanceId = (_j = object.instanceId) !== null && _j !== void 0 ? _j : "";
    message.sequenceId = (_k = object.sequenceId) !== null && _k !== void 0 ? _k : "0";
    message.osType = (_l = object.osType) !== null && _l !== void 0 ? _l : "";
    message.osVersion = (_m = object.osVersion) !== null && _m !== void 0 ? _m : "";
    message.appVersion = (_o = object.appVersion) !== null && _o !== void 0 ? _o : "";
    message.appBuild = (_p = object.appBuild) !== null && _p !== void 0 ? _p : "";
    message.serverUploadTs = (_q = object.serverUploadTs) !== null && _q !== void 0 ? _q : 0;
    message.eventTime = (_r = object.eventTime) !== null && _r !== void 0 ? _r : 0;
    message.serverReceiptTime = (_s = object.serverReceiptTime) !== null && _s !== void 0 ? _s : 0;
    message.maxSequenceIdOnInstance = (_t = object.maxSequenceIdOnInstance) !== null && _t !== void 0 ? _t : "0";
    message.userGuid = (_u = object.userGuid) !== null && _u !== void 0 ? _u : "";
    message.collection = (_v = object.collection) !== null && _v !== void 0 ? _v : 0;
    message.serviceId = (_w = object.serviceId) !== null && _w !== void 0 ? _w : "";
    message.appType = (_x = object.appType) !== null && _x !== void 0 ? _x : 0;
    message.spectrumInstanceId = (_y = object.spectrumInstanceId) !== null && _y !== void 0 ? _y : "";
    message.spectrumSequenceId = (_z = object.spectrumSequenceId) !== null && _z !== void 0 ? _z : "0";
    message.eventData = object.eventData !== void 0 && object.eventData !== null ? ServerEventData.fromPartial(object.eventData) : void 0;
    return message;
  }
};
function createBaseServerEvent() {
  return {
    eventName: "",
    serverTs: 0,
    userId: "",
    userAgent: "",
    country: "",
    city: "",
    region: "",
    eventId: "",
    instanceId: "",
    sequenceId: "0",
    osType: "",
    osVersion: "",
    appVersion: "",
    appBuild: "",
    serverUploadTs: 0,
    eventTime: 0,
    serverReceiptTime: 0,
    maxSequenceIdOnInstance: "0",
    userGuid: "",
    collection: 0,
    serviceId: "",
    appType: 0,
    spectrumInstanceId: "",
    spectrumSequenceId: "0",
    eventData: void 0
  };
}
var ServerEventData = {
  encode(message, writer = import_minimal19.default.Writer.create()) {
    if (message.cameraKitException !== void 0) {
      CameraKitException.encode(message.cameraKitException, writer.uint32(1866).fork()).ldelim();
    }
    if (message.cameraKitLensSpin !== void 0) {
      CameraKitLensSpin.encode(message.cameraKitLensSpin, writer.uint32(1874).fork()).ldelim();
    }
    if (message.cameraKitAssetDownload !== void 0) {
      CameraKitAssetDownload.encode(message.cameraKitAssetDownload, writer.uint32(1882).fork()).ldelim();
    }
    if (message.cameraKitLensContentValidationFailed !== void 0) {
      CameraKitLensContentValidationFailed.encode(message.cameraKitLensContentValidationFailed, writer.uint32(1922).fork()).ldelim();
    }
    if (message.cameraKitLensDownload !== void 0) {
      CameraKitLensDownload.encode(message.cameraKitLensDownload, writer.uint32(1930).fork()).ldelim();
    }
    if (message.cameraKitAssetValidationFailed !== void 0) {
      CameraKitAssetValidationFailed.encode(message.cameraKitAssetValidationFailed, writer.uint32(1938).fork()).ldelim();
    }
    if (message.cameraKitSession !== void 0) {
      CameraKitSession.encode(message.cameraKitSession, writer.uint32(2130).fork()).ldelim();
    }
    if (message.cameraKitWebLensSwipe !== void 0) {
      CameraKitWebLensSwipe.encode(message.cameraKitWebLensSwipe, writer.uint32(3818).fork()).ldelim();
    }
    if (message.cameraKitWebBenchmarkComplete !== void 0) {
      CameraKitWebBenchmarkComplete.encode(message.cameraKitWebBenchmarkComplete, writer.uint32(3826).fork()).ldelim();
    }
    if (message.cameraKitLegalPrompt !== void 0) {
      CameraKitLegalPrompt.encode(message.cameraKitLegalPrompt, writer.uint32(3874).fork()).ldelim();
    }
    return writer;
  },
  fromPartial(object) {
    const message = createBaseServerEventData();
    message.cameraKitException = object.cameraKitException !== void 0 && object.cameraKitException !== null ? CameraKitException.fromPartial(object.cameraKitException) : void 0;
    message.cameraKitLensSpin = object.cameraKitLensSpin !== void 0 && object.cameraKitLensSpin !== null ? CameraKitLensSpin.fromPartial(object.cameraKitLensSpin) : void 0;
    message.cameraKitAssetDownload = object.cameraKitAssetDownload !== void 0 && object.cameraKitAssetDownload !== null ? CameraKitAssetDownload.fromPartial(object.cameraKitAssetDownload) : void 0;
    message.cameraKitLensContentValidationFailed = object.cameraKitLensContentValidationFailed !== void 0 && object.cameraKitLensContentValidationFailed !== null ? CameraKitLensContentValidationFailed.fromPartial(object.cameraKitLensContentValidationFailed) : void 0;
    message.cameraKitLensDownload = object.cameraKitLensDownload !== void 0 && object.cameraKitLensDownload !== null ? CameraKitLensDownload.fromPartial(object.cameraKitLensDownload) : void 0;
    message.cameraKitAssetValidationFailed = object.cameraKitAssetValidationFailed !== void 0 && object.cameraKitAssetValidationFailed !== null ? CameraKitAssetValidationFailed.fromPartial(object.cameraKitAssetValidationFailed) : void 0;
    message.cameraKitSession = object.cameraKitSession !== void 0 && object.cameraKitSession !== null ? CameraKitSession.fromPartial(object.cameraKitSession) : void 0;
    message.cameraKitWebLensSwipe = object.cameraKitWebLensSwipe !== void 0 && object.cameraKitWebLensSwipe !== null ? CameraKitWebLensSwipe.fromPartial(object.cameraKitWebLensSwipe) : void 0;
    message.cameraKitWebBenchmarkComplete = object.cameraKitWebBenchmarkComplete !== void 0 && object.cameraKitWebBenchmarkComplete !== null ? CameraKitWebBenchmarkComplete.fromPartial(object.cameraKitWebBenchmarkComplete) : void 0;
    message.cameraKitLegalPrompt = object.cameraKitLegalPrompt !== void 0 && object.cameraKitLegalPrompt !== null ? CameraKitLegalPrompt.fromPartial(object.cameraKitLegalPrompt) : void 0;
    return message;
  }
};
function createBaseServerEventData() {
  return {
    cameraKitException: void 0,
    cameraKitLensSpin: void 0,
    cameraKitAssetDownload: void 0,
    cameraKitLensContentValidationFailed: void 0,
    cameraKitLensDownload: void 0,
    cameraKitAssetValidationFailed: void 0,
    cameraKitSession: void 0,
    cameraKitWebLensSwipe: void 0,
    cameraKitWebBenchmarkComplete: void 0,
    cameraKitLegalPrompt: void 0
  };
}
var AppType;
(function(AppType2) {
  AppType2[AppType2["IOS_NATIVE"] = 0] = "IOS_NATIVE";
  AppType2[AppType2["IOS_WEB_DESKTOP"] = 1] = "IOS_WEB_DESKTOP";
  AppType2[AppType2["IOS_WEB_MOBILE"] = 2] = "IOS_WEB_MOBILE";
  AppType2[AppType2["ANDROID_NATIVE"] = 3] = "ANDROID_NATIVE";
  AppType2[AppType2["ANDROID_WEB_DESKTOP"] = 4] = "ANDROID_WEB_DESKTOP";
  AppType2[AppType2["ANDROID_WEB_MOBILE"] = 5] = "ANDROID_WEB_MOBILE";
  AppType2[AppType2["OSX_WEB_DESKTOP"] = 6] = "OSX_WEB_DESKTOP";
  AppType2[AppType2["OSX_WEB_MOBILE"] = 7] = "OSX_WEB_MOBILE";
  AppType2[AppType2["WINDOWS_WEB_DESKTOP"] = 8] = "WINDOWS_WEB_DESKTOP";
  AppType2[AppType2["WINDOWS_WEB_MOBILE"] = 9] = "WINDOWS_WEB_MOBILE";
  AppType2[AppType2["LINUX_WEB_DESKTOP"] = 10] = "LINUX_WEB_DESKTOP";
  AppType2[AppType2["LINUX_WEB_MOBILE"] = 11] = "LINUX_WEB_MOBILE";
  AppType2[AppType2["LENSSTUDIO"] = 12] = "LENSSTUDIO";
  AppType2[AppType2["SNAPCAMERA"] = 13] = "SNAPCAMERA";
  AppType2[AppType2["WEB_DESKTOP"] = 14] = "WEB_DESKTOP";
  AppType2[AppType2["WEB_MOBILE"] = 15] = "WEB_MOBILE";
  AppType2[AppType2["LENSSTUDIO_REMAKE"] = 16] = "LENSSTUDIO_REMAKE";
  AppType2[AppType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(AppType || (AppType = {}));
var Collection;
(function(Collection2) {
  Collection2[Collection2["COLLECTION_UNUSED"] = 0] = "COLLECTION_UNUSED";
  Collection2[Collection2["GAE"] = 1] = "GAE";
  Collection2[Collection2["GCE_M"] = 2] = "GCE_M";
  Collection2[Collection2["GCE_S"] = 3] = "GCE_S";
  Collection2[Collection2["GCE_T"] = 4] = "GCE_T";
  Collection2[Collection2["GKE_M"] = 5] = "GKE_M";
  Collection2[Collection2["GKE_S"] = 6] = "GKE_S";
  Collection2[Collection2["GKE_T"] = 7] = "GKE_T";
  Collection2[Collection2["LOCAL"] = 8] = "LOCAL";
  Collection2[Collection2["GCE_ST"] = 9] = "GCE_ST";
  Collection2[Collection2["GKE_ST"] = 10] = "GKE_ST";
  Collection2[Collection2["GCE_C"] = 11] = "GCE_C";
  Collection2[Collection2["GCE_SC"] = 12] = "GCE_SC";
  Collection2[Collection2["GCE_TC"] = 13] = "GCE_TC";
  Collection2[Collection2["GCE_TSC"] = 14] = "GCE_TSC";
  Collection2[Collection2["GKE_C"] = 15] = "GKE_C";
  Collection2[Collection2["GKE_SC"] = 16] = "GKE_SC";
  Collection2[Collection2["GKE_TC"] = 17] = "GKE_TC";
  Collection2[Collection2["GKE_TSC"] = 18] = "GKE_TSC";
  Collection2[Collection2["GKE_W"] = 19] = "GKE_W";
  Collection2[Collection2["GKE_WT"] = 20] = "GKE_WT";
  Collection2[Collection2["GKE_WC"] = 21] = "GKE_WC";
  Collection2[Collection2["GKE_WSC"] = 22] = "GKE_WSC";
  Collection2[Collection2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(Collection || (Collection = {}));
var CameraKitLensSpin = {
  encode(message, writer = import_minimal19.default.Writer.create()) {
    if (message.cameraKitEventBase !== void 0) {
      CameraKitEventBase.encode(message.cameraKitEventBase, writer.uint32(10).fork()).ldelim();
    }
    if (message.lensId !== "") {
      writer.uint32(18).string(message.lensId);
    }
    if (message.viewTimeSec !== 0) {
      writer.uint32(25).double(message.viewTimeSec);
    }
    if (message.lensGroupId !== "") {
      writer.uint32(34).string(message.lensGroupId);
    }
    return writer;
  },
  fromPartial(object) {
    var _a, _b, _c;
    const message = createBaseCameraKitLensSpin();
    message.cameraKitEventBase = object.cameraKitEventBase !== void 0 && object.cameraKitEventBase !== null ? CameraKitEventBase.fromPartial(object.cameraKitEventBase) : void 0;
    message.lensId = (_a = object.lensId) !== null && _a !== void 0 ? _a : "";
    message.viewTimeSec = (_b = object.viewTimeSec) !== null && _b !== void 0 ? _b : 0;
    message.lensGroupId = (_c = object.lensGroupId) !== null && _c !== void 0 ? _c : "";
    return message;
  }
};
function createBaseCameraKitLensSpin() {
  return { cameraKitEventBase: void 0, lensId: "", viewTimeSec: 0, lensGroupId: "" };
}
var CameraKitWebLensSwipe = {
  encode(message, writer = import_minimal19.default.Writer.create()) {
    if (message.cameraKitEventBase !== void 0) {
      CameraKitEventBase.encode(message.cameraKitEventBase, writer.uint32(10).fork()).ldelim();
    }
    if (message.performanceCluster !== "0") {
      writer.uint32(16).uint64(message.performanceCluster);
    }
    if (message.webglRendererInfo !== "") {
      writer.uint32(26).string(message.webglRendererInfo);
    }
    if (message.lensId !== "") {
      writer.uint32(34).string(message.lensId);
    }
    if (message.lensFrameProcessingTimeMsAvg !== 0) {
      writer.uint32(41).double(message.lensFrameProcessingTimeMsAvg);
    }
    if (message.lensFrameProcessingTimeMsStd !== 0) {
      writer.uint32(49).double(message.lensFrameProcessingTimeMsStd);
    }
    if (message.viewTimeSec !== 0) {
      writer.uint32(57).double(message.viewTimeSec);
    }
    if (message.recordingTimeSec !== 0) {
      writer.uint32(65).double(message.recordingTimeSec);
    }
    if (message.applyDelaySec !== 0) {
      writer.uint32(73).double(message.applyDelaySec);
    }
    if (message.avgFps !== 0) {
      writer.uint32(81).double(message.avgFps);
    }
    if (message.isLensFirstWithinDay === true) {
      writer.uint32(88).bool(message.isLensFirstWithinDay);
    }
    if (message.isLensFirstWithinMonth === true) {
      writer.uint32(96).bool(message.isLensFirstWithinMonth);
    }
    if (message.lensGroupId !== "") {
      writer.uint32(106).string(message.lensGroupId);
    }
    return writer;
  },
  fromPartial(object) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
    const message = createBaseCameraKitWebLensSwipe();
    message.cameraKitEventBase = object.cameraKitEventBase !== void 0 && object.cameraKitEventBase !== null ? CameraKitEventBase.fromPartial(object.cameraKitEventBase) : void 0;
    message.performanceCluster = (_a = object.performanceCluster) !== null && _a !== void 0 ? _a : "0";
    message.webglRendererInfo = (_b = object.webglRendererInfo) !== null && _b !== void 0 ? _b : "";
    message.lensId = (_c = object.lensId) !== null && _c !== void 0 ? _c : "";
    message.lensFrameProcessingTimeMsAvg = (_d = object.lensFrameProcessingTimeMsAvg) !== null && _d !== void 0 ? _d : 0;
    message.lensFrameProcessingTimeMsStd = (_e = object.lensFrameProcessingTimeMsStd) !== null && _e !== void 0 ? _e : 0;
    message.viewTimeSec = (_f = object.viewTimeSec) !== null && _f !== void 0 ? _f : 0;
    message.recordingTimeSec = (_g = object.recordingTimeSec) !== null && _g !== void 0 ? _g : 0;
    message.applyDelaySec = (_h = object.applyDelaySec) !== null && _h !== void 0 ? _h : 0;
    message.avgFps = (_j = object.avgFps) !== null && _j !== void 0 ? _j : 0;
    message.isLensFirstWithinDay = (_k = object.isLensFirstWithinDay) !== null && _k !== void 0 ? _k : false;
    message.isLensFirstWithinMonth = (_l = object.isLensFirstWithinMonth) !== null && _l !== void 0 ? _l : false;
    message.lensGroupId = (_m = object.lensGroupId) !== null && _m !== void 0 ? _m : "";
    return message;
  }
};
function createBaseCameraKitWebLensSwipe() {
  return {
    cameraKitEventBase: void 0,
    performanceCluster: "0",
    webglRendererInfo: "",
    lensId: "",
    lensFrameProcessingTimeMsAvg: 0,
    lensFrameProcessingTimeMsStd: 0,
    viewTimeSec: 0,
    recordingTimeSec: 0,
    applyDelaySec: 0,
    avgFps: 0,
    isLensFirstWithinDay: false,
    isLensFirstWithinMonth: false,
    lensGroupId: ""
  };
}
var CameraKitLensDownload = {
  encode(message, writer = import_minimal19.default.Writer.create()) {
    if (message.cameraKitEventBase !== void 0) {
      CameraKitEventBase.encode(message.cameraKitEventBase, writer.uint32(10).fork()).ldelim();
    }
    if (message.lensId !== "") {
      writer.uint32(18).string(message.lensId);
    }
    if (message.automaticDownload === true) {
      writer.uint32(24).bool(message.automaticDownload);
    }
    if (message.downloadTimeSec !== 0) {
      writer.uint32(33).double(message.downloadTimeSec);
    }
    if (message.sizeByte !== "0") {
      writer.uint32(40).uint64(message.sizeByte);
    }
    return writer;
  },
  fromPartial(object) {
    var _a, _b, _c, _d;
    const message = createBaseCameraKitLensDownload();
    message.cameraKitEventBase = object.cameraKitEventBase !== void 0 && object.cameraKitEventBase !== null ? CameraKitEventBase.fromPartial(object.cameraKitEventBase) : void 0;
    message.lensId = (_a = object.lensId) !== null && _a !== void 0 ? _a : "";
    message.automaticDownload = (_b = object.automaticDownload) !== null && _b !== void 0 ? _b : false;
    message.downloadTimeSec = (_c = object.downloadTimeSec) !== null && _c !== void 0 ? _c : 0;
    message.sizeByte = (_d = object.sizeByte) !== null && _d !== void 0 ? _d : "0";
    return message;
  }
};
function createBaseCameraKitLensDownload() {
  return { cameraKitEventBase: void 0, lensId: "", automaticDownload: false, downloadTimeSec: 0, sizeByte: "0" };
}
var CameraKitAssetDownload = {
  encode(message, writer = import_minimal19.default.Writer.create()) {
    if (message.cameraKitEventBase !== void 0) {
      CameraKitEventBase.encode(message.cameraKitEventBase, writer.uint32(10).fork()).ldelim();
    }
    if (message.automaticDownload === true) {
      writer.uint32(24).bool(message.automaticDownload);
    }
    if (message.downloadTimeSec !== 0) {
      writer.uint32(33).double(message.downloadTimeSec);
    }
    if (message.sizeByte !== "0") {
      writer.uint32(40).uint64(message.sizeByte);
    }
    if (message.assetId !== "") {
      writer.uint32(50).string(message.assetId);
    }
    return writer;
  },
  fromPartial(object) {
    var _a, _b, _c, _d;
    const message = createBaseCameraKitAssetDownload();
    message.cameraKitEventBase = object.cameraKitEventBase !== void 0 && object.cameraKitEventBase !== null ? CameraKitEventBase.fromPartial(object.cameraKitEventBase) : void 0;
    message.automaticDownload = (_a = object.automaticDownload) !== null && _a !== void 0 ? _a : false;
    message.downloadTimeSec = (_b = object.downloadTimeSec) !== null && _b !== void 0 ? _b : 0;
    message.sizeByte = (_c = object.sizeByte) !== null && _c !== void 0 ? _c : "0";
    message.assetId = (_d = object.assetId) !== null && _d !== void 0 ? _d : "";
    return message;
  }
};
function createBaseCameraKitAssetDownload() {
  return { cameraKitEventBase: void 0, automaticDownload: false, downloadTimeSec: 0, sizeByte: "0", assetId: "" };
}
var CameraKitException = {
  encode(message, writer = import_minimal19.default.Writer.create()) {
    if (message.cameraKitEventBase !== void 0) {
      CameraKitEventBase.encode(message.cameraKitEventBase, writer.uint32(10).fork()).ldelim();
    }
    if (message.lensId !== "") {
      writer.uint32(18).string(message.lensId);
    }
    if (message.type !== "") {
      writer.uint32(26).string(message.type);
    }
    if (message.reason !== "") {
      writer.uint32(34).string(message.reason);
    }
    return writer;
  },
  fromPartial(object) {
    var _a, _b, _c;
    const message = createBaseCameraKitException();
    message.cameraKitEventBase = object.cameraKitEventBase !== void 0 && object.cameraKitEventBase !== null ? CameraKitEventBase.fromPartial(object.cameraKitEventBase) : void 0;
    message.lensId = (_a = object.lensId) !== null && _a !== void 0 ? _a : "";
    message.type = (_b = object.type) !== null && _b !== void 0 ? _b : "";
    message.reason = (_c = object.reason) !== null && _c !== void 0 ? _c : "";
    return message;
  }
};
function createBaseCameraKitException() {
  return { cameraKitEventBase: void 0, lensId: "", type: "", reason: "" };
}
var CameraKitSession = {
  encode(message, writer = import_minimal19.default.Writer.create()) {
    if (message.cameraKitEventBase !== void 0) {
      CameraKitEventBase.encode(message.cameraKitEventBase, writer.uint32(10).fork()).ldelim();
    }
    if (message.dailySessionBucket !== 0) {
      writer.uint32(16).int32(message.dailySessionBucket);
    }
    if (message.isFirstWithinMonth === true) {
      writer.uint32(24).bool(message.isFirstWithinMonth);
    }
    if (message.day !== "0") {
      writer.uint32(32).uint64(message.day);
    }
    if (message.month !== "0") {
      writer.uint32(40).uint64(message.month);
    }
    if (message.year !== "0") {
      writer.uint32(48).uint64(message.year);
    }
    return writer;
  },
  fromPartial(object) {
    var _a, _b, _c, _d, _e;
    const message = createBaseCameraKitSession();
    message.cameraKitEventBase = object.cameraKitEventBase !== void 0 && object.cameraKitEventBase !== null ? CameraKitEventBase.fromPartial(object.cameraKitEventBase) : void 0;
    message.dailySessionBucket = (_a = object.dailySessionBucket) !== null && _a !== void 0 ? _a : 0;
    message.isFirstWithinMonth = (_b = object.isFirstWithinMonth) !== null && _b !== void 0 ? _b : false;
    message.day = (_c = object.day) !== null && _c !== void 0 ? _c : "0";
    message.month = (_d = object.month) !== null && _d !== void 0 ? _d : "0";
    message.year = (_e = object.year) !== null && _e !== void 0 ? _e : "0";
    return message;
  }
};
function createBaseCameraKitSession() {
  return {
    cameraKitEventBase: void 0,
    dailySessionBucket: 0,
    isFirstWithinMonth: false,
    day: "0",
    month: "0",
    year: "0"
  };
}
var DailySessionBucket;
(function(DailySessionBucket2) {
  DailySessionBucket2[DailySessionBucket2["NO_SESSION_BUCKET"] = 0] = "NO_SESSION_BUCKET";
  DailySessionBucket2[DailySessionBucket2["ONE_SESSION"] = 1] = "ONE_SESSION";
  DailySessionBucket2[DailySessionBucket2["TWO_SESSION"] = 2] = "TWO_SESSION";
  DailySessionBucket2[DailySessionBucket2["THREE_SESSION"] = 3] = "THREE_SESSION";
  DailySessionBucket2[DailySessionBucket2["FOUR_SESSION"] = 4] = "FOUR_SESSION";
  DailySessionBucket2[DailySessionBucket2["FIVE_SESSION"] = 5] = "FIVE_SESSION";
  DailySessionBucket2[DailySessionBucket2["SIX_SESSION"] = 6] = "SIX_SESSION";
  DailySessionBucket2[DailySessionBucket2["SEVEN_SESSION"] = 7] = "SEVEN_SESSION";
  DailySessionBucket2[DailySessionBucket2["EIGHT_SESSION"] = 8] = "EIGHT_SESSION";
  DailySessionBucket2[DailySessionBucket2["NINE_SESSION"] = 9] = "NINE_SESSION";
  DailySessionBucket2[DailySessionBucket2["TEN_OR_MORE_SESSION"] = 10] = "TEN_OR_MORE_SESSION";
  DailySessionBucket2[DailySessionBucket2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(DailySessionBucket || (DailySessionBucket = {}));
var CameraKitLensContentValidationFailed = {
  encode(message, writer = import_minimal19.default.Writer.create()) {
    if (message.cameraKitEventBase !== void 0) {
      CameraKitEventBase.encode(message.cameraKitEventBase, writer.uint32(10).fork()).ldelim();
    }
    if (message.lensId !== "") {
      writer.uint32(18).string(message.lensId);
    }
    return writer;
  },
  fromPartial(object) {
    var _a;
    const message = createBaseCameraKitLensContentValidationFailed();
    message.cameraKitEventBase = object.cameraKitEventBase !== void 0 && object.cameraKitEventBase !== null ? CameraKitEventBase.fromPartial(object.cameraKitEventBase) : void 0;
    message.lensId = (_a = object.lensId) !== null && _a !== void 0 ? _a : "";
    return message;
  }
};
function createBaseCameraKitLensContentValidationFailed() {
  return { cameraKitEventBase: void 0, lensId: "" };
}
var CameraKitAssetValidationFailed = {
  encode(message, writer = import_minimal19.default.Writer.create()) {
    if (message.cameraKitEventBase !== void 0) {
      CameraKitEventBase.encode(message.cameraKitEventBase, writer.uint32(10).fork()).ldelim();
    }
    if (message.assetId !== "") {
      writer.uint32(26).string(message.assetId);
    }
    return writer;
  },
  fromPartial(object) {
    var _a;
    const message = createBaseCameraKitAssetValidationFailed();
    message.cameraKitEventBase = object.cameraKitEventBase !== void 0 && object.cameraKitEventBase !== null ? CameraKitEventBase.fromPartial(object.cameraKitEventBase) : void 0;
    message.assetId = (_a = object.assetId) !== null && _a !== void 0 ? _a : "";
    return message;
  }
};
function createBaseCameraKitAssetValidationFailed() {
  return { cameraKitEventBase: void 0, assetId: "" };
}
var CameraKitWebBenchmarkComplete = {
  encode(message, writer = import_minimal19.default.Writer.create()) {
    if (message.cameraKitEventBase !== void 0) {
      CameraKitEventBase.encode(message.cameraKitEventBase, writer.uint32(10).fork()).ldelim();
    }
    if (message.benchmarkName !== "") {
      writer.uint32(18).string(message.benchmarkName);
    }
    if (message.benchmarkValue !== 0) {
      writer.uint32(25).double(message.benchmarkValue);
    }
    if (message.performanceCluster !== "0") {
      writer.uint32(32).uint64(message.performanceCluster);
    }
    if (message.webglRendererInfo !== "") {
      writer.uint32(42).string(message.webglRendererInfo);
    }
    return writer;
  },
  fromPartial(object) {
    var _a, _b, _c, _d;
    const message = createBaseCameraKitWebBenchmarkComplete();
    message.cameraKitEventBase = object.cameraKitEventBase !== void 0 && object.cameraKitEventBase !== null ? CameraKitEventBase.fromPartial(object.cameraKitEventBase) : void 0;
    message.benchmarkName = (_a = object.benchmarkName) !== null && _a !== void 0 ? _a : "";
    message.benchmarkValue = (_b = object.benchmarkValue) !== null && _b !== void 0 ? _b : 0;
    message.performanceCluster = (_c = object.performanceCluster) !== null && _c !== void 0 ? _c : "0";
    message.webglRendererInfo = (_d = object.webglRendererInfo) !== null && _d !== void 0 ? _d : "";
    return message;
  }
};
function createBaseCameraKitWebBenchmarkComplete() {
  return {
    cameraKitEventBase: void 0,
    benchmarkName: "",
    benchmarkValue: 0,
    performanceCluster: "0",
    webglRendererInfo: ""
  };
}
var CameraKitLegalPrompt = {
  encode(message, writer = import_minimal19.default.Writer.create()) {
    if (message.cameraKitEventBase !== void 0) {
      CameraKitEventBase.encode(message.cameraKitEventBase, writer.uint32(10).fork()).ldelim();
    }
    if (message.legalPromptId !== "") {
      writer.uint32(18).string(message.legalPromptId);
    }
    if (message.legalPromptResult !== 0) {
      writer.uint32(24).int32(message.legalPromptResult);
    }
    return writer;
  },
  fromPartial(object) {
    var _a, _b;
    const message = createBaseCameraKitLegalPrompt();
    message.cameraKitEventBase = object.cameraKitEventBase !== void 0 && object.cameraKitEventBase !== null ? CameraKitEventBase.fromPartial(object.cameraKitEventBase) : void 0;
    message.legalPromptId = (_a = object.legalPromptId) !== null && _a !== void 0 ? _a : "";
    message.legalPromptResult = (_b = object.legalPromptResult) !== null && _b !== void 0 ? _b : 0;
    return message;
  }
};
function createBaseCameraKitLegalPrompt() {
  return { cameraKitEventBase: void 0, legalPromptId: "", legalPromptResult: 0 };
}
var CameraKitEventBase = {
  encode(message, writer = import_minimal19.default.Writer.create()) {
    if (message.kitEventBase !== void 0) {
      KitEventBase.encode(message.kitEventBase, writer.uint32(10).fork()).ldelim();
    }
    if (message.deviceCluster !== "0") {
      writer.uint32(16).uint64(message.deviceCluster);
    }
    if (message.cameraKitVersion !== "") {
      writer.uint32(26).string(message.cameraKitVersion);
    }
    if (message.lensCoreVersion !== "") {
      writer.uint32(34).string(message.lensCoreVersion);
    }
    if (message.deviceModel !== "") {
      writer.uint32(42).string(message.deviceModel);
    }
    if (message.cameraKitVariant !== 0) {
      writer.uint32(48).int32(message.cameraKitVariant);
    }
    if (message.cameraKitFlavor !== 0) {
      writer.uint32(56).int32(message.cameraKitFlavor);
    }
    if (message.appId !== "") {
      writer.uint32(66).string(message.appId);
    }
    if (message.deviceConnectivity !== 0) {
      writer.uint32(72).int32(message.deviceConnectivity);
    }
    if (message.sessionId !== "") {
      writer.uint32(82).string(message.sessionId);
    }
    if (message.appVendorUuid !== "") {
      writer.uint32(90).string(message.appVendorUuid);
    }
    if (message.rankingRequestId !== "") {
      writer.uint32(98).string(message.rankingRequestId);
    }
    if (message.cameraKitEnvironment !== 0) {
      writer.uint32(104).int32(message.cameraKitEnvironment);
    }
    if (message.partnerUuid !== "") {
      writer.uint32(114).string(message.partnerUuid);
    }
    return writer;
  },
  fromPartial(object) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o;
    const message = createBaseCameraKitEventBase();
    message.kitEventBase = object.kitEventBase !== void 0 && object.kitEventBase !== null ? KitEventBase.fromPartial(object.kitEventBase) : void 0;
    message.deviceCluster = (_a = object.deviceCluster) !== null && _a !== void 0 ? _a : "0";
    message.cameraKitVersion = (_b = object.cameraKitVersion) !== null && _b !== void 0 ? _b : "";
    message.lensCoreVersion = (_c = object.lensCoreVersion) !== null && _c !== void 0 ? _c : "";
    message.deviceModel = (_d = object.deviceModel) !== null && _d !== void 0 ? _d : "";
    message.cameraKitVariant = (_e = object.cameraKitVariant) !== null && _e !== void 0 ? _e : 0;
    message.cameraKitFlavor = (_f = object.cameraKitFlavor) !== null && _f !== void 0 ? _f : 0;
    message.appId = (_g = object.appId) !== null && _g !== void 0 ? _g : "";
    message.deviceConnectivity = (_h = object.deviceConnectivity) !== null && _h !== void 0 ? _h : 0;
    message.sessionId = (_j = object.sessionId) !== null && _j !== void 0 ? _j : "";
    message.appVendorUuid = (_k = object.appVendorUuid) !== null && _k !== void 0 ? _k : "";
    message.rankingRequestId = (_l = object.rankingRequestId) !== null && _l !== void 0 ? _l : "";
    message.cameraKitEnvironment = (_m = object.cameraKitEnvironment) !== null && _m !== void 0 ? _m : 0;
    message.partnerUuid = (_o = object.partnerUuid) !== null && _o !== void 0 ? _o : "";
    return message;
  }
};
function createBaseCameraKitEventBase() {
  return {
    kitEventBase: void 0,
    deviceCluster: "0",
    cameraKitVersion: "",
    lensCoreVersion: "",
    deviceModel: "",
    cameraKitVariant: 0,
    cameraKitFlavor: 0,
    appId: "",
    deviceConnectivity: 0,
    sessionId: "",
    appVendorUuid: "",
    rankingRequestId: "",
    cameraKitEnvironment: 0,
    partnerUuid: ""
  };
}
var KitEventBase = {
  encode(message, writer = import_minimal19.default.Writer.create()) {
    if (message.oauthClientId !== "") {
      writer.uint32(10).string(message.oauthClientId);
    }
    if (message.locale !== "") {
      writer.uint32(18).string(message.locale);
    }
    if (message.kitUserAgent !== "") {
      writer.uint32(26).string(message.kitUserAgent);
    }
    if (message.ipAddress !== "") {
      writer.uint32(34).string(message.ipAddress);
    }
    if (message.osMinorVersion !== "") {
      writer.uint32(42).string(message.osMinorVersion);
    }
    if (message.kitVariant !== 0) {
      writer.uint32(48).int32(message.kitVariant);
    }
    if (message.kitVariantVersion !== "") {
      writer.uint32(58).string(message.kitVariantVersion);
    }
    if (message.kitClientTimestampMillis !== "0") {
      writer.uint32(64).uint64(message.kitClientTimestampMillis);
    }
    if (message.clientSequenceId !== "0") {
      writer.uint32(72).uint64(message.clientSequenceId);
    }
    if (message.maxClientSequenceIdOnInstance !== "0") {
      writer.uint32(80).uint64(message.maxClientSequenceIdOnInstance);
    }
    if (message.targetArchitecture !== "") {
      writer.uint32(90).string(message.targetArchitecture);
    }
    if (message.runningWithDebuggerAttached === true) {
      writer.uint32(96).bool(message.runningWithDebuggerAttached);
    }
    if (message.runningInTests === true) {
      writer.uint32(104).bool(message.runningInTests);
    }
    if (message.runningInSimulator === true) {
      writer.uint32(112).bool(message.runningInSimulator);
    }
    if (message.isAppPrerelease === true) {
      writer.uint32(120).bool(message.isAppPrerelease);
    }
    if (message.kitAppId !== "") {
      writer.uint32(130).string(message.kitAppId);
    }
    if (message.kitSessionId !== "") {
      writer.uint32(138).string(message.kitSessionId);
    }
    if (message.kitPluginType !== 0) {
      writer.uint32(144).int32(message.kitPluginType);
    }
    if (message.isFromReactNativePlugin === true) {
      writer.uint32(152).bool(message.isFromReactNativePlugin);
    }
    return writer;
  },
  fromPartial(object) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u;
    const message = createBaseKitEventBase();
    message.oauthClientId = (_a = object.oauthClientId) !== null && _a !== void 0 ? _a : "";
    message.locale = (_b = object.locale) !== null && _b !== void 0 ? _b : "";
    message.kitUserAgent = (_c = object.kitUserAgent) !== null && _c !== void 0 ? _c : "";
    message.ipAddress = (_d = object.ipAddress) !== null && _d !== void 0 ? _d : "";
    message.osMinorVersion = (_e = object.osMinorVersion) !== null && _e !== void 0 ? _e : "";
    message.kitVariant = (_f = object.kitVariant) !== null && _f !== void 0 ? _f : 0;
    message.kitVariantVersion = (_g = object.kitVariantVersion) !== null && _g !== void 0 ? _g : "";
    message.kitClientTimestampMillis = (_h = object.kitClientTimestampMillis) !== null && _h !== void 0 ? _h : "0";
    message.clientSequenceId = (_j = object.clientSequenceId) !== null && _j !== void 0 ? _j : "0";
    message.maxClientSequenceIdOnInstance = (_k = object.maxClientSequenceIdOnInstance) !== null && _k !== void 0 ? _k : "0";
    message.targetArchitecture = (_l = object.targetArchitecture) !== null && _l !== void 0 ? _l : "";
    message.runningWithDebuggerAttached = (_m = object.runningWithDebuggerAttached) !== null && _m !== void 0 ? _m : false;
    message.runningInTests = (_o = object.runningInTests) !== null && _o !== void 0 ? _o : false;
    message.runningInSimulator = (_p = object.runningInSimulator) !== null && _p !== void 0 ? _p : false;
    message.isAppPrerelease = (_q = object.isAppPrerelease) !== null && _q !== void 0 ? _q : false;
    message.kitAppId = (_r = object.kitAppId) !== null && _r !== void 0 ? _r : "";
    message.kitSessionId = (_s = object.kitSessionId) !== null && _s !== void 0 ? _s : "";
    message.kitPluginType = (_t = object.kitPluginType) !== null && _t !== void 0 ? _t : 0;
    message.isFromReactNativePlugin = (_u = object.isFromReactNativePlugin) !== null && _u !== void 0 ? _u : false;
    return message;
  }
};
function createBaseKitEventBase() {
  return {
    oauthClientId: "",
    locale: "",
    kitUserAgent: "",
    ipAddress: "",
    osMinorVersion: "",
    kitVariant: 0,
    kitVariantVersion: "",
    kitClientTimestampMillis: "0",
    clientSequenceId: "0",
    maxClientSequenceIdOnInstance: "0",
    targetArchitecture: "",
    runningWithDebuggerAttached: false,
    runningInTests: false,
    runningInSimulator: false,
    isAppPrerelease: false,
    kitAppId: "",
    kitSessionId: "",
    kitPluginType: 0,
    isFromReactNativePlugin: false
  };
}
var CameraKitLegalPromptResult;
(function(CameraKitLegalPromptResult2) {
  CameraKitLegalPromptResult2[CameraKitLegalPromptResult2["CAMERA_KIT_LEGAL_PROMPT_MISSING"] = 0] = "CAMERA_KIT_LEGAL_PROMPT_MISSING";
  CameraKitLegalPromptResult2[CameraKitLegalPromptResult2["CAMERA_KIT_LEGAL_PROMPT_ACCEPTED"] = 1] = "CAMERA_KIT_LEGAL_PROMPT_ACCEPTED";
  CameraKitLegalPromptResult2[CameraKitLegalPromptResult2["CAMERA_KIT_LEGAL_PROMPT_DISMISSED"] = 2] = "CAMERA_KIT_LEGAL_PROMPT_DISMISSED";
  CameraKitLegalPromptResult2[CameraKitLegalPromptResult2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(CameraKitLegalPromptResult || (CameraKitLegalPromptResult = {}));
var CameraKitEnvironment2;
(function(CameraKitEnvironment3) {
  CameraKitEnvironment3[CameraKitEnvironment3["CAMERA_KIT_ENVIRONMENT_UNKNOWN"] = 0] = "CAMERA_KIT_ENVIRONMENT_UNKNOWN";
  CameraKitEnvironment3[CameraKitEnvironment3["CAMERA_KIT_ENVIRONMENT_STAGING"] = 1] = "CAMERA_KIT_ENVIRONMENT_STAGING";
  CameraKitEnvironment3[CameraKitEnvironment3["CAMERA_KIT_ENVIRONMENT_PRODUCTION"] = 2] = "CAMERA_KIT_ENVIRONMENT_PRODUCTION";
  CameraKitEnvironment3[CameraKitEnvironment3["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(CameraKitEnvironment2 || (CameraKitEnvironment2 = {}));
var CameraKitConnectivityType2;
(function(CameraKitConnectivityType3) {
  CameraKitConnectivityType3[CameraKitConnectivityType3["CAMERA_KIT_CONNECTIVITY_TYPE_UNKNOWN"] = 0] = "CAMERA_KIT_CONNECTIVITY_TYPE_UNKNOWN";
  CameraKitConnectivityType3[CameraKitConnectivityType3["CAMERA_KIT_CONNECTIVITY_TYPE_WIFI"] = 1] = "CAMERA_KIT_CONNECTIVITY_TYPE_WIFI";
  CameraKitConnectivityType3[CameraKitConnectivityType3["CAMERA_KIT_CONNECTIVITY_TYPE_MOBILE"] = 2] = "CAMERA_KIT_CONNECTIVITY_TYPE_MOBILE";
  CameraKitConnectivityType3[CameraKitConnectivityType3["CAMERA_KIT_CONNECTIVITY_TYPE_UNREACHABLE"] = 3] = "CAMERA_KIT_CONNECTIVITY_TYPE_UNREACHABLE";
  CameraKitConnectivityType3[CameraKitConnectivityType3["CAMERA_KIT_CONNECTIVITY_TYPE_BLUETOOTH"] = 4] = "CAMERA_KIT_CONNECTIVITY_TYPE_BLUETOOTH";
  CameraKitConnectivityType3[CameraKitConnectivityType3["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(CameraKitConnectivityType2 || (CameraKitConnectivityType2 = {}));
var CameraKitFlavor2;
(function(CameraKitFlavor3) {
  CameraKitFlavor3[CameraKitFlavor3["CAMERA_KIT_FLAVOR_UNKNOWN"] = 0] = "CAMERA_KIT_FLAVOR_UNKNOWN";
  CameraKitFlavor3[CameraKitFlavor3["CAMERA_KIT_FLAVOR_DEBUG"] = 1] = "CAMERA_KIT_FLAVOR_DEBUG";
  CameraKitFlavor3[CameraKitFlavor3["CAMERA_KIT_FLAVOR_RELEASE"] = 2] = "CAMERA_KIT_FLAVOR_RELEASE";
  CameraKitFlavor3[CameraKitFlavor3["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(CameraKitFlavor2 || (CameraKitFlavor2 = {}));
var CameraKitVariant;
(function(CameraKitVariant2) {
  CameraKitVariant2[CameraKitVariant2["CAMERA_KIT_VARIANT_UNKNOWN"] = 0] = "CAMERA_KIT_VARIANT_UNKNOWN";
  CameraKitVariant2[CameraKitVariant2["CAMERA_KIT_VARIANT_PARTNER"] = 1] = "CAMERA_KIT_VARIANT_PARTNER";
  CameraKitVariant2[CameraKitVariant2["CAMERA_KIT_VARIANT_PUBLIC"] = 2] = "CAMERA_KIT_VARIANT_PUBLIC";
  CameraKitVariant2[CameraKitVariant2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(CameraKitVariant || (CameraKitVariant = {}));
var KitPluginType;
(function(KitPluginType2) {
  KitPluginType2[KitPluginType2["NO_PLUGIN"] = 0] = "NO_PLUGIN";
  KitPluginType2[KitPluginType2["UNITY"] = 1] = "UNITY";
  KitPluginType2[KitPluginType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(KitPluginType || (KitPluginType = {}));
var KitType;
(function(KitType2) {
  KitType2[KitType2["UNKNOWN_KIT_TYPE"] = 0] = "UNKNOWN_KIT_TYPE";
  KitType2[KitType2["BITMOJI_KIT"] = 1] = "BITMOJI_KIT";
  KitType2[KitType2["CREATIVE_KIT"] = 2] = "CREATIVE_KIT";
  KitType2[KitType2["LOGIN_KIT"] = 3] = "LOGIN_KIT";
  KitType2[KitType2["STORY_KIT"] = 4] = "STORY_KIT";
  KitType2[KitType2["CAMERA_KIT"] = 5] = "CAMERA_KIT";
  KitType2[KitType2["SHOP_KIT"] = 6] = "SHOP_KIT";
  KitType2[KitType2["EULA_KIT"] = 7] = "EULA_KIT";
  KitType2[KitType2["PAYMENTS_KIT"] = 8] = "PAYMENTS_KIT";
  KitType2[KitType2["INVITE_KIT"] = 9] = "INVITE_KIT";
  KitType2[KitType2["CAMERA_KIT_WEB"] = 10] = "CAMERA_KIT_WEB";
  KitType2[KitType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(KitType || (KitType = {}));

// node_modules/@snap/camera-kit/dist/handlers/mappingHandler.js
var createMappingHandler = (map2, pageVisibility, maxMapConcurrency = Number.POSITIVE_INFINITY) => {
  const buffer2 = [];
  let mapConcurrency = 0;
  const processRequest = (request) => __awaiter(void 0, void 0, void 0, function* () {
    try {
      mapConcurrency++;
      const mapped = request.map();
      if (mapped instanceof Promise)
        request.next(yield mapped);
      else if (mapped)
        request.next(mapped);
    } catch (error) {
      request.reject(error);
    } finally {
      mapConcurrency--;
    }
    while (buffer2.length > 0 && mapConcurrency < maxMapConcurrency) {
      processRequest(buffer2.shift());
    }
  });
  if (pageVisibility) {
    pageVisibility.onPageHidden(() => {
      while (buffer2.length > 0)
        processRequest(buffer2.shift());
    });
  }
  return (next) => (request, metadata) => {
    return new Promise((resolve, reject) => {
      const mappableRequest = {
        map: () => map2(request),
        next: (mappedRequest) => next(mappedRequest, metadata).then(resolve).catch(reject),
        reject
      };
      if (mapConcurrency < maxMapConcurrency)
        processRequest(mappableRequest);
      else
        buffer2.push(mappableRequest);
    });
  };
};

// node_modules/@snap/camera-kit/dist/handlers/batchingHandler.js
var createBatchingHandler = ({ batchReduce, isBatchComplete, maxBatchAge, pageVisibility }) => {
  let batchTimeout;
  let currentBatch = void 0;
  let clearOnHidden = () => {
  };
  const reducingHandler = createMappingHandler((request) => __awaiter(void 0, void 0, void 0, function* () {
    currentBatch = yield batchReduce(currentBatch, request);
    return currentBatch;
  }), pageVisibility, 1);
  const batchAndSend = (next, request, metadata) => {
    const batch = request ? batchReduce(currentBatch, request) : currentBatch;
    if (!batch)
      return;
    const complete = batch instanceof Promise ? batch.then((b2) => next(b2, metadata)).catch(() => {
    }) : next(batch, metadata).catch(() => {
    });
    currentBatch = void 0;
    clearTimeout(batchTimeout);
    clearOnHidden();
    return complete;
  };
  return (next) => (request, metadata) => __awaiter(void 0, void 0, void 0, function* () {
    if (pageVisibility && pageVisibility.isDuringVisibilityTransition("hidden")) {
      yield batchAndSend(next, request, metadata);
      return;
    }
    if (currentBatch === void 0) {
      const sendBatch = () => batchAndSend(next, void 0, metadata);
      if (maxBatchAge !== void 0)
        batchTimeout = setTimeout(sendBatch, maxBatchAge);
      if (pageVisibility)
        clearOnHidden = pageVisibility.onPageHidden(sendBatch);
    }
    const handle = reducingHandler(() => __awaiter(void 0, void 0, void 0, function* () {
      if (!currentBatch)
        return;
      if (!isBatchComplete(currentBatch))
        return;
      yield batchAndSend(next, void 0, metadata);
    }));
    return handle(request, metadata);
  });
};

// node_modules/@snap/camera-kit/dist/handlers/rateLimitingHandler.js
var delay2 = (duration) => new Promise((resolve) => setTimeout(resolve, duration));
var createRateLimitingHandler = (duration, pageVisibility) => {
  let mostRecentSendTime = void 0;
  const mappingHandler = createMappingHandler((request) => __awaiter(void 0, void 0, void 0, function* () {
    if (mostRecentSendTime !== void 0) {
      const millisUntilNextSend = duration - (Date.now() - mostRecentSendTime);
      if (millisUntilNextSend > 0)
        yield delay2(millisUntilNextSend);
    }
    mostRecentSendTime = Date.now();
    return request;
  }), pageVisibility, 1);
  return (next) => (request, metadata) => {
    if (pageVisibility && pageVisibility.isDuringVisibilityTransition("hidden"))
      return next(request, metadata);
    return mappingHandler(next)(request, metadata);
  };
};

// node_modules/@snap/camera-kit/dist/metrics/operational/Count.js
function isCountMetric(value) {
  var _a;
  return ((_a = value.metric) === null || _a === void 0 ? void 0 : _a.$case) === "count";
}
var Count = class _Count extends Metric {
  static count(name, n2, dimensions = {}) {
    const count2 = new _Count(name, dimensions);
    count2.increment(n2);
    return count2;
  }
  constructor(name, dimensions = {}) {
    super(name, dimensions);
    this.name = name;
    this.count = 0;
  }
  increment(count2) {
    this.count += count2;
    return this.count;
  }
  toOperationalMetric() {
    return [
      {
        name: `${this.name}${serializeMetricDimensions(this.dimensions)}`,
        timestamp: /* @__PURE__ */ new Date(),
        metric: { $case: "count", count: `${Math.ceil(this.count)}` }
      }
    ];
  }
};

// node_modules/@snap/camera-kit/dist/clients/metricsClient.js
var METRIC_REQUEST_RATE_LIMIT_MS = 1e3;
var BUSINESS_EVENT_BATCH_MAX_SIZE = 10;
var BUSINESS_EVENT_BATCH_MAX_AGE_MS = 5e3;
var METRIC_BATCH_MAX_SIZE = 100;
var METRIC_BATCH_MAX_AGE_MS = 5e3;
var MetricsClient = class {
  constructor(grpcClient, pageVisibility) {
    this.grpcClient = grpcClient;
    const rateLimitingHandler = createRateLimitingHandler(METRIC_REQUEST_RATE_LIMIT_MS, pageVisibility);
    this.businessEventsHandler = new HandlerChainBuilder((request) => __awaiter(this, void 0, void 0, function* () {
      yield this.grpcClient.setBusinessEvents(request);
    })).map(rateLimitingHandler).map(createMappingHandler((serverEvents) => {
      const batch = ServerEventBatch.fromPartial({ serverEvents });
      const request = {
        batchEvents: {
          typeUrl: "com.snapchat.analytics.blizzard.ServerEventBatch",
          value: ServerEventBatch.encode(batch).finish()
        }
      };
      return request;
    }, pageVisibility)).map(createBatchingHandler({
      batchReduce: (previous, event) => {
        const batch = previous !== null && previous !== void 0 ? previous : [];
        batch.push(event);
        return batch;
      },
      isBatchComplete: (batch) => batch.length >= BUSINESS_EVENT_BATCH_MAX_SIZE,
      maxBatchAge: BUSINESS_EVENT_BATCH_MAX_AGE_MS,
      pageVisibility
    })).handler;
    this.operationalMetricsHandler = new HandlerChainBuilder((metrics) => __awaiter(this, void 0, void 0, function* () {
      yield this.grpcClient.setOperationalMetrics({ metrics });
    })).map(rateLimitingHandler).map(createBatchingHandler({
      batchReduce: (previous, metric) => {
        var _a;
        const batch = { metrics: (_a = previous === null || previous === void 0 ? void 0 : previous.metrics) !== null && _a !== void 0 ? _a : [] };
        if (isCountMetric(metric)) {
          const priorCount = batch.metrics.find((m2) => {
            return isCountMetric(m2) && m2.name === metric.name;
          });
          if (priorCount && isCountMetric(priorCount)) {
            priorCount.metric.count = `${Number(priorCount.metric.count) + Number(metric.metric.count)}`;
            return batch;
          }
        }
        batch.metrics.push(metric);
        return batch;
      },
      isBatchComplete: (bundle) => bundle.metrics.length >= METRIC_BATCH_MAX_SIZE,
      maxBatchAge: METRIC_BATCH_MAX_AGE_MS,
      pageVisibility
    })).handler;
  }
  setBusinessEvents(event) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.businessEventsHandler(event);
    });
  }
  setOperationalMetrics(metric) {
    return __awaiter(this, void 0, void 0, function* () {
      yield Promise.all(metric.toOperationalMetric().map((metric2) => {
        return this.operationalMetricsHandler(metric2);
      }));
    });
  }
};
var validExternalMetrics = /^push2web_/;
var externalMetricsSubjectFactory = Injectable("externalMetricsSubject", () => new Subject());
var metricsClientFactory = Injectable("metricsClient", [externalMetricsSubjectFactory.token, grpcHandlerFactory.token, pageVisibilityFactory.token], (externalMetricsSubjectFactory2, grpcHandler, pageVisibility) => {
  const metrics = new MetricsClient(createTsProtoClient(MetricsDefinition, grpcHandler), pageVisibility);
  externalMetricsSubjectFactory2.pipe(filter((metric) => validExternalMetrics.test(metric.name))).subscribe({
    next: (metric) => {
      metrics.setOperationalMetrics(metric);
    }
  });
  return metrics;
});

// node_modules/@snap/camera-kit/dist/remote-configuration/cofHandler.js
var COF_REQUEST_TYPE = "cof";
var logger6 = getLogger("cofHandler");
var cofHandlerFactory = Injectable("cofHandler", [configurationToken, requestStateEventTargetFactory.token, metricsClientFactory.token], (config2, requestStateEventTarget, metrics) => {
  const cofCache = new ExpiringPersistence(() => convertDaysToSeconds(365), new IndexedDBPersistence({ databaseName: "COFCache" }));
  const getCacheKey2 = (r2) => JSON.stringify(r2);
  return new HandlerChainBuilder((request, _a) => __awaiter(void 0, void 0, void 0, function* () {
    var { signal, isSideEffect: _ } = _a, metadata = __rest(_a, ["signal", "isSideEffect"]);
    const rpc = new GrpcWebImpl(`https://${config2.apiHostname}`, {});
    const client = new CircumstancesServiceClientImpl(rpc);
    return new Promise((resolve, reject) => __awaiter(void 0, void 0, void 0, function* () {
      var _b;
      if (signal) {
        signal.addEventListener("abort", () => reject(new Error("COF request aborted by handler chain.")));
      }
      const cachedResponse = yield cofCache.retrieve(getCacheKey2(request)).catch((e2) => {
        logger6.warn("Unable to get COF response from cache.", e2);
        return {
          configResultsEtag: void 0,
          configResults: []
        };
      });
      const dimensions = {
        requestType: COF_REQUEST_TYPE,
        delta: `${!!(cachedResponse === null || cachedResponse === void 0 ? void 0 : cachedResponse.configResultsEtag)}`
      };
      const { requestId: requestId2 } = dispatchRequestStarted(requestStateEventTarget, { dimensions });
      try {
        const response = yield client.targetingQuery(Object.assign(Object.assign({}, request), { configResultsEtag: cachedResponse === null || cachedResponse === void 0 ? void 0 : cachedResponse.configResultsEtag, deltaSync: !!(cachedResponse === null || cachedResponse === void 0 ? void 0 : cachedResponse.configResultsEtag) }), new import_browser_headers2.BrowserHeaders(Object.assign({ authorization: `Bearer ${config2.apiToken}`, "x-snap-client-user-agent": getCameraKitUserAgent() }, metadata)));
        delete response.toObject;
        const configResults = unionBy("configId", (_b = cachedResponse === null || cachedResponse === void 0 ? void 0 : cachedResponse.configResults) !== null && _b !== void 0 ? _b : [], response.configResults).filter((config3) => !config3.delete);
        const status = 200;
        let sizeByte = 0;
        try {
          sizeByte = new TextEncoder().encode(JSON.stringify(response)).byteLength;
        } finally {
          dispatchRequestCompleted(requestStateEventTarget, {
            requestId: requestId2,
            dimensions,
            status,
            sizeByte
          });
        }
        resolve(Object.assign(Object.assign({}, response), { configResults }));
      } catch (error) {
        dispatchRequestErrored(requestStateEventTarget, {
          requestId: requestId2,
          dimensions,
          error: ensureError(error)
        });
        reject(error);
      }
    }));
  })).map(createRetryingHandler({ retryPredicate: (r2) => r2 instanceof Error })).map(createTimeoutHandler({ timeout: 20 * 1e3 })).map(createResponseCachingHandler(cofCache, getCacheKey2, staleWhileRevalidateStrategy({
    onMiss: () => {
      metrics.setOperationalMetrics(Count.count("cache_miss", 1, { request_type: "cof" }));
    }
  }))).handler;
});

// node_modules/@snap/camera-kit/dist/remote-configuration/remoteConfiguration.js
var defaultTargetingRequest = {
  namespaces: [Namespace.LENS_CORE, Namespace.CAMERA_KIT_CORE, Namespace.LENS_CORE_CONFIG]
};
var RemoteConfiguration = class {
  constructor(lensPerformance, cofHandler, grpcClient) {
    const lensCluster = Promise.resolve(lensPerformance).then((lensPerformance2) => {
      return (lensPerformance2 === null || lensPerformance2 === void 0 ? void 0 : lensPerformance2.cluster) === 0 ? void 0 : lensPerformance2 === null || lensPerformance2 === void 0 ? void 0 : lensPerformance2.cluster;
    });
    this.configById = from(lensCluster).pipe(mergeMap((lensClusterOrig4) => from(cofHandler(Object.assign(Object.assign({}, defaultTargetingRequest), { lensClusterOrig4 })))), map((result) => {
      const configById = /* @__PURE__ */ new Map();
      result.configResults.forEach((config2) => {
        var _a;
        const configsWithId = (_a = configById.get(config2.configId)) !== null && _a !== void 0 ? _a : [];
        configsWithId.push(config2);
        configById.set(config2.configId, configsWithId);
      });
      return configById;
    }), shareReplay(1));
    this.initializationConfig = from(grpcClient.getInitializationConfig({})).pipe(map((result) => {
      if (result.ok) {
        const response = result.unwrap();
        if (response.message)
          return response.message;
        else
          throw new Error(`Failed to load initialization config. gRPC response successful, but message was null. gRPC status: ${response.statusMessage}`);
      }
      throw new Error(`Failed to load initialization config. gRPC status message: ${result.unwrapErr().statusMessage}`);
    }), shareReplay(1));
  }
  get(configId) {
    return this.configById.pipe(map((config2) => {
      var _a;
      return (_a = config2.get(configId)) !== null && _a !== void 0 ? _a : [];
    }));
  }
  getInitializationConfig() {
    return this.initializationConfig;
  }
  getNamespace(namespace) {
    return this.configById.pipe(map((configs) => {
      const namespaceConfigs = Array.from(configs.values()).filter((values) => values.some((c2) => c2.namespace === namespace)).flatMap((results) => results);
      return namespaceConfigs;
    }));
  }
};
var remoteConfigurationFactory = Injectable("remoteConfiguration", [configurationToken, cofHandlerFactory.token, grpcHandlerFactory.token], (config2, cofHandler, grpcHandler) => {
  const remoteConfig = new RemoteConfiguration(config2.lensPerformance, cofHandler, createTsProtoClient(MetricsDefinition, grpcHandler));
  remoteConfig.get("").pipe(take(1)).subscribe();
  return remoteConfig;
});

// node_modules/@snap/camera-kit/dist/lens/assets/deviceDependentAssetLoader.js
var hasStringValue = (value) => {
  return isRecord(value) && isString(value.stringValue);
};
var isAssetConfig = (value) => {
  return isRecord(value) && isString(value.url) && (value.checksum === void 0 || isString(value.checksum));
};
var deviceDependentAssetLoaderFactory = Injectable("deviceDependentAssetLoader", [defaultFetchHandlerFactory.token, remoteConfigurationFactory.token], (fetchHandler, remoteConfiguration) => {
  const assetHandler = new HandlerChainBuilder(fetchHandler).map(createArrayBufferParsingHandler()).handler;
  return function deviceDependentAssetLoader({ assetDescriptor: { assetId }, lowPriority }) {
    return __awaiter(this, void 0, void 0, function* () {
      const loadingFailed = (reason, cause) => new Error(`Cannot load device-dependent asset ${assetId}. ${reason}`, { cause });
      return firstValueFrom(remoteConfiguration.get(assetId).pipe(catchError((error) => {
        throw loadingFailed("COF config failed to load.", error);
      }), map((configs) => {
        if (configs.length === 0) {
          throw loadingFailed(`No COF config found corresponding to that assetId.`);
        }
        const [{ value }] = configs;
        if (!hasStringValue(value))
          throw loadingFailed("COF config malformed (missing stringValue)");
        let assetConfig;
        try {
          assetConfig = JSON.parse(value.stringValue);
        } catch (parseError) {
          throw loadingFailed("COF config malformed (JSON parse error)", parseError);
        }
        if (!isAssetConfig(assetConfig))
          throw loadingFailed("COF config malformed (missing URL)");
        return assetConfig;
      }), mergeMap(({ url, checksum }) => __awaiter(this, void 0, void 0, function* () {
        const [data, response] = yield assetHandler(url, withRequestPriority({ cache: "force-cache" }, lowPriority));
        if (!response.ok)
          throw response;
        return { data, checksum };
      }))));
    });
  };
});

// node_modules/@snap/camera-kit/dist/lens/assets/remoteMediaAssetLoaderFactory.js
var remoteMediaAssetLoaderFactory = Injectable("remoteMediaAssetLoader", [defaultFetchHandlerFactory.token], (fetchHandler) => {
  const handler = new HandlerChainBuilder(fetchHandler).map(createArrayBufferParsingHandler()).handler;
  return function remoteMediaAssetLoader({ assetDescriptor: { assetId }, lowPriority }) {
    return __awaiter(this, void 0, void 0, function* () {
      const [buffer2, response] = yield handler(assetId, withRequestPriority({ cache: "force-cache" }, lowPriority));
      if (!response.ok)
        throw response;
      return buffer2;
    });
  };
});

// node_modules/@snap/camera-kit/dist/lens/assets/staticAssetLoader.js
var staticAssetLoaderFactory = Injectable("staticAssetLoader", [defaultFetchHandlerFactory.token], (fetchHandler) => {
  const handler = new HandlerChainBuilder(fetchHandler).map(createArrayBufferParsingHandler()).handler;
  return ({ assetDescriptor: { assetId }, assetManifest, lowPriority }) => __awaiter(void 0, void 0, void 0, function* () {
    var _a;
    const assetUrl = (_a = assetManifest === null || assetManifest === void 0 ? void 0 : assetManifest.find((manifest) => manifest.id === assetId)) === null || _a === void 0 ? void 0 : _a.assetUrl;
    if (!assetUrl) {
      throw new Error(`Cannot load lens asset ${assetId}. Static asset URL could not be found.`);
    }
    const [buffer2, response] = yield handler(assetUrl, withRequestPriority({ cache: "force-cache" }, lowPriority));
    if (!response.ok)
      throw response;
    return buffer2;
  });
});

// node_modules/@snap/camera-kit/dist/lens/assets/LensAssetRepository.js
var logger7 = getLogger("LensAssetRepository");
function getCacheKey(asset) {
  return `${asset.assetId}_${asset.assetType.value}`;
}
function mapManfiestItemToAssetType(lensCore, type) {
  switch (type) {
    case LensAssetManifestItem_Type.ASSET:
      return lensCore.AssetType.Static;
    case LensAssetManifestItem_Type.DEVICE_DEPENDENT_ASSET_UNSET:
    case LensAssetManifestItem_Type.UNRECOGNIZED:
      return lensCore.AssetType.DeviceDependent;
    default:
      return assertUnreachable(type);
  }
}
var LensAssetRepository = class {
  constructor(lensCore, assetLoaders, metrics, requestStateEventTarget) {
    this.lensCore = lensCore;
    this.assetLoaders = assetLoaders;
    this.metrics = metrics;
    this.requestStateEventTarget = requestStateEventTarget;
    this.cachedAssetKeys = /* @__PURE__ */ new Set();
  }
  cacheAssets(assetManifest, lens, assetTimings = [LensAssetManifestItem_RequestTiming.REQUIRED], lowPriority = false) {
    return __awaiter(this, void 0, void 0, function* () {
      const assetTimingsToPreload = /* @__PURE__ */ new Set([
        LensAssetManifestItem_RequestTiming.PRELOAD_UNSET,
        ...assetTimings
      ]);
      const assetDescriptors = assetManifest.filter((asset) => {
        return assetTimingsToPreload.has(asset.requestTiming);
      }).map(({ id, type }) => ({
        assetId: id,
        assetType: mapManfiestItemToAssetType(this.lensCore, type)
      }));
      if (assetDescriptors.length) {
        return this.cacheAssetsByDescriptor(assetDescriptors, lens, assetManifest, lowPriority);
      }
    });
  }
  loadAsset(request) {
    var _a, _b;
    return __awaiter(this, void 0, void 0, function* () {
      const { assetDescriptor: { assetId, assetType }, lens } = request;
      const [assetTypeName, assetLoader] = (_a = this.assetLoaders.get(assetType)) !== null && _a !== void 0 ? _a : [];
      const safeAssetTypeName = assetTypeName !== null && assetTypeName !== void 0 ? assetTypeName : "unknown";
      const dimensions = {
        requestType: "asset",
        assetId,
        assetType: safeAssetTypeName,
        lensId: (_b = lens === null || lens === void 0 ? void 0 : lens.id) !== null && _b !== void 0 ? _b : "unknown"
      };
      const { requestId: requestId2 } = dispatchRequestStarted(this.requestStateEventTarget, { dimensions });
      try {
        if (!assetLoader) {
          throw new Error(`Cannot get asset ${assetId}. Asset type ${safeAssetTypeName} is not supported.`);
        }
        const assetResponse = yield assetLoader(request);
        const assetBuffer = "data" in assetResponse ? assetResponse.data : assetResponse;
        const assetChecksum = "checksum" in assetResponse ? assetResponse.checksum : void 0;
        if (assetBuffer.byteLength === 0) {
          throw new Error(`Got empty response for asset ${assetId} from ${safeAssetTypeName} loader.`);
        }
        dispatchRequestCompleted(this.requestStateEventTarget, {
          requestId: requestId2,
          dimensions,
          status: 200,
          sizeByte: assetBuffer.byteLength
        });
        this.lensCore.provideRemoteAssetsResponse({
          assetId,
          assetBuffer,
          assetType,
          assetChecksum,
          onFailure: (lensCoreError) => {
            if (/validation failed/.test(lensCoreError.message)) {
              this.metrics.dispatchEvent(new TypedCustomEvent("assetValidationFailed", {
                name: "assetValidationFailed",
                assetId
              }));
            }
            logger7.warn(`Failed to provide lens asset ${assetId}.`, lensCoreError);
          }
        });
      } catch (error) {
        const wrappedError = new Error(`Failed to load lens asset ${assetId}.`, { cause: error });
        dispatchRequestErrored(this.requestStateEventTarget, { requestId: requestId2, dimensions, error: wrappedError });
        throw wrappedError;
      }
    });
  }
  cacheAssetsByDescriptor(assetDescriptors, lens, assetManifest, lowPriority) {
    return __awaiter(this, void 0, void 0, function* () {
      yield Promise.all(assetDescriptors.filter((assetDescriptors2) => !this.cachedAssetKeys.has(getCacheKey(assetDescriptors2))).map((assetDescriptor) => __awaiter(this, void 0, void 0, function* () {
        var _a;
        try {
          yield this.loadAsset({ assetDescriptor, lens, assetManifest, lowPriority });
          this.cachedAssetKeys.add(getCacheKey(assetDescriptor));
        } catch (error) {
          const { assetId, assetType } = assetDescriptor;
          const [assetTypeName] = (_a = this.assetLoaders.get(assetType)) !== null && _a !== void 0 ? _a : [];
          logger7.warn(`Failed to cache asset ${assetId} of type ${assetTypeName !== null && assetTypeName !== void 0 ? assetTypeName : assetType.value}.`, error);
        }
      })));
    });
  }
};
var lensAssetRepositoryFactory = Injectable("lensAssetRepository", [
  lensCoreFactory.token,
  deviceDependentAssetLoaderFactory.token,
  remoteMediaAssetLoaderFactory.token,
  staticAssetLoaderFactory.token,
  metricsEventTargetFactory.token,
  requestStateEventTargetFactory.token
], (lensCore, deviceDependentAssetLoader, remoteMediaAssetLoader, staticAssetLoader, metrics, requestStateEventTarget) => new LensAssetRepository(lensCore, /* @__PURE__ */ new Map([
  [lensCore.AssetType.DeviceDependent, ["DeviceDependent", deviceDependentAssetLoader]],
  [lensCore.AssetType.RemoteMediaByUrl, ["RemoteMediaByUrl", remoteMediaAssetLoader]],
  [lensCore.AssetType.URL, ["URL", remoteMediaAssetLoader]],
  [lensCore.AssetType.Static, ["Static", staticAssetLoader]]
]), metrics, requestStateEventTarget));

// node_modules/@snap/camera-kit/dist/generated-proto/pb_schema/camera_kit/v3/export.js
var import_long19 = __toESM(require_long());
var import_minimal20 = __toESM(require_minimal2());
var ExportLensesByIdRequest_Context_Extension_Name;
(function(ExportLensesByIdRequest_Context_Extension_Name2) {
  ExportLensesByIdRequest_Context_Extension_Name2["UNSET"] = "UNSET";
  ExportLensesByIdRequest_Context_Extension_Name2["SHOP_KIT"] = "SHOP_KIT";
  ExportLensesByIdRequest_Context_Extension_Name2["LENS_WEB_BUILDER"] = "LENS_WEB_BUILDER";
  ExportLensesByIdRequest_Context_Extension_Name2["UNRECOGNIZED"] = "UNRECOGNIZED";
})(ExportLensesByIdRequest_Context_Extension_Name || (ExportLensesByIdRequest_Context_Extension_Name = {}));
var ExportLensesByIdResponse_ExcludedLens_Code;
(function(ExportLensesByIdResponse_ExcludedLens_Code2) {
  ExportLensesByIdResponse_ExcludedLens_Code2["UNSET"] = "UNSET";
  ExportLensesByIdResponse_ExcludedLens_Code2["UNKNOWN"] = "UNKNOWN";
  ExportLensesByIdResponse_ExcludedLens_Code2["NOT_FOUND"] = "NOT_FOUND";
  ExportLensesByIdResponse_ExcludedLens_Code2["INCOMPATIBLE_LENS_CORE_VERSION"] = "INCOMPATIBLE_LENS_CORE_VERSION";
  ExportLensesByIdResponse_ExcludedLens_Code2["ARCHIVED_OR_INVISIBLE"] = "ARCHIVED_OR_INVISIBLE";
  ExportLensesByIdResponse_ExcludedLens_Code2["CONTAINS_MUSIC"] = "CONTAINS_MUSIC";
  ExportLensesByIdResponse_ExcludedLens_Code2["UNRECOGNIZED"] = "UNRECOGNIZED";
})(ExportLensesByIdResponse_ExcludedLens_Code || (ExportLensesByIdResponse_ExcludedLens_Code = {}));
function createBaseExtensionRequestContext() {
  return { userAgent: "", locale: "" };
}
var ExtensionRequestContext = {
  encode(message, writer = import_minimal20.default.Writer.create()) {
    if (message.userAgent !== "") {
      writer.uint32(10).string(message.userAgent);
    }
    if (message.locale !== "") {
      writer.uint32(18).string(message.locale);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal20.default.Reader ? input : new import_minimal20.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseExtensionRequestContext();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.userAgent = reader.string();
          break;
        case 2:
          message.locale = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(object) {
    var _a, _b;
    const message = createBaseExtensionRequestContext();
    message.userAgent = (_a = object.userAgent) !== null && _a !== void 0 ? _a : "";
    message.locale = (_b = object.locale) !== null && _b !== void 0 ? _b : "";
    return message;
  }
};
function createBaseEnvelope() {
  return { lenses: [] };
}
var Envelope = {
  decode(input, length) {
    const reader = input instanceof import_minimal20.default.Reader ? input : new import_minimal20.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseEnvelope();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.lenses.push(Lens.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(object) {
    var _a;
    const message = createBaseEnvelope();
    message.lenses = ((_a = object.lenses) === null || _a === void 0 ? void 0 : _a.map((e2) => Lens.fromPartial(e2))) || [];
    return message;
  }
};
if (import_minimal20.default.util.Long !== import_long19.default) {
  import_minimal20.default.util.Long = import_long19.default;
  import_minimal20.default.configure();
}

// node_modules/@snap/camera-kit/dist/lens/LensSource.js
var lensSourcesFactory = Injectable("lensSources", () => []);
function loadLensesFromSources(sources, groupId, lensId) {
  return __awaiter(this, void 0, void 0, function* () {
    const source = sources.find((source2) => source2.isGroupOwner(groupId));
    if (!source) {
      throw new Error(`Cannot load lens ${lensId ? `${lensId} from ` : ""}group ${groupId}. No LensSource claimed ownership of that lens group.`);
    }
    const envelope = lensId === void 0 ? yield source.loadLensGroup(groupId) : yield source.loadLens(lensId, groupId);
    return envelope instanceof ArrayBuffer || ArrayBuffer.isView(envelope) ? Envelope.decode(envelope instanceof Uint8Array ? envelope : new Uint8Array(envelope)).lenses : [];
  });
}

// node_modules/@snap/camera-kit/dist/lens/LensRepository.js
var logger8 = getLogger("LensRepository");
var assetTimingMap = {
  required: LensAssetManifestItem_RequestTiming.REQUIRED,
  onDemand: LensAssetManifestItem_RequestTiming.ON_DEMAND
};
function isAssetTiming(value) {
  return isString(value) && assetTimingMap.hasOwnProperty(value);
}
function isAssetTimingArrayOrUndefined(value) {
  return isUndefined(value) || isArrayOfType(isAssetTiming, value);
}
var LensRepository = (() => {
  var _a;
  let _instanceExtraInitializers = [];
  let _loadLens_decorators;
  let _loadLensGroups_decorators;
  let _cacheLensContent_decorators;
  return _a = class LensRepository {
    constructor(lensFetchHandler, lensSources, lensAssetRepository) {
      this.lensFetchHandler = (__runInitializers(this, _instanceExtraInitializers), lensFetchHandler);
      this.lensSources = lensSources;
      this.lensAssetRepository = lensAssetRepository;
      this.metadataCache = /* @__PURE__ */ new Map();
      this.binariesCache = /* @__PURE__ */ new Map();
    }
    loadLens(lensId, groupId) {
      return __awaiter(this, void 0, void 0, function* () {
        const lens = (yield loadLensesFromSources(this.lensSources, groupId, lensId))[0];
        if (!lens) {
          throw new Error(`Cannot load lens. No lens with id ${lensId} was found in lens group ${groupId}.`);
        }
        const lensWithGroup = Object.assign(Object.assign({}, lens), { groupId });
        this.metadataCache.set(lens.id, lensWithGroup);
        return toPublicLens(lensWithGroup);
      });
    }
    loadLensGroups(groupIds) {
      return __awaiter(this, void 0, void 0, function* () {
        const responses = yield Promise.all(groupIds.map((groupId) => __awaiter(this, void 0, void 0, function* () {
          try {
            return (yield loadLensesFromSources(this.lensSources, groupId)).map((lens) => {
              const lensWithGroup = Object.assign(Object.assign({}, lens), { groupId });
              this.metadataCache.set(lens.id, lensWithGroup);
              return toPublicLens(lensWithGroup);
            });
          } catch (e2) {
            const error = ensureError(e2);
            logger8.error(new Error(`Failed to load lens group ${groupId}.`, { cause: error }));
            return error;
          }
        })));
        return responses.reduce((result, response) => {
          if (response instanceof Error)
            result.errors.push(response);
          else
            result.lenses.push(...response);
          return result;
        }, { errors: [], lenses: [] });
      });
    }
    cacheLensContent(lenses, assetTimingsToCache = ["required", "onDemand"]) {
      return __awaiter(this, void 0, void 0, function* () {
        const assetTimingsToLoad = assetTimingsToCache.map((timing) => assetTimingMap[timing]);
        yield Promise.all(lenses.map((lens) => __awaiter(this, void 0, void 0, function* () {
          try {
            const { lensBuffer } = yield this.getLensContent(lens, true);
            const { content } = this.metadataCache.get(lens.id);
            this.binariesCache.set(lens.id, lensBuffer);
            yield this.lensAssetRepository.cacheAssets(content.assetManifest, lens, assetTimingsToLoad, true);
          } catch (error) {
            logger8.warn(`Failed to cache lens ${lens.id}.`, error);
          }
        })));
      });
    }
    getLensMetadata(lensId) {
      return this.metadataCache.get(lensId);
    }
    removeCachedLenses(lenses) {
      lenses.forEach((lens) => this.binariesCache.delete(lens.id));
    }
    getLensContent(lens, lowPriority = false) {
      var _a2;
      return __awaiter(this, void 0, void 0, function* () {
        const { content } = (_a2 = this.metadataCache.get(lens.id)) !== null && _a2 !== void 0 ? _a2 : {};
        if (!content) {
          throw new Error(`Cannot find metadata for lens ${lens.id}.`);
        }
        const cachedLensBuffer = this.binariesCache.get(lens.id);
        if (cachedLensBuffer) {
          return {
            lensBuffer: cachedLensBuffer,
            lensChecksum: content.lnsSha256
          };
        }
        const [lensBuffer] = yield this.lensFetchHandler([
          new Request(content.lnsUrlBolt, withRequestPriority({ cache: "force-cache" }, lowPriority)),
          {
            requestType: "lens_content",
            lensId: lens.id
          }
        ]);
        return { lensBuffer, lensChecksum: content.lnsSha256 };
      });
    }
  }, (() => {
    _loadLens_decorators = [validate(isSafeString, isSafeString), errorLoggingDecorator(logger8)];
    _loadLensGroups_decorators = [validate(isSafeStringArray), errorLoggingDecorator(logger8)];
    _cacheLensContent_decorators = [validate(isLensArray, isAssetTimingArrayOrUndefined), errorLoggingDecorator(logger8)];
    __esDecorate(_a, null, _loadLens_decorators, { kind: "method", name: "loadLens", static: false, private: false, access: { has: (obj) => "loadLens" in obj, get: (obj) => obj.loadLens } }, null, _instanceExtraInitializers);
    __esDecorate(_a, null, _loadLensGroups_decorators, { kind: "method", name: "loadLensGroups", static: false, private: false, access: { has: (obj) => "loadLensGroups" in obj, get: (obj) => obj.loadLensGroups } }, null, _instanceExtraInitializers);
    __esDecorate(_a, null, _cacheLensContent_decorators, { kind: "method", name: "cacheLensContent", static: false, private: false, access: { has: (obj) => "cacheLensContent" in obj, get: (obj) => obj.cacheLensContent } }, null, _instanceExtraInitializers);
  })(), _a;
})();
var lensRepositoryFactory = Injectable("LensRepository", [
  requestStateEventTargetFactory.token,
  defaultFetchHandlerFactory.token,
  lensSourcesFactory.token,
  lensAssetRepositoryFactory.token
], (requestStateEventTarget, defaultFetchHandler, lensSources, lensAssetRepository) => {
  const lensFetchHandler = new HandlerChainBuilder(defaultFetchHandler).map(createRequestStateEmittingHandler(requestStateEventTarget)).map(createArrayBufferParsingHandler()).handler;
  return new LensRepository(lensFetchHandler, lensSources, lensAssetRepository);
});

// node_modules/@snap/camera-kit/dist/dependency-injection/PartialContainer.js
var PartialContainer = class _PartialContainer {
  constructor(injectables) {
    this.injectables = injectables;
  }
  provides(fn) {
    return new _PartialContainer(Object.assign(Object.assign({}, this.injectables), { [fn.token]: fn }));
  }
  getFactories(parent) {
    return Object.fromEntries(entries(this.injectables).map(([token, fn]) => {
      return [
        token,
        memoize((c2) => {
          return fn(...fn.dependencies.map((t2) => {
            return t2 === token ? parent.get(t2) : c2.get(t2);
          }));
        })
      ];
    }));
  }
  getTokens() {
    return Object.keys(this.injectables);
  }
};

// node_modules/@snap/camera-kit/dist/dependency-injection/Container.js
var CONTAINER = "$container";
var Container = class _Container {
  static provides(fnOrContainer) {
    if (fnOrContainer instanceof PartialContainer)
      return new _Container({}).provides(fnOrContainer);
    if (fnOrContainer instanceof _Container)
      return new _Container({}).provides(fnOrContainer);
    return new _Container({}).provides(fnOrContainer);
  }
  constructor(factories) {
    this.factories = {};
    for (const k2 in factories) {
      const fn = factories[k2];
      if (isMemoized(fn))
        this.factories[k2] = fn;
      else
        this.factories[k2] = memoize(fn);
    }
  }
  copy(scopedServices) {
    const factories = Object.assign({}, this.factories);
    (scopedServices || []).forEach((token) => {
      factories[token] = this.factories[token].delegate;
    });
    return new _Container(factories);
  }
  get(token) {
    if (token === CONTAINER)
      return this;
    const factory = this.factories[token];
    if (!factory) {
      throw new Error(`[Container::get] Could not find Service for Token "${String(token)}". This should've caused a compile-time error. If the Token is 'undefined', check all your calls to the Injectable function. Make sure you define dependencies using string literals or string constants that are definitely initialized before the call to Injectable.`);
    }
    return factory(this);
  }
  run(fnOrContainer) {
    if (fnOrContainer instanceof PartialContainer) {
      const runnableContainer = this.provides(fnOrContainer);
      for (const token of fnOrContainer.getTokens()) {
        runnableContainer.get(token);
      }
    } else {
      this.provides(fnOrContainer).get(fnOrContainer.token);
    }
    return this;
  }
  provides(fnOrContainer) {
    if (fnOrContainer instanceof PartialContainer || fnOrContainer instanceof _Container) {
      const factories = fnOrContainer instanceof PartialContainer ? fnOrContainer.getFactories(this) : fnOrContainer.factories;
      return new _Container(Object.assign(Object.assign({}, this.factories), factories));
    }
    return this.providesService(fnOrContainer);
  }
  providesService(fn) {
    const token = fn.token;
    const dependencies = fn.dependencies;
    const factory = memoize((container) => {
      return fn(...dependencies.map((t2) => {
        return t2 === token ? this.get(t2) : container.get(t2);
      }));
    });
    const factories = Object.assign(Object.assign({}, this.factories), { [token]: factory });
    return new _Container(factories);
  }
};

// node_modules/@snap/state-management/dist/types.js
var fromEntries2 = (entries2) => Object.fromEntries(entries2);

// node_modules/@snap/state-management/dist/actions.js
var defineAction = (name) => () => {
  const actionCreator = (data) => ({
    name,
    data
  });
  Object.defineProperty(actionCreator, "name", { value: name });
  return actionCreator;
};
var defineActions = (...actions) => {
  const entries2 = actions.map((s2) => [s2.name, s2]);
  return fromEntries2(entries2);
};
function forActions(...actions) {
  return filter((v2) => actions.some((action) => v2[0].name === action));
}
function isAction(action, name) {
  return action.name === name;
}

// node_modules/@snap/state-management/dist/state-machine.js
var StateMachine = class {
  /**
   * Create a StateMachine with a defined set of Actions and States.
   *
   * The StateMachine begins in a given initial state with transitions to new states defined by a "reducer" function.
   *
   * Reducers are OperatorFunctions which map an Observable of `[Action, State]` pairs into an Observable of a new
   * state. They can be constructed using RxJS's `pipe` function. For example:
   *
   * ```ts
   * new StateMachine(actions, states, initialState, pipe(
   *   inStates('someState'),
   *   forActions('someAction'),
   *   map(([a, s]) => computeNewState(a, s)),
   * ))
   * ```
   *
   * Often it will be useful to break the reducer into separate behaviors to handle different actions:
   *
   * ```ts
   * new StateMachine(actions, states, initialState, state => {
   *   return merge(
   *     state.pipe(inStates('someState'), forAction('someAction'), map(computeNextState)),
   *     state.pipe(inStates('otherState'), forAction('otherAction'), map(computeOtherNextState)),
   *     // ...
   *   )
   * })
   * ```
   *
   * Reducers must return an output Observable<State> which, when the input Observable<[Action, State]> emits, either:
   *
   * - synchronously emits a single new state.
   * - emits nothing.
   *
   * To enforce this, reducer Observables race with a sync Observable containing the current state. If the reducer
   * Observable does not emit a new state synchronously, the current state is used (i.e. the state does not change).
   *
   * @param initialState
   * @param reducer
   * @returns
   */
  constructor(actions, states, initialState, reducer) {
    __publicField(this, "actions");
    __publicField(this, "states");
    /**
     * After an Action is dispatched, passed to the StateMachine's reducer to produce a new state (or stay in the same
     * state), a pair of [Action, State] is emitted on this Observable.
     *
     * This can be used to observe every action dispatched to the StateMachine, along with the state that it produced.
     *
     * The most common use of the `events` Observable is to implement side-effects. It's very common for side-effects
     * to dispatch actions back to the StateMachine.
     *
     * ```ts
     * stateMachine.events.pipe(
     *   inStates('idle'),
     *   forActions('makeRequest'),
     *   switchMap(([{data: request}]) => fromFetch(request)),
     *   tap(response => stateMachine.dispatch('requestComplete', response)),
     * ).subscribe()
     * ```
     */
    __publicField(this, "events");
    __publicField(this, "actionsSubject");
    __publicField(this, "eventsSubject");
    __publicField(this, "state");
    this.actions = actions;
    this.states = states;
    this.actionsSubject = new Subject();
    this.eventsSubject = new Subject();
    this.events = this.eventsSubject.asObservable();
    this.state = new BehaviorSubject(initialState);
    this.actionsSubject.pipe(withLatestFrom(this.state), mergeMap(([a2, s2]) => (
      // `NEVER` + `startWith` is needed for `raceWith` to work properly. If we instead used the more
      // typical `of([a, s])` we would encounter the following problem:
      //
      // `of` emits its value and completes synchronously (i.e. both in the same "frame," if you think in
      // marble diagrams). Assuming `reducer` does nothing to modify the completion behavior of its source
      // Observable, the Observable returned by `reducer` will also complete immediately. If we were to
      // pass that Observable to `raceWith`  whose output mirrors whichever input Observable is first to
      // emit, error, *or complete*  it would always win, even if it never emitted anything (because it
      // would already be complete).
      //
      // So instead we need an Observable that does not complete. We achieve this by using `NEVER` and
      // then starting it with `[a, s]`. Note that it's important to then use `take(1)` after `raceWith`
      // so that we don't leak Observables which never complete.
      NEVER.pipe(startWith([a2, s2]), reducer, raceWith(of(s2)), tap((newState) => {
        if (newState !== s2)
          this.state.next(newState);
      }), map((newState) => [a2, newState]), take(1))
    ))).subscribe(this.eventsSubject);
  }
  dispatch(actionOrName, data) {
    const action = typeof actionOrName === "string" ? { name: actionOrName, data } : actionOrName;
    this.actionsSubject.next(action);
  }
  /**
   * Returns the current state.
   */
  getState() {
    return this.state.getValue();
  }
};
function dispatch(stateMachine) {
  return (source) => new Observable((subscriber) => {
    const subscription = stateMachine.events.subscribe(subscriber);
    subscription.add(source.subscribe({
      next: (action) => stateMachine.dispatch(action),
      error: (error) => subscriber.error(error)
      // We purposely do not forward the `complete` notification.
      // We want the subscriber to remain subscribed to the stateMachine.events observable even if the
      // source Observable<Actions> completes.
    }));
    return subscription;
  });
}

// node_modules/@snap/state-management/dist/states.js
var defineState = (name) => () => defineAction(name)();
var defineStates = (...states) => defineActions(...states);
function inStates(...states) {
  return filter((v2) => states.some((state) => v2[1].name === state));
}
function isState(state, name) {
  return state.name === name;
}

// node_modules/@snap/camera-kit/dist/generated-proto/pb_schema/lenses/launchdata.js
var import_long27 = __toESM(require_long());
var import_minimal28 = __toESM(require_minimal2());

// node_modules/@snap/camera-kit/dist/generated-proto/pb_schema/lenses/snappable.js
var import_long20 = __toESM(require_long());
var import_minimal21 = __toESM(require_minimal2());
var EncryptionData_EncryptionScheme;
(function(EncryptionData_EncryptionScheme2) {
  EncryptionData_EncryptionScheme2["NOT_APPLICABLE"] = "NOT_APPLICABLE";
  EncryptionData_EncryptionScheme2["SPOOKEY"] = "SPOOKEY";
  EncryptionData_EncryptionScheme2["REGISTRY"] = "REGISTRY";
  EncryptionData_EncryptionScheme2["FIDELIUS"] = "FIDELIUS";
  EncryptionData_EncryptionScheme2["UNRECOGNIZED"] = "UNRECOGNIZED";
})(EncryptionData_EncryptionScheme || (EncryptionData_EncryptionScheme = {}));
function encryptionData_EncryptionSchemeFromJSON(object) {
  switch (object) {
    case 0:
    case "NOT_APPLICABLE":
      return EncryptionData_EncryptionScheme.NOT_APPLICABLE;
    case 1:
    case "SPOOKEY":
      return EncryptionData_EncryptionScheme.SPOOKEY;
    case 2:
    case "REGISTRY":
      return EncryptionData_EncryptionScheme.REGISTRY;
    case 3:
    case "FIDELIUS":
      return EncryptionData_EncryptionScheme.FIDELIUS;
    case -1:
    case "UNRECOGNIZED":
    default:
      return EncryptionData_EncryptionScheme.UNRECOGNIZED;
  }
}
function encryptionData_EncryptionSchemeToNumber(object) {
  switch (object) {
    case EncryptionData_EncryptionScheme.NOT_APPLICABLE:
      return 0;
    case EncryptionData_EncryptionScheme.SPOOKEY:
      return 1;
    case EncryptionData_EncryptionScheme.REGISTRY:
      return 2;
    case EncryptionData_EncryptionScheme.FIDELIUS:
      return 3;
    default:
      return 0;
  }
}
var SnappableMessage_ReplyType;
(function(SnappableMessage_ReplyType2) {
  SnappableMessage_ReplyType2["NOT_APPLICABLE"] = "NOT_APPLICABLE";
  SnappableMessage_ReplyType2["CONTEXT"] = "CONTEXT";
  SnappableMessage_ReplyType2["INTERSTITIAL"] = "INTERSTITIAL";
  SnappableMessage_ReplyType2["UNRECOGNIZED"] = "UNRECOGNIZED";
})(SnappableMessage_ReplyType || (SnappableMessage_ReplyType = {}));
function createBaseEncryptionData() {
  return {
    key: new Uint8Array(),
    ivStore: {},
    isKeyServerEncrypted: false,
    isKeyE2eEncrypted: false,
    encryptionScheme: EncryptionData_EncryptionScheme.NOT_APPLICABLE
  };
}
var EncryptionData = {
  encode(message, writer = import_minimal21.default.Writer.create()) {
    if (message.key.length !== 0) {
      writer.uint32(10).bytes(message.key);
    }
    Object.entries(message.ivStore).forEach(([key, value]) => {
      EncryptionData_IvStoreEntry.encode({ key, value }, writer.uint32(18).fork()).ldelim();
    });
    if (message.isKeyServerEncrypted === true) {
      writer.uint32(24).bool(message.isKeyServerEncrypted);
    }
    if (message.isKeyE2eEncrypted === true) {
      writer.uint32(32).bool(message.isKeyE2eEncrypted);
    }
    if (message.encryptionScheme !== EncryptionData_EncryptionScheme.NOT_APPLICABLE) {
      writer.uint32(40).int32(encryptionData_EncryptionSchemeToNumber(message.encryptionScheme));
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal21.default.Reader ? input : new import_minimal21.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseEncryptionData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.key = reader.bytes();
          break;
        case 2:
          const entry2 = EncryptionData_IvStoreEntry.decode(reader, reader.uint32());
          if (entry2.value !== void 0) {
            message.ivStore[entry2.key] = entry2.value;
          }
          break;
        case 3:
          message.isKeyServerEncrypted = reader.bool();
          break;
        case 4:
          message.isKeyE2eEncrypted = reader.bool();
          break;
        case 5:
          message.encryptionScheme = encryptionData_EncryptionSchemeFromJSON(reader.int32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(object) {
    var _a, _b, _c, _d, _e;
    const message = createBaseEncryptionData();
    message.key = (_a = object.key) !== null && _a !== void 0 ? _a : new Uint8Array();
    message.ivStore = Object.entries((_b = object.ivStore) !== null && _b !== void 0 ? _b : {}).reduce((acc, [key, value]) => {
      if (value !== void 0) {
        acc[key] = value;
      }
      return acc;
    }, {});
    message.isKeyServerEncrypted = (_c = object.isKeyServerEncrypted) !== null && _c !== void 0 ? _c : false;
    message.isKeyE2eEncrypted = (_d = object.isKeyE2eEncrypted) !== null && _d !== void 0 ? _d : false;
    message.encryptionScheme = (_e = object.encryptionScheme) !== null && _e !== void 0 ? _e : EncryptionData_EncryptionScheme.NOT_APPLICABLE;
    return message;
  }
};
function createBaseEncryptionData_IvStoreEntry() {
  return { key: "", value: new Uint8Array() };
}
var EncryptionData_IvStoreEntry = {
  encode(message, writer = import_minimal21.default.Writer.create()) {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value.length !== 0) {
      writer.uint32(18).bytes(message.value);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal21.default.Reader ? input : new import_minimal21.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseEncryptionData_IvStoreEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.key = reader.string();
          break;
        case 2:
          message.value = reader.bytes();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(object) {
    var _a, _b;
    const message = createBaseEncryptionData_IvStoreEntry();
    message.key = (_a = object.key) !== null && _a !== void 0 ? _a : "";
    message.value = (_b = object.value) !== null && _b !== void 0 ? _b : new Uint8Array();
    return message;
  }
};
function createBasePlayerData() {
  return { store: {}, serializedStore: new Uint8Array() };
}
var PlayerData = {
  encode(message, writer = import_minimal21.default.Writer.create()) {
    Object.entries(message.store).forEach(([key, value]) => {
      PlayerData_StoreEntry.encode({ key, value }, writer.uint32(10).fork()).ldelim();
    });
    if (message.serializedStore.length !== 0) {
      writer.uint32(18).bytes(message.serializedStore);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal21.default.Reader ? input : new import_minimal21.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBasePlayerData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          const entry1 = PlayerData_StoreEntry.decode(reader, reader.uint32());
          if (entry1.value !== void 0) {
            message.store[entry1.key] = entry1.value;
          }
          break;
        case 2:
          message.serializedStore = reader.bytes();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(object) {
    var _a, _b;
    const message = createBasePlayerData();
    message.store = Object.entries((_a = object.store) !== null && _a !== void 0 ? _a : {}).reduce((acc, [key, value]) => {
      if (value !== void 0) {
        acc[key] = String(value);
      }
      return acc;
    }, {});
    message.serializedStore = (_b = object.serializedStore) !== null && _b !== void 0 ? _b : new Uint8Array();
    return message;
  }
};
function createBasePlayerData_StoreEntry() {
  return { key: "", value: "" };
}
var PlayerData_StoreEntry = {
  encode(message, writer = import_minimal21.default.Writer.create()) {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal21.default.Reader ? input : new import_minimal21.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBasePlayerData_StoreEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.key = reader.string();
          break;
        case 2:
          message.value = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(object) {
    var _a, _b;
    const message = createBasePlayerData_StoreEntry();
    message.key = (_a = object.key) !== null && _a !== void 0 ? _a : "";
    message.value = (_b = object.value) !== null && _b !== void 0 ? _b : "";
    return message;
  }
};
function createBaseSessionData() {
  return { playerData: {} };
}
var SessionData = {
  encode(message, writer = import_minimal21.default.Writer.create()) {
    Object.entries(message.playerData).forEach(([key, value]) => {
      SessionData_PlayerDataEntry.encode({ key, value }, writer.uint32(10).fork()).ldelim();
    });
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal21.default.Reader ? input : new import_minimal21.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSessionData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          const entry1 = SessionData_PlayerDataEntry.decode(reader, reader.uint32());
          if (entry1.value !== void 0) {
            message.playerData[entry1.key] = entry1.value;
          }
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(object) {
    var _a;
    const message = createBaseSessionData();
    message.playerData = Object.entries((_a = object.playerData) !== null && _a !== void 0 ? _a : {}).reduce((acc, [key, value]) => {
      if (value !== void 0) {
        acc[key] = PlayerData.fromPartial(value);
      }
      return acc;
    }, {});
    return message;
  }
};
function createBaseSessionData_PlayerDataEntry() {
  return { key: "", value: void 0 };
}
var SessionData_PlayerDataEntry = {
  encode(message, writer = import_minimal21.default.Writer.create()) {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== void 0) {
      PlayerData.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal21.default.Reader ? input : new import_minimal21.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSessionData_PlayerDataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.key = reader.string();
          break;
        case 2:
          message.value = PlayerData.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(object) {
    var _a;
    const message = createBaseSessionData_PlayerDataEntry();
    message.key = (_a = object.key) !== null && _a !== void 0 ? _a : "";
    message.value = object.value !== void 0 && object.value !== null ? PlayerData.fromPartial(object.value) : void 0;
    return message;
  }
};
function createBaseSnappable() {
  return {
    id: "",
    sessionId: "",
    playerId: "",
    sessionData: void 0,
    createdTime: "0",
    expireTime: "0",
    version: 0,
    encryptionData: void 0,
    sessionDepth: 0
  };
}
var Snappable = {
  encode(message, writer = import_minimal21.default.Writer.create()) {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.sessionId !== "") {
      writer.uint32(18).string(message.sessionId);
    }
    if (message.playerId !== "") {
      writer.uint32(26).string(message.playerId);
    }
    if (message.sessionData !== void 0) {
      SessionData.encode(message.sessionData, writer.uint32(34).fork()).ldelim();
    }
    if (message.createdTime !== "0") {
      writer.uint32(40).int64(message.createdTime);
    }
    if (message.expireTime !== "0") {
      writer.uint32(48).int64(message.expireTime);
    }
    if (message.version !== 0) {
      writer.uint32(56).int32(message.version);
    }
    if (message.encryptionData !== void 0) {
      EncryptionData.encode(message.encryptionData, writer.uint32(66).fork()).ldelim();
    }
    if (message.sessionDepth !== 0) {
      writer.uint32(72).int32(message.sessionDepth);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal21.default.Reader ? input : new import_minimal21.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSnappable();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.id = reader.string();
          break;
        case 2:
          message.sessionId = reader.string();
          break;
        case 3:
          message.playerId = reader.string();
          break;
        case 4:
          message.sessionData = SessionData.decode(reader, reader.uint32());
          break;
        case 5:
          message.createdTime = longToString8(reader.int64());
          break;
        case 6:
          message.expireTime = longToString8(reader.int64());
          break;
        case 7:
          message.version = reader.int32();
          break;
        case 8:
          message.encryptionData = EncryptionData.decode(reader, reader.uint32());
          break;
        case 9:
          message.sessionDepth = reader.int32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(object) {
    var _a, _b, _c, _d, _e, _f, _g;
    const message = createBaseSnappable();
    message.id = (_a = object.id) !== null && _a !== void 0 ? _a : "";
    message.sessionId = (_b = object.sessionId) !== null && _b !== void 0 ? _b : "";
    message.playerId = (_c = object.playerId) !== null && _c !== void 0 ? _c : "";
    message.sessionData = object.sessionData !== void 0 && object.sessionData !== null ? SessionData.fromPartial(object.sessionData) : void 0;
    message.createdTime = (_d = object.createdTime) !== null && _d !== void 0 ? _d : "0";
    message.expireTime = (_e = object.expireTime) !== null && _e !== void 0 ? _e : "0";
    message.version = (_f = object.version) !== null && _f !== void 0 ? _f : 0;
    message.encryptionData = object.encryptionData !== void 0 && object.encryptionData !== null ? EncryptionData.fromPartial(object.encryptionData) : void 0;
    message.sessionDepth = (_g = object.sessionDepth) !== null && _g !== void 0 ? _g : 0;
    return message;
  }
};
function longToString8(long) {
  return long.toString();
}
if (import_minimal21.default.util.Long !== import_long20.default) {
  import_minimal21.default.util.Long = import_long20.default;
  import_minimal21.default.configure();
}

// node_modules/@snap/camera-kit/dist/generated-proto/pb_schema/lenses/lures.js
var import_long23 = __toESM(require_long());
var import_minimal24 = __toESM(require_minimal2());

// node_modules/@snap/camera-kit/dist/generated-proto/pb_schema/lenses/geocircle.js
var import_long22 = __toESM(require_long());
var import_minimal23 = __toESM(require_minimal2());

// node_modules/@snap/camera-kit/dist/generated-proto/pb_schema/lenses/geopoint.js
var import_long21 = __toESM(require_long());
var import_minimal22 = __toESM(require_minimal2());
function createBaseGeopoint() {
  return { latitude: 0, longitude: 0 };
}
var Geopoint = {
  encode(message, writer = import_minimal22.default.Writer.create()) {
    if (message.latitude !== 0) {
      writer.uint32(9).double(message.latitude);
    }
    if (message.longitude !== 0) {
      writer.uint32(17).double(message.longitude);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal22.default.Reader ? input : new import_minimal22.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGeopoint();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.latitude = reader.double();
          break;
        case 2:
          message.longitude = reader.double();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(object) {
    var _a, _b;
    const message = createBaseGeopoint();
    message.latitude = (_a = object.latitude) !== null && _a !== void 0 ? _a : 0;
    message.longitude = (_b = object.longitude) !== null && _b !== void 0 ? _b : 0;
    return message;
  }
};
if (import_minimal22.default.util.Long !== import_long21.default) {
  import_minimal22.default.util.Long = import_long21.default;
  import_minimal22.default.configure();
}

// node_modules/@snap/camera-kit/dist/generated-proto/pb_schema/lenses/geocircle.js
function createBaseGeocircle() {
  return { radius: 0, center: void 0 };
}
var Geocircle = {
  encode(message, writer = import_minimal23.default.Writer.create()) {
    if (message.radius !== 0) {
      writer.uint32(9).double(message.radius);
    }
    if (message.center !== void 0) {
      Geopoint.encode(message.center, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal23.default.Reader ? input : new import_minimal23.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGeocircle();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.radius = reader.double();
          break;
        case 2:
          message.center = Geopoint.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(object) {
    var _a;
    const message = createBaseGeocircle();
    message.radius = (_a = object.radius) !== null && _a !== void 0 ? _a : 0;
    message.center = object.center !== void 0 && object.center !== null ? Geopoint.fromPartial(object.center) : void 0;
    return message;
  }
};
if (import_minimal23.default.util.Long !== import_long22.default) {
  import_minimal23.default.util.Long = import_long22.default;
  import_minimal23.default.configure();
}

// node_modules/@snap/camera-kit/dist/generated-proto/pb_schema/lenses/lures.js
function createBaseLures() {
  return { locations: [], activeLure: void 0, closestLure: void 0 };
}
var Lures = {
  encode(message, writer = import_minimal24.default.Writer.create()) {
    for (const v2 of message.locations) {
      Geocircle.encode(v2, writer.uint32(10).fork()).ldelim();
    }
    if (message.activeLure !== void 0) {
      Geocircle.encode(message.activeLure, writer.uint32(18).fork()).ldelim();
    }
    if (message.closestLure !== void 0) {
      Geocircle.encode(message.closestLure, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal24.default.Reader ? input : new import_minimal24.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseLures();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.locations.push(Geocircle.decode(reader, reader.uint32()));
          break;
        case 2:
          message.activeLure = Geocircle.decode(reader, reader.uint32());
          break;
        case 3:
          message.closestLure = Geocircle.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(object) {
    var _a;
    const message = createBaseLures();
    message.locations = ((_a = object.locations) === null || _a === void 0 ? void 0 : _a.map((e2) => Geocircle.fromPartial(e2))) || [];
    message.activeLure = object.activeLure !== void 0 && object.activeLure !== null ? Geocircle.fromPartial(object.activeLure) : void 0;
    message.closestLure = object.closestLure !== void 0 && object.closestLure !== null ? Geocircle.fromPartial(object.closestLure) : void 0;
    return message;
  }
};
if (import_minimal24.default.util.Long !== import_long23.default) {
  import_minimal24.default.util.Long = import_long23.default;
  import_minimal24.default.configure();
}

// node_modules/@snap/camera-kit/dist/generated-proto/pb_schema/lenses/user_data.js
var import_long24 = __toESM(require_long());
var import_minimal25 = __toESM(require_minimal2());
var UserData_Zodiac;
(function(UserData_Zodiac2) {
  UserData_Zodiac2["Invalid"] = "Invalid";
  UserData_Zodiac2["Aquarius"] = "Aquarius";
  UserData_Zodiac2["Aries"] = "Aries";
  UserData_Zodiac2["Cancer"] = "Cancer";
  UserData_Zodiac2["Capricorn"] = "Capricorn";
  UserData_Zodiac2["Gemini"] = "Gemini";
  UserData_Zodiac2["Leo"] = "Leo";
  UserData_Zodiac2["Libra"] = "Libra";
  UserData_Zodiac2["Pisces"] = "Pisces";
  UserData_Zodiac2["Sagittarius"] = "Sagittarius";
  UserData_Zodiac2["Scorpio"] = "Scorpio";
  UserData_Zodiac2["Taurus"] = "Taurus";
  UserData_Zodiac2["Virgo"] = "Virgo";
  UserData_Zodiac2["UNRECOGNIZED"] = "UNRECOGNIZED";
})(UserData_Zodiac || (UserData_Zodiac = {}));
function userData_ZodiacFromJSON(object) {
  switch (object) {
    case 0:
    case "Invalid":
      return UserData_Zodiac.Invalid;
    case 1:
    case "Aquarius":
      return UserData_Zodiac.Aquarius;
    case 2:
    case "Aries":
      return UserData_Zodiac.Aries;
    case 3:
    case "Cancer":
      return UserData_Zodiac.Cancer;
    case 4:
    case "Capricorn":
      return UserData_Zodiac.Capricorn;
    case 5:
    case "Gemini":
      return UserData_Zodiac.Gemini;
    case 6:
    case "Leo":
      return UserData_Zodiac.Leo;
    case 7:
    case "Libra":
      return UserData_Zodiac.Libra;
    case 8:
    case "Pisces":
      return UserData_Zodiac.Pisces;
    case 9:
    case "Sagittarius":
      return UserData_Zodiac.Sagittarius;
    case 10:
    case "Scorpio":
      return UserData_Zodiac.Scorpio;
    case 11:
    case "Taurus":
      return UserData_Zodiac.Taurus;
    case 12:
    case "Virgo":
      return UserData_Zodiac.Virgo;
    case -1:
    case "UNRECOGNIZED":
    default:
      return UserData_Zodiac.UNRECOGNIZED;
  }
}
function userData_ZodiacToNumber(object) {
  switch (object) {
    case UserData_Zodiac.Invalid:
      return 0;
    case UserData_Zodiac.Aquarius:
      return 1;
    case UserData_Zodiac.Aries:
      return 2;
    case UserData_Zodiac.Cancer:
      return 3;
    case UserData_Zodiac.Capricorn:
      return 4;
    case UserData_Zodiac.Gemini:
      return 5;
    case UserData_Zodiac.Leo:
      return 6;
    case UserData_Zodiac.Libra:
      return 7;
    case UserData_Zodiac.Pisces:
      return 8;
    case UserData_Zodiac.Sagittarius:
      return 9;
    case UserData_Zodiac.Scorpio:
      return 10;
    case UserData_Zodiac.Taurus:
      return 11;
    case UserData_Zodiac.Virgo:
      return 12;
    default:
      return 0;
  }
}
function createBaseBitmojiUserInfo() {
  return { avatarId: "", selfieId: "" };
}
var BitmojiUserInfo = {
  encode(message, writer = import_minimal25.default.Writer.create()) {
    if (message.avatarId !== "") {
      writer.uint32(10).string(message.avatarId);
    }
    if (message.selfieId !== "") {
      writer.uint32(18).string(message.selfieId);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal25.default.Reader ? input : new import_minimal25.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseBitmojiUserInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.avatarId = reader.string();
          break;
        case 2:
          message.selfieId = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(object) {
    var _a, _b;
    const message = createBaseBitmojiUserInfo();
    message.avatarId = (_a = object.avatarId) !== null && _a !== void 0 ? _a : "";
    message.selfieId = (_b = object.selfieId) !== null && _b !== void 0 ? _b : "";
    return message;
  }
};
function createBaseFriendUserInfo() {
  return { friendshipStart: void 0, lastInteraction: void 0, streak: 0 };
}
var FriendUserInfo = {
  encode(message, writer = import_minimal25.default.Writer.create()) {
    if (message.friendshipStart !== void 0) {
      Timestamp.encode(toTimestamp4(message.friendshipStart), writer.uint32(10).fork()).ldelim();
    }
    if (message.lastInteraction !== void 0) {
      Timestamp.encode(toTimestamp4(message.lastInteraction), writer.uint32(18).fork()).ldelim();
    }
    if (message.streak !== 0) {
      writer.uint32(24).uint32(message.streak);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal25.default.Reader ? input : new import_minimal25.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFriendUserInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.friendshipStart = fromTimestamp4(Timestamp.decode(reader, reader.uint32()));
          break;
        case 2:
          message.lastInteraction = fromTimestamp4(Timestamp.decode(reader, reader.uint32()));
          break;
        case 3:
          message.streak = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(object) {
    var _a, _b, _c;
    const message = createBaseFriendUserInfo();
    message.friendshipStart = (_a = object.friendshipStart) !== null && _a !== void 0 ? _a : void 0;
    message.lastInteraction = (_b = object.lastInteraction) !== null && _b !== void 0 ? _b : void 0;
    message.streak = (_c = object.streak) !== null && _c !== void 0 ? _c : 0;
    return message;
  }
};
function createBaseUserData() {
  return {
    userId: "",
    username: "",
    birthdate: "",
    displayName: "",
    countrycode: "",
    score: "0",
    bitmojiInfo: void 0,
    friendInfo: void 0,
    zodiac: UserData_Zodiac.Invalid
  };
}
var UserData = {
  encode(message, writer = import_minimal25.default.Writer.create()) {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.username !== "") {
      writer.uint32(18).string(message.username);
    }
    if (message.birthdate !== "") {
      writer.uint32(26).string(message.birthdate);
    }
    if (message.displayName !== "") {
      writer.uint32(34).string(message.displayName);
    }
    if (message.countrycode !== "") {
      writer.uint32(42).string(message.countrycode);
    }
    if (message.score !== "0") {
      writer.uint32(56).uint64(message.score);
    }
    if (message.bitmojiInfo !== void 0) {
      BitmojiUserInfo.encode(message.bitmojiInfo, writer.uint32(66).fork()).ldelim();
    }
    if (message.friendInfo !== void 0) {
      FriendUserInfo.encode(message.friendInfo, writer.uint32(74).fork()).ldelim();
    }
    if (message.zodiac !== UserData_Zodiac.Invalid) {
      writer.uint32(80).int32(userData_ZodiacToNumber(message.zodiac));
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal25.default.Reader ? input : new import_minimal25.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseUserData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.userId = reader.string();
          break;
        case 2:
          message.username = reader.string();
          break;
        case 3:
          message.birthdate = reader.string();
          break;
        case 4:
          message.displayName = reader.string();
          break;
        case 5:
          message.countrycode = reader.string();
          break;
        case 7:
          message.score = longToString9(reader.uint64());
          break;
        case 8:
          message.bitmojiInfo = BitmojiUserInfo.decode(reader, reader.uint32());
          break;
        case 9:
          message.friendInfo = FriendUserInfo.decode(reader, reader.uint32());
          break;
        case 10:
          message.zodiac = userData_ZodiacFromJSON(reader.int32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(object) {
    var _a, _b, _c, _d, _e, _f, _g;
    const message = createBaseUserData();
    message.userId = (_a = object.userId) !== null && _a !== void 0 ? _a : "";
    message.username = (_b = object.username) !== null && _b !== void 0 ? _b : "";
    message.birthdate = (_c = object.birthdate) !== null && _c !== void 0 ? _c : "";
    message.displayName = (_d = object.displayName) !== null && _d !== void 0 ? _d : "";
    message.countrycode = (_e = object.countrycode) !== null && _e !== void 0 ? _e : "";
    message.score = (_f = object.score) !== null && _f !== void 0 ? _f : "0";
    message.bitmojiInfo = object.bitmojiInfo !== void 0 && object.bitmojiInfo !== null ? BitmojiUserInfo.fromPartial(object.bitmojiInfo) : void 0;
    message.friendInfo = object.friendInfo !== void 0 && object.friendInfo !== null ? FriendUserInfo.fromPartial(object.friendInfo) : void 0;
    message.zodiac = (_g = object.zodiac) !== null && _g !== void 0 ? _g : UserData_Zodiac.Invalid;
    return message;
  }
};
function toTimestamp4(date) {
  const seconds = Math.trunc(date.getTime() / 1e3).toString();
  const nanos = date.getTime() % 1e3 * 1e6;
  return { seconds, nanos };
}
function fromTimestamp4(t2) {
  let millis = Number(t2.seconds) * 1e3;
  millis += t2.nanos / 1e6;
  return new Date(millis);
}
function longToString9(long) {
  return long.toString();
}
if (import_minimal25.default.util.Long !== import_long24.default) {
  import_minimal25.default.util.Long = import_long24.default;
  import_minimal25.default.configure();
}

// node_modules/@snap/camera-kit/dist/generated-proto/pb_schema/lenses/persistent_store.js
var import_long25 = __toESM(require_long());
var import_minimal26 = __toESM(require_minimal2());
function createBasePersistentStore() {
  return { store: new Uint8Array() };
}
var PersistentStore = {
  encode(message, writer = import_minimal26.default.Writer.create()) {
    if (message.store.length !== 0) {
      writer.uint32(10).bytes(message.store);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal26.default.Reader ? input : new import_minimal26.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBasePersistentStore();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.store = reader.bytes();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(object) {
    var _a;
    const message = createBasePersistentStore();
    message.store = (_a = object.store) !== null && _a !== void 0 ? _a : new Uint8Array();
    return message;
  }
};
if (import_minimal26.default.util.Long !== import_long25.default) {
  import_minimal26.default.util.Long = import_long25.default;
  import_minimal26.default.configure();
}

// node_modules/@snap/camera-kit/dist/generated-proto/pb_schema/lenses/launch_params.js
var import_long26 = __toESM(require_long());
var import_minimal27 = __toESM(require_minimal2());
function createBaseLaunchParams() {
  return { data: new Uint8Array() };
}
var LaunchParams = {
  encode(message, writer = import_minimal27.default.Writer.create()) {
    if (message.data.length !== 0) {
      writer.uint32(10).bytes(message.data);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal27.default.Reader ? input : new import_minimal27.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseLaunchParams();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.data = reader.bytes();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(object) {
    var _a;
    const message = createBaseLaunchParams();
    message.data = (_a = object.data) !== null && _a !== void 0 ? _a : new Uint8Array();
    return message;
  }
};
if (import_minimal27.default.util.Long !== import_long26.default) {
  import_minimal27.default.util.Long = import_long26.default;
  import_minimal27.default.configure();
}

// node_modules/@snap/camera-kit/dist/generated-proto/pb_schema/lenses/launchdata.js
var LaunchData_EntryPoint;
(function(LaunchData_EntryPoint2) {
  LaunchData_EntryPoint2["LIVE_CAMERA"] = "LIVE_CAMERA";
  LaunchData_EntryPoint2["STORY_REPLY"] = "STORY_REPLY";
  LaunchData_EntryPoint2["CHAT_REPLY"] = "CHAT_REPLY";
  LaunchData_EntryPoint2["RESTART"] = "RESTART";
  LaunchData_EntryPoint2["PREVIEW_CANCEL"] = "PREVIEW_CANCEL";
  LaunchData_EntryPoint2["MAP"] = "MAP";
  LaunchData_EntryPoint2["BITMOJI_STICKERS"] = "BITMOJI_STICKERS";
  LaunchData_EntryPoint2["POST_CAPTURE_PREVIEW"] = "POST_CAPTURE_PREVIEW";
  LaunchData_EntryPoint2["POST_CAPTURE_TRANSCODING"] = "POST_CAPTURE_TRANSCODING";
  LaunchData_EntryPoint2["UNRECOGNIZED"] = "UNRECOGNIZED";
})(LaunchData_EntryPoint || (LaunchData_EntryPoint = {}));
function launchData_EntryPointFromJSON(object) {
  switch (object) {
    case 0:
    case "LIVE_CAMERA":
      return LaunchData_EntryPoint.LIVE_CAMERA;
    case 1:
    case "STORY_REPLY":
      return LaunchData_EntryPoint.STORY_REPLY;
    case 2:
    case "CHAT_REPLY":
      return LaunchData_EntryPoint.CHAT_REPLY;
    case 3:
    case "RESTART":
      return LaunchData_EntryPoint.RESTART;
    case 4:
    case "PREVIEW_CANCEL":
      return LaunchData_EntryPoint.PREVIEW_CANCEL;
    case 5:
    case "MAP":
      return LaunchData_EntryPoint.MAP;
    case 6:
    case "BITMOJI_STICKERS":
      return LaunchData_EntryPoint.BITMOJI_STICKERS;
    case 7:
    case "POST_CAPTURE_PREVIEW":
      return LaunchData_EntryPoint.POST_CAPTURE_PREVIEW;
    case 8:
    case "POST_CAPTURE_TRANSCODING":
      return LaunchData_EntryPoint.POST_CAPTURE_TRANSCODING;
    case -1:
    case "UNRECOGNIZED":
    default:
      return LaunchData_EntryPoint.UNRECOGNIZED;
  }
}
function launchData_EntryPointToNumber(object) {
  switch (object) {
    case LaunchData_EntryPoint.LIVE_CAMERA:
      return 0;
    case LaunchData_EntryPoint.STORY_REPLY:
      return 1;
    case LaunchData_EntryPoint.CHAT_REPLY:
      return 2;
    case LaunchData_EntryPoint.RESTART:
      return 3;
    case LaunchData_EntryPoint.PREVIEW_CANCEL:
      return 4;
    case LaunchData_EntryPoint.MAP:
      return 5;
    case LaunchData_EntryPoint.BITMOJI_STICKERS:
      return 6;
    case LaunchData_EntryPoint.POST_CAPTURE_PREVIEW:
      return 7;
    case LaunchData_EntryPoint.POST_CAPTURE_TRANSCODING:
      return 8;
    default:
      return 0;
  }
}
var LaunchData_ApiDescriptor;
(function(LaunchData_ApiDescriptor2) {
  LaunchData_ApiDescriptor2["NONE"] = "NONE";
  LaunchData_ApiDescriptor2["EXPERIMENTAL"] = "EXPERIMENTAL";
  LaunchData_ApiDescriptor2["UNRECOGNIZED"] = "UNRECOGNIZED";
})(LaunchData_ApiDescriptor || (LaunchData_ApiDescriptor = {}));
function launchData_ApiDescriptorFromJSON(object) {
  switch (object) {
    case 0:
    case "NONE":
      return LaunchData_ApiDescriptor.NONE;
    case 1:
    case "EXPERIMENTAL":
      return LaunchData_ApiDescriptor.EXPERIMENTAL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return LaunchData_ApiDescriptor.UNRECOGNIZED;
  }
}
function launchData_ApiDescriptorToNumber(object) {
  switch (object) {
    case LaunchData_ApiDescriptor.NONE:
      return 0;
    case LaunchData_ApiDescriptor.EXPERIMENTAL:
      return 1;
    default:
      return 0;
  }
}
var LaunchData_RenderConfig;
(function(LaunchData_RenderConfig2) {
  LaunchData_RenderConfig2["DEFAULT"] = "DEFAULT";
  LaunchData_RenderConfig2["REPLAY_STREAM"] = "REPLAY_STREAM";
  LaunchData_RenderConfig2["UNRECOGNIZED"] = "UNRECOGNIZED";
})(LaunchData_RenderConfig || (LaunchData_RenderConfig = {}));
function launchData_RenderConfigFromJSON(object) {
  switch (object) {
    case 0:
    case "DEFAULT":
      return LaunchData_RenderConfig.DEFAULT;
    case 1:
    case "REPLAY_STREAM":
      return LaunchData_RenderConfig.REPLAY_STREAM;
    case -1:
    case "UNRECOGNIZED":
    default:
      return LaunchData_RenderConfig.UNRECOGNIZED;
  }
}
function launchData_RenderConfigToNumber(object) {
  switch (object) {
    case LaunchData_RenderConfig.DEFAULT:
      return 0;
    case LaunchData_RenderConfig.REPLAY_STREAM:
      return 1;
    default:
      return 0;
  }
}
var LaunchData_ActivationSource;
(function(LaunchData_ActivationSource2) {
  LaunchData_ActivationSource2["ACTIVATION_SOURCE_UNSET"] = "ACTIVATION_SOURCE_UNSET";
  LaunchData_ActivationSource2["ACTIVATION_SOURCE_DEFAULT"] = "ACTIVATION_SOURCE_DEFAULT";
  LaunchData_ActivationSource2["CREATIVE"] = "CREATIVE";
  LaunchData_ActivationSource2["SCAN"] = "SCAN";
  LaunchData_ActivationSource2["SCAN_HISTORY"] = "SCAN_HISTORY";
  LaunchData_ActivationSource2["CHAT_FEED_PSA"] = "CHAT_FEED_PSA";
  LaunchData_ActivationSource2["GROWTH_NOTIFICATION"] = "GROWTH_NOTIFICATION";
  LaunchData_ActivationSource2["MASS_SNAP"] = "MASS_SNAP";
  LaunchData_ActivationSource2["SMART_CTA"] = "SMART_CTA";
  LaunchData_ActivationSource2["MASS_CHAT"] = "MASS_CHAT";
  LaunchData_ActivationSource2["BILLBOARD_FHP"] = "BILLBOARD_FHP";
  LaunchData_ActivationSource2["LENS_ACTIVITY_CENTER"] = "LENS_ACTIVITY_CENTER";
  LaunchData_ActivationSource2["AR_BAR"] = "AR_BAR";
  LaunchData_ActivationSource2["UNRECOGNIZED"] = "UNRECOGNIZED";
})(LaunchData_ActivationSource || (LaunchData_ActivationSource = {}));
function launchData_ActivationSourceFromJSON(object) {
  switch (object) {
    case 0:
    case "ACTIVATION_SOURCE_UNSET":
      return LaunchData_ActivationSource.ACTIVATION_SOURCE_UNSET;
    case 1:
    case "ACTIVATION_SOURCE_DEFAULT":
      return LaunchData_ActivationSource.ACTIVATION_SOURCE_DEFAULT;
    case 2:
    case "CREATIVE":
      return LaunchData_ActivationSource.CREATIVE;
    case 3:
    case "SCAN":
      return LaunchData_ActivationSource.SCAN;
    case 4:
    case "SCAN_HISTORY":
      return LaunchData_ActivationSource.SCAN_HISTORY;
    case 5:
    case "CHAT_FEED_PSA":
      return LaunchData_ActivationSource.CHAT_FEED_PSA;
    case 6:
    case "GROWTH_NOTIFICATION":
      return LaunchData_ActivationSource.GROWTH_NOTIFICATION;
    case 7:
    case "MASS_SNAP":
      return LaunchData_ActivationSource.MASS_SNAP;
    case 8:
    case "SMART_CTA":
      return LaunchData_ActivationSource.SMART_CTA;
    case 9:
    case "MASS_CHAT":
      return LaunchData_ActivationSource.MASS_CHAT;
    case 10:
    case "BILLBOARD_FHP":
      return LaunchData_ActivationSource.BILLBOARD_FHP;
    case 11:
    case "LENS_ACTIVITY_CENTER":
      return LaunchData_ActivationSource.LENS_ACTIVITY_CENTER;
    case 12:
    case "AR_BAR":
      return LaunchData_ActivationSource.AR_BAR;
    case -1:
    case "UNRECOGNIZED":
    default:
      return LaunchData_ActivationSource.UNRECOGNIZED;
  }
}
function launchData_ActivationSourceToNumber(object) {
  switch (object) {
    case LaunchData_ActivationSource.ACTIVATION_SOURCE_UNSET:
      return 0;
    case LaunchData_ActivationSource.ACTIVATION_SOURCE_DEFAULT:
      return 1;
    case LaunchData_ActivationSource.CREATIVE:
      return 2;
    case LaunchData_ActivationSource.SCAN:
      return 3;
    case LaunchData_ActivationSource.SCAN_HISTORY:
      return 4;
    case LaunchData_ActivationSource.CHAT_FEED_PSA:
      return 5;
    case LaunchData_ActivationSource.GROWTH_NOTIFICATION:
      return 6;
    case LaunchData_ActivationSource.MASS_SNAP:
      return 7;
    case LaunchData_ActivationSource.SMART_CTA:
      return 8;
    case LaunchData_ActivationSource.MASS_CHAT:
      return 9;
    case LaunchData_ActivationSource.BILLBOARD_FHP:
      return 10;
    case LaunchData_ActivationSource.LENS_ACTIVITY_CENTER:
      return 11;
    case LaunchData_ActivationSource.AR_BAR:
      return 12;
    default:
      return 0;
  }
}
function createBaseLaunchData() {
  return {
    snappable: void 0,
    lures: void 0,
    userId: "",
    entryPoint: LaunchData_EntryPoint.LIVE_CAMERA,
    userData: void 0,
    persistentStore: void 0,
    launchParams: void 0,
    apiDescriptors: [],
    renderConfig: LaunchData_RenderConfig.DEFAULT,
    activationSource: LaunchData_ActivationSource.ACTIVATION_SOURCE_UNSET
  };
}
var LaunchData = {
  encode(message, writer = import_minimal28.default.Writer.create()) {
    if (message.snappable !== void 0) {
      Snappable.encode(message.snappable, writer.uint32(10).fork()).ldelim();
    }
    if (message.lures !== void 0) {
      Lures.encode(message.lures, writer.uint32(18).fork()).ldelim();
    }
    if (message.userId !== "") {
      writer.uint32(26).string(message.userId);
    }
    if (message.entryPoint !== LaunchData_EntryPoint.LIVE_CAMERA) {
      writer.uint32(32).int32(launchData_EntryPointToNumber(message.entryPoint));
    }
    if (message.userData !== void 0) {
      UserData.encode(message.userData, writer.uint32(42).fork()).ldelim();
    }
    if (message.persistentStore !== void 0) {
      PersistentStore.encode(message.persistentStore, writer.uint32(50).fork()).ldelim();
    }
    if (message.launchParams !== void 0) {
      LaunchParams.encode(message.launchParams, writer.uint32(58).fork()).ldelim();
    }
    writer.uint32(66).fork();
    for (const v2 of message.apiDescriptors) {
      writer.int32(launchData_ApiDescriptorToNumber(v2));
    }
    writer.ldelim();
    if (message.renderConfig !== LaunchData_RenderConfig.DEFAULT) {
      writer.uint32(72).int32(launchData_RenderConfigToNumber(message.renderConfig));
    }
    if (message.activationSource !== LaunchData_ActivationSource.ACTIVATION_SOURCE_UNSET) {
      writer.uint32(80).int32(launchData_ActivationSourceToNumber(message.activationSource));
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal28.default.Reader ? input : new import_minimal28.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseLaunchData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.snappable = Snappable.decode(reader, reader.uint32());
          break;
        case 2:
          message.lures = Lures.decode(reader, reader.uint32());
          break;
        case 3:
          message.userId = reader.string();
          break;
        case 4:
          message.entryPoint = launchData_EntryPointFromJSON(reader.int32());
          break;
        case 5:
          message.userData = UserData.decode(reader, reader.uint32());
          break;
        case 6:
          message.persistentStore = PersistentStore.decode(reader, reader.uint32());
          break;
        case 7:
          message.launchParams = LaunchParams.decode(reader, reader.uint32());
          break;
        case 8:
          if ((tag & 7) === 2) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.apiDescriptors.push(launchData_ApiDescriptorFromJSON(reader.int32()));
            }
          } else {
            message.apiDescriptors.push(launchData_ApiDescriptorFromJSON(reader.int32()));
          }
          break;
        case 9:
          message.renderConfig = launchData_RenderConfigFromJSON(reader.int32());
          break;
        case 10:
          message.activationSource = launchData_ActivationSourceFromJSON(reader.int32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(object) {
    var _a, _b, _c, _d, _e;
    const message = createBaseLaunchData();
    message.snappable = object.snappable !== void 0 && object.snappable !== null ? Snappable.fromPartial(object.snappable) : void 0;
    message.lures = object.lures !== void 0 && object.lures !== null ? Lures.fromPartial(object.lures) : void 0;
    message.userId = (_a = object.userId) !== null && _a !== void 0 ? _a : "";
    message.entryPoint = (_b = object.entryPoint) !== null && _b !== void 0 ? _b : LaunchData_EntryPoint.LIVE_CAMERA;
    message.userData = object.userData !== void 0 && object.userData !== null ? UserData.fromPartial(object.userData) : void 0;
    message.persistentStore = object.persistentStore !== void 0 && object.persistentStore !== null ? PersistentStore.fromPartial(object.persistentStore) : void 0;
    message.launchParams = object.launchParams !== void 0 && object.launchParams !== null ? LaunchParams.fromPartial(object.launchParams) : void 0;
    message.apiDescriptors = ((_c = object.apiDescriptors) === null || _c === void 0 ? void 0 : _c.map((e2) => e2)) || [];
    message.renderConfig = (_d = object.renderConfig) !== null && _d !== void 0 ? _d : LaunchData_RenderConfig.DEFAULT;
    message.activationSource = (_e = object.activationSource) !== null && _e !== void 0 ? _e : LaunchData_ActivationSource.ACTIVATION_SOURCE_UNSET;
    return message;
  }
};
if (import_minimal28.default.util.Long !== import_long27.default) {
  import_minimal28.default.util.Long = import_long27.default;
  import_minimal28.default.configure();
}

// node_modules/@snap/camera-kit/dist/lens/LensLaunchData.js
var zodiacMap = {
  aquarius: UserData_Zodiac.Aquarius,
  aries: UserData_Zodiac.Aries,
  cancer: UserData_Zodiac.Cancer,
  capricorn: UserData_Zodiac.Capricorn,
  gemini: UserData_Zodiac.Gemini,
  leo: UserData_Zodiac.Leo,
  libra: UserData_Zodiac.Libra,
  pisces: UserData_Zodiac.Pisces,
  sagittarius: UserData_Zodiac.Sagittarius,
  scorpio: UserData_Zodiac.Scorpio,
  taurus: UserData_Zodiac.Taurus,
  virgo: UserData_Zodiac.Virgo
};
var zodiacValueSet = new Set(Object.keys(zodiacMap));
function isZodiac(value) {
  return zodiacValueSet.has(value);
}
function isLensLaunchDataOrUndefined(value) {
  return isUndefined(value) || isLensLaunchData(value);
}
function isLensLaunchData(value) {
  return isRecord(value) && isStringOrUndefined(value.userId) && isLensUserDataOrUndefined(value.userData) && isLensLaunchParamsOrUndefined(value.launchParams);
}
function isLensUserDataOrUndefined(value) {
  return isUndefined(value) || isLensUserData(value);
}
function isLensUserData(value) {
  return isRecord(value) && isStringOrUndefined(value.userId) && isStringOrUndefined(value.username) && isStringOrUndefined(value.birthdate) && isStringOrUndefined(value.displayName) && isStringOrUndefined(value.countrycode) && isStringOrUndefined(value.score) && isBitmojiUserInfoOrUndefined(value.bitmojiInfo) && isFriendUserInfoOrUndefined(value.friendInfo) && isZodiacOrUndefined(value.zodiac);
}
function isBitmojiUserInfoOrUndefined(value) {
  return isUndefined(value) || isBitmojiUserInfo(value);
}
function isBitmojiUserInfo(value) {
  return isRecord(value) && isStringOrUndefined(value.avatarId) && isStringOrUndefined(value.selfieId);
}
function isFriendUserInfoOrUndefined(value) {
  return isUndefined(value) || isFriendUserInfo(value);
}
function isFriendUserInfo(value) {
  return isRecord(value) && isDateOrUndefined(value.friendshipStart) && isDateOrUndefined(value.lastInteraction) && isValidNumberOrUndefined(value.streak);
}
function isZodiacOrUndefined(value) {
  return isUndefined(value) || isZodiac(value);
}
function isLensLaunchParamsOrUndefined(value) {
  return isUndefined(value) || isLensLaunchParams(value);
}
function isLensLaunchParams(value) {
  return isRecord(value) && predicateRecordValues(isStringOrNumberOrArrayOfStringsOrNumbers)(value);
}
function isStringOrNumberOrArrayOfStringsOrNumbers(value) {
  return isString(value) || isValidNumber(value) || isArrayOfType(isString, value) || isArrayOfType(isValidNumber, value);
}
var encodeLensLaunchData = (launchData, persistentStore) => {
  var _a;
  return LaunchData.encode(LaunchData.fromPartial(Object.assign(Object.assign({}, launchData), { userData: launchData.userData ? Object.assign(Object.assign({}, launchData.userData), { zodiac: ((_a = launchData.userData) === null || _a === void 0 ? void 0 : _a.zodiac) ? zodiacMap[launchData.userData.zodiac] : void 0 }) : void 0, launchParams: launchData.launchParams ? encodeLensLaunchParams(launchData.launchParams) : void 0, persistentStore: { store: new Uint8Array(persistentStore) } }))).finish().slice();
};
function encodeLensLaunchParams(launchParams) {
  return { data: new TextEncoder().encode(JSON.stringify(launchParams)) };
}

// node_modules/@snap/camera-kit/dist/transforms/Transform2D.js
var Transform2D = class {
  constructor(matrix) {
    this.matrix = matrix;
  }
};
Transform2D.MirrorX = new Transform2D([-1, 0, 0, 0, 1, 0, 1, 0, 1]);
Transform2D.MirrorY = new Transform2D([1, 0, 0, 0, -1, 0, 0, 1, 1]);
Transform2D.Identity = new Transform2D([1, 0, 0, 0, 1, 0, 0, 0, 1]);
function isTransform2D(value) {
  return value instanceof Transform2D;
}

// node_modules/@snap/camera-kit/dist/media-sources/CameraKitSource.js
var defaultDeviceInfo = {
  cameraType: "user",
  fpsLimit: Number.POSITIVE_INFINITY
};
var createNotAttachedError = (message) => new Error(`${message}. This CameraKitSource is not attached to a CameraKitSession.`);
var cameraTypeValueSet = new Set(Object.keys({
  user: 0,
  environment: 0
}));
function isCameraKitSource(value) {
  return value instanceof CameraKitSource;
}
function isPartialCameraKitDeviceOptionsOrUndefined(value) {
  return isUndefined(value) || isPartialCameraKitDeviceOptions(value);
}
function isPartialCameraKitDeviceOptions(value) {
  return isRecord(value) && isCameraTypeOrUndefined(value.cameraType) && isValidNumberOrUndefined(value.fpsLimit);
}
function isCameraType(value) {
  return cameraTypeValueSet.has(value);
}
function isCameraTypeOrUndefined(value) {
  return isUndefined(value) || isCameraType(value);
}
var CameraKitSource = (() => {
  var _a;
  let _instanceExtraInitializers = [];
  let _setRenderSize_decorators;
  let _setTransform_decorators;
  return _a = class CameraKitSource2 {
    constructor(sourceInfo, subscriber = {}, deviceInfo = {}) {
      this.sourceInfo = (__runInitializers(this, _instanceExtraInitializers), sourceInfo);
      this.subscriber = subscriber;
      this.deviceInfo = Object.assign(Object.assign({}, defaultDeviceInfo), copyDefinedProperties(deviceInfo));
    }
    attach(lensCore, reportError) {
      return __awaiter(this, void 0, void 0, function* () {
        if (this.lensCore) {
          throw new Error("Cannot attach. This CameraKitCustomSource has already been attached to a CameraKitSession. To re-attach, create a copy of this CameraKitCustomSource.");
        }
        this.lensCore = lensCore;
        yield lensCore.useMediaElement({
          autoplayNewMedia: false,
          autoplayPreviewCanvas: false,
          media: this.sourceInfo.media,
          pauseExistingMedia: false,
          replayTrackingData: this.sourceInfo.replayTrackingData,
          requestWebcam: false,
          startOnFrontCamera: ["user", "front"].includes(this.deviceInfo.cameraType),
          useManualFrameProcessing: this.sourceInfo.useManualFrameProcessing
        });
        const fps = this.deviceInfo.fpsLimit < Number.POSITIVE_INFINITY ? this.deviceInfo.fpsLimit : 0;
        yield lensCore.setFPSLimit({ fps });
        yield lensCore.setRenderSize({ mode: "matchInputResolution" });
        if (this.subscriber.onAttach)
          yield this.subscriber.onAttach(this, lensCore, reportError);
      });
    }
    copy(deviceInfo = {}) {
      return new CameraKitSource2(this.sourceInfo, this.subscriber, Object.assign(Object.assign({}, this.deviceInfo), deviceInfo));
    }
    detach(reportError) {
      if (!this.lensCore)
        return Promise.reject(createNotAttachedError("Cannot detach"));
      if (this.subscriber.onDetach)
        return this.subscriber.onDetach(reportError);
    }
    setRenderSize(width2, height2) {
      if (!this.lensCore)
        return Promise.reject(createNotAttachedError("Cannot setRenderSize"));
      const target = { width: width2, height: height2 };
      return this.lensCore.setRenderSize({ mode: "explicit", target });
    }
    setTransform(transform) {
      if (!this.lensCore)
        return Promise.reject(createNotAttachedError("Cannot setTransform"));
      const matrix = new Float32Array(transform.matrix);
      return this.lensCore.setInputTransform({ matrix });
    }
  }, (() => {
    _setRenderSize_decorators = [validate(isValidNumber, isValidNumber)];
    _setTransform_decorators = [validate(isTransform2D)];
    __esDecorate(_a, null, _setRenderSize_decorators, { kind: "method", name: "setRenderSize", static: false, private: false, access: { has: (obj) => "setRenderSize" in obj, get: (obj) => obj.setRenderSize } }, null, _instanceExtraInitializers);
    __esDecorate(_a, null, _setTransform_decorators, { kind: "method", name: "setTransform", static: false, private: false, access: { has: (obj) => "setTransform" in obj, get: (obj) => obj.setTransform } }, null, _instanceExtraInitializers);
  })(), _a;
})();

// node_modules/@snap/camera-kit/dist/observable-operators/debounceTimeAfter.js
function debounceTimeAfter(amount, duration, scheduler = asyncScheduler) {
  return (source) => {
    return new Observable((subscriber) => {
      let iterationCount = 0;
      return source.pipe(tap((value) => {
        iterationCount++;
        if (iterationCount <= amount) {
          subscriber.next({ type: "initial", value });
        }
      }), buffer(source.pipe(debounceTime(duration, scheduler))), tap((values) => {
        if (iterationCount > amount) {
          subscriber.next({ type: "debounced", values: values.slice(amount) });
        }
        iterationCount = 0;
      })).subscribe();
    });
  };
}

// node_modules/@snap/camera-kit/dist/media-sources/MediaStreamSource.js
var defaultOptions3 = Object.assign(Object.assign({}, defaultDeviceInfo), { transform: Transform2D.Identity, disableSourceAudio: false });
function closeWorklet(worklet) {
  if (!worklet)
    return;
  worklet.port.close();
  worklet.port.onmessage = null;
  worklet.disconnect();
}
function closeAudioContext(audioContext) {
  return __awaiter(this, void 0, void 0, function* () {
    if (!audioContext || audioContext.state === "closed")
      return;
    return audioContext.close();
  });
}
function handleAudioProcessingErrors(errors, reportError) {
  return errors.pipe(debounceTimeAfter(1, 1e3), map((event) => {
    if (event.type === "initial") {
      reportError(new Error("The first audio processing error before debouncing.", { cause: event.value }));
    } else if (event.type === "debounced") {
      const errorMessages = [...new Set(event.values.map(stringifyErrorMessage))].join("\n");
      reportError(new Error(`Debounced ${event.values.length} audio processing errors.`, {
        cause: new Error(errorMessages)
      }));
    }
  })).subscribe();
}
function createMediaStreamSource(stream, options = {}) {
  var _a;
  const { facingMode } = stream.getVideoTracks().length > 0 ? stream.getVideoTracks()[0].getSettings() : { facingMode: void 0 };
  const detectedCameraType = facingMode === "user" || facingMode === "environment" ? facingMode : void 0;
  const optionsWithDefaults = Object.assign(Object.assign(Object.assign({}, defaultOptions3), copyDefinedProperties(options)), { cameraType: (_a = options.cameraType) !== null && _a !== void 0 ? _a : detectedCameraType });
  const enableSourceAudio = stream.getAudioTracks().length > 0 && !optionsWithDefaults.disableSourceAudio;
  const simulateStereoAudio = true;
  const sampleRate = 44100;
  let audioContext = void 0;
  let audioSource = void 0;
  let worklet = void 0;
  let microphoneRecorderUrl;
  if (enableSourceAudio) {
    const microphoneRecorderWorklet = `
        class MicrophoneWorkletProcessor extends AudioWorkletProcessor {
            process(inputs, outputs, parameters) {
                this.port.postMessage({
                    eventType: 'data',
                    buffer: inputs
                });
                return true;
            }
        }
        registerProcessor('microphone-worklet', MicrophoneWorkletProcessor);`;
    const microphoneRecorderBlob = new Blob([microphoneRecorderWorklet], {
      type: "application/javascript"
    });
    microphoneRecorderUrl = URL.createObjectURL(microphoneRecorderBlob);
  }
  let audioProcessingErrorSubscription = void 0;
  return new CameraKitSource({ media: stream }, {
    onAttach: (source, lensCore, reportError) => __awaiter(this, void 0, void 0, function* () {
      yield source.setTransform(optionsWithDefaults.transform);
      if (enableSourceAudio) {
        const audioProcessingErrors = new Subject();
        audioProcessingErrorSubscription = handleAudioProcessingErrors(audioProcessingErrors, reportError);
        yield lensCore.setAudioParameters({
          parameters: {
            numChannels: simulateStereoAudio ? 2 : 1,
            sampleRate
          }
        });
        try {
          closeWorklet(worklet);
          audioSource === null || audioSource === void 0 ? void 0 : audioSource.disconnect();
          yield closeAudioContext(audioContext);
        } catch (error) {
          reportError(ensureError(error));
        }
        audioContext = new AudioContext();
        audioSource = audioContext.createMediaStreamSource(stream);
        const scopedAudioSource = audioSource;
        audioContext.audioWorklet.addModule(microphoneRecorderUrl).then(() => {
          if (audioContext) {
            worklet = new AudioWorkletNode(audioContext, "microphone-worklet");
            scopedAudioSource.connect(worklet);
            worklet.connect(audioContext.destination);
            worklet.port.onmessage = (e2) => {
              if (e2.data.eventType === "data") {
                const leftSamples = e2.data.buffer[0][0];
                if (!leftSamples)
                  return;
                let inputBuffers = [leftSamples];
                if (simulateStereoAudio) {
                  const rightSamples = e2.data.buffer[0].length > 1 ? e2.data.buffer[0][1] : leftSamples.slice();
                  inputBuffers.push(rightSamples);
                }
                lensCore.processAudioSampleBuffer({ input: inputBuffers }).catch((error) => audioProcessingErrors.next(error));
              }
            };
          }
        }).catch((error) => {
          reportError(error);
        });
      }
    }),
    onDetach: (reportError) => __awaiter(this, void 0, void 0, function* () {
      if (worklet) {
        closeWorklet(worklet);
        worklet = void 0;
      }
      if (audioSource) {
        audioSource.disconnect();
        audioSource = void 0;
      }
      if (audioContext) {
        yield closeAudioContext(audioContext).catch(reportError);
        audioContext = void 0;
      }
      if (audioProcessingErrorSubscription) {
        audioProcessingErrorSubscription.unsubscribe();
        audioProcessingErrorSubscription = void 0;
      }
    })
  }, optionsWithDefaults);
}

// node_modules/@snap/camera-kit/dist/media-sources/VideoSource.js
var defaultOptions4 = Object.assign(Object.assign({}, defaultDeviceInfo), { trackingData: new ArrayBuffer(0) });
function createVideoSource(video, options = {}) {
  const { trackingData } = Object.assign(Object.assign({}, defaultOptions4), copyDefinedProperties(options));
  const replayTrackingData = trackingData.byteLength > 0 ? { buffer: trackingData } : void 0;
  return new CameraKitSource({
    media: video,
    replayTrackingData
  }, {}, options);
}

// node_modules/@snap/camera-kit/dist/logger/logEntries.js
var logEntriesFactory = Injectable("logEntries", () => resetLogger().asObservable());

// node_modules/@snap/camera-kit/dist/session/LensPerformanceMeasurement.js
var getDefaultFrameMetricsState = () => ({
  avgFps: 0,
  averageProcessingTime: 0,
  n: 0,
  processingTimeBuckets: new Uint32Array(frameProcessingTimeMedianMax + 1),
  procFrameCount: 0,
  procFrameMean: 0,
  procFrameD2: 0
});
var frameDurationThreshold = 1;
var frameProcessingTimeMedianMax = 200;
var LensPerformanceMeasurement = class {
  constructor(instances) {
    this.instances = instances;
    this.state = Object.assign({}, getDefaultFrameMetricsState());
    this.instances.add(this);
  }
  update(processingTimeMs) {
    this.computeRunningStats(processingTimeMs);
  }
  measure() {
    let median = 0;
    let count2 = 0;
    for (; median < this.state.processingTimeBuckets.length; median++) {
      count2 += this.state.processingTimeBuckets[median];
      if (count2 >= (this.state.n + 1) / 2)
        break;
    }
    return {
      avgFps: this.state.avgFps,
      lensFrameProcessingTimeMsAvg: this.state.procFrameMean,
      lensFrameProcessingTimeMsStd: Math.sqrt(this.state.procFrameD2 / this.state.procFrameCount),
      lensFrameProcessingTimeMsMedian: this.state.n > 0 ? median : 0,
      lensFrameProcessingN: this.state.n
    };
  }
  reset() {
    this.state = Object.assign({}, getDefaultFrameMetricsState());
  }
  end() {
    this.instances.delete(this);
  }
  computeRunningStats(processingTimeMs) {
    const delta = processingTimeMs - this.state.procFrameMean;
    this.state.procFrameCount += 1;
    this.state.procFrameMean += delta / this.state.procFrameCount;
    const delta2 = processingTimeMs - this.state.procFrameMean;
    this.state.procFrameD2 += delta * delta2;
    if (this.priorFrameCompletedTime === void 0) {
      this.priorFrameCompletedTime = performance.now();
    } else {
      const frameDurationSec = (performance.now() - this.priorFrameCompletedTime) / 1e3;
      if (frameDurationSec < frameDurationThreshold) {
        this.state.avgFps = (this.state.avgFps + 1 / frameDurationSec) / 2;
      }
      this.priorFrameCompletedTime = performance.now();
    }
    this.state.n++;
    this.state.processingTimeBuckets[Math.min(Math.round(processingTimeMs), frameProcessingTimeMedianMax)]++;
  }
};

// node_modules/@snap/camera-kit/dist/session/LensPerformanceMetrics.js
var logger9 = getLogger("RenderingMetrics");
var LensPerformanceMetrics = (() => {
  var _a;
  let _instanceExtraInitializers = [];
  let _beginMeasurement_decorators;
  return _a = class LensPerformanceMetrics {
    constructor(lensCore) {
      this.lensCore = (__runInitializers(this, _instanceExtraInitializers), lensCore);
      this.measurementInstances = /* @__PURE__ */ new Set();
      this.lensCore.setOnFrameProcessedCallback({
        onFrameProcessed: ({ processingTimeMs }) => {
          try {
            for (const measurement of this.measurementInstances.values()) {
              measurement.update(processingTimeMs);
            }
          } catch (error) {
            logger9.error(error);
          }
        }
      }).catch((error) => logger9.error(`Failed registering setOnFrameProcessedCallback with error: ${error.message}`));
    }
    beginMeasurement() {
      return new LensPerformanceMeasurement(this.measurementInstances);
    }
  }, (() => {
    _beginMeasurement_decorators = [errorLoggingDecorator(logger9)];
    __esDecorate(_a, null, _beginMeasurement_decorators, { kind: "method", name: "beginMeasurement", static: false, private: false, access: { has: (obj) => "beginMeasurement" in obj, get: (obj) => obj.beginMeasurement } }, null, _instanceExtraInitializers);
  })(), _a;
})();

// node_modules/@snap/camera-kit/dist/lens/LensPersistenceStore.js
var logger10 = getLogger("LensPersistenceStore");
var lensPersistenceStoreFactory = Injectable("lensPersistenceStore", [lensCoreFactory.token], (lensCore) => {
  const db = new IndexedDBPersistence({ databaseName: "lensPersistenceStore" });
  lensCore.registerSavePersistentStoreCallback((id, data) => __awaiter(void 0, void 0, void 0, function* () {
    try {
      yield db.store(id, data);
    } catch (error) {
      logger10.error(persistentStoreError(`Error occurred while storing data for lens ${id}.`, error));
    }
  }));
  return db;
});

// node_modules/@snap/camera-kit/dist/common/localization.js
function makeTemplate(keys) {
  return (template) => (values) => {
    const tag = (readonlyStrings) => {
      const strings = readonlyStrings.slice();
      return [strings.shift()].concat(keys.map((key) => {
        var _a;
        return `${(_a = values[key]) !== null && _a !== void 0 ? _a : ""}${strings.shift()}`;
      })).concat(strings).join("");
    };
    return template(tag);
  };
}
var legalPromptMessage = makeTemplate(["privacyPolicyUrl", "termsOfServiceUrl", "learnMoreUrl"]);
var allStrings = {
  "en-US": {
    legalPromptMessage: legalPromptMessage((tag) => tag`By using Lenses, you acknowledge reading Snaps <a href="${0}" target="_blank">Privacy Policy</a> and agree to Snaps <a href="${0}" target="_blank">Terms of Service</a>. Some lenses use information about your face, hands and voice to work. <a href="${0}" target="_blank">Learn More</a>, and if you want to agree and continue, tap below.`),
    legalPromptAccept: `I Agree`,
    legalPromptReject: `Dismiss`,
    legalPromptTermsOfService: `Terms of Service`,
    legalPromptVariantGMessage: `This feature uses information about face(s), hands and voice(s) detected by the camera and microphone to work. With this feature, you can apply fun and useful augmented reality effects on top of selfies and images. Our camera uses technology to locate certain features (like where your hands, eyes, and nose are) and uses that information to accurately position the feature with the image sensed by the camera. Any information that is collected will be deleted as soon as possible (typically soon after the app is closed) and always within no more than three years.<br/><br/>If you want to agree and continue, tap below.`,
    legalPromptVariantGAdultOrChild: `Are you an adult or child?`,
    legalPromptVariantGFindYourParent: `Please find your parent or legal guardian.`,
    legalPromptVariantGIAmGuardian: `I am the child's guardian`,
    legalPromptVariantGCancel: `Cancel`,
    legalPromptVariantGAdult: `Adult`,
    legalPromptVariantGChild: `Child`
  },
  ar: {
    legalPromptMessage: legalPromptMessage((tag) => tag`     <a href="${0}" target="_blank"> </a>   <a href="${0}" target="_blank"> </a>  .          . <a href="${0}" target="_blank">    </a>      .`),
    legalPromptAccept: ` `,
    legalPromptReject: ``,
    legalPromptTermsOfService: ` `,
    legalPromptVariantGMessage: `     ()  ()    .              .         (     )            .           (     )        .<br/><br/>      .`,
    legalPromptVariantGAdultOrChild: `     `,
    legalPromptVariantGFindYourParent: `       .`,
    legalPromptVariantGIAmGuardian: `   `,
    legalPromptVariantGCancel: ``,
    legalPromptVariantGAdult: ` `,
    legalPromptVariantGChild: ``
  },
  "bn-BD": {
    legalPromptMessage: legalPromptMessage((tag) => tag`     Snap- <a href="${0}" target="_blank"> </a>   Snap- <a href="${0}" target="_blank"> </a>-             ,      <a href="${0}" target="_blank"> </a>             `),
    legalPromptAccept: `  `,
    legalPromptReject: ` `,
    legalPromptTermsOfService: ` `,
    legalPromptVariantGMessage: `          ,                             (  ,    )                              (    )          <br/><br/>            `,
    legalPromptVariantGAdultOrChild: `    ?`,
    legalPromptVariantGFindYourParent: `       `,
    legalPromptVariantGIAmGuardian: `  `,
    legalPromptVariantGCancel: ` `,
    legalPromptVariantGAdult: ``,
    legalPromptVariantGChild: ``
  },
  "bn-IN": {
    legalPromptMessage: legalPromptMessage((tag) => tag`  ,  Snap\' \"<a href="${0}" target="_blank">\" </a>   Snap\' <a href="${0}" target="_blank"> </a>-             ,       <a href="${0}" target="_blank"> </a>           `),
    legalPromptAccept: ` `,
    legalPromptReject: ` `,
    legalPromptTermsOfService: ` `,
    legalPromptVariantGMessage: `           (),   ()       ,                         (  ,    )                    <br/><br/>       ,   `,
    legalPromptVariantGAdultOrChild: `     ?`,
    legalPromptVariantGFindYourParent: `   -    `,
    legalPromptVariantGIAmGuardian: `  `,
    legalPromptVariantGCancel: ` `,
    legalPromptVariantGAdult: ``,
    legalPromptVariantGChild: ``
  },
  "da-DK": {
    legalPromptMessage: legalPromptMessage((tag) => tag`Nr du anvender Linser, bekrfter du, at du har lst Snaps <a href="${0}" target="_blank">privatlivspolitik</a> og accepterer Snaps <a href="${0}" target="_blank">servicevilkr</a>. Nogle Linser bruger information om dit ansigt, dine hnder og din stemme for at fungere. <a href="${0}" target="_blank">F mere at vide</a>, og tryk nedenfor, hvis du vil acceptere og fortstte.`),
    legalPromptAccept: `Jeg er enig`,
    legalPromptReject: `Afvis`,
    legalPromptTermsOfService: `Servicevilkr`,
    legalPromptVariantGMessage: `Denne funktion bruger oplysninger om ansigt(er), hnder og stemme(r), der registreres af kameraet og mikrofonen, for at kunne fungere. Med denne funktion kan du anvende sjove og nyttige augmented reality-effekter p selfies og billeder. Vores kamera bruger teknologi til at finde bestemte trk (f.eks. hvor dine hnder, jne og nse er) og bruger disse oplysninger til njagtigt at placere trkket i billedet, der opfanges af kameraet. Alle oplysninger, der indsamles, slettes s hurtigst som muligt (typisk kort efter, at appen lukkes) og altid inden for hjst tre r.<br/><br/>Tryk herunder, hvis du accepterer og vil fortstte.`,
    legalPromptVariantGAdultOrChild: `Er du voksen eller barn?`,
    legalPromptVariantGFindYourParent: `Find din forlder eller vrge.`,
    legalPromptVariantGIAmGuardian: `Jeg er barnets vrge`,
    legalPromptVariantGCancel: `Annuller`,
    legalPromptVariantGAdult: `Voksen`,
    legalPromptVariantGChild: `Barn`
  },
  "de-DE": {
    legalPromptMessage: legalPromptMessage((tag) => tag`Wenn du Linsen verwendet, versicherst du, dass du die <a href="${0}" target="_blank">Datenschutzbestimmungen</a> von Snap gelesen hast und den <a href="${0}" target="_blank">Servicebestimmungen</a> von Snap zustimmst. Manche Linsen verarbeiten Informationen zu deinem Gesicht, deinen Hnden und deiner Stimme, um zu funktionieren. <a href="${0}" target="_blank">Hier erfhrst du mehr.</a> Tippe unten, wenn du zustimmen und fortfahren mchtest.`),
    legalPromptAccept: `Zustimmen`,
    legalPromptReject: `Ablehnen`,
    legalPromptTermsOfService: `Servicebestimmungen`,
    legalPromptVariantGMessage: `Diese Funktion verwendet Informationen ber Gesichter, Hnde und Stimmen, die von der Kamera und dem Mikrofon erkannt werden. Mit dieser Funktion kannst du lustige und ntzliche Augmented Reality-Effekte auf Selfies und Bilder anwenden. Unsere Kamera nutzt Technologien, um bestimmte Merkmale zu lokalisieren (z. B. wo sich deine Hnde, Augen und Nase befinden), und verwendet diese Informationen, um dieses Merkmal dann exakt ber das von der Kamera erfasste Bild zu positionieren. Alle gesammelten Informationen werden so schnell wie mglich gelscht (in der Regel kurz nach dem Schlieen der App), sptestens aber innerhalb von dreiJahren.<br/><br/>Tippe unten, um zuzustimmen und fortzufahren.`,
    legalPromptVariantGAdultOrChild: `Bist du erwachsen oder minderjhrig?`,
    legalPromptVariantGFindYourParent: `Bitte hole ein Elternteil oder Erziehungsberechtigten.`,
    legalPromptVariantGIAmGuardian: `Ich bin der Erziehungsberechtigte des Kindes.`,
    legalPromptVariantGCancel: `Abbrechen`,
    legalPromptVariantGAdult: `Erwachsen`,
    legalPromptVariantGChild: `Minderjhrig`
  },
  "el-GR": {
    legalPromptMessage: legalPromptMessage((tag) => tag`  ,      <a href="${0}" target="_blank"> </a>  Snap      <a href="${0}" target="_blank"> </a>  Snap.        ,         . <a href="${0}" target="_blank"> </a>        ,  .`),
    legalPromptAccept: ``,
    legalPromptReject: ``,
    legalPromptTermsOfService: ` `,
    legalPromptVariantGMessage: `        ,             ,   .                 .            (    ,      )                   .          (      )          .<br/><br/>     ,  .`,
    legalPromptVariantGAdultOrChild: `   ;`,
    legalPromptVariantGFindYourParent: `       .`,
    legalPromptVariantGIAmGuardian: `    `,
    legalPromptVariantGCancel: ``,
    legalPromptVariantGAdult: ``,
    legalPromptVariantGChild: ``
  },
  "en-GB": {
    legalPromptMessage: legalPromptMessage((tag) => tag`By using Lenses, you acknowledge reading Snap\s <a href="${0}" target="_blank">Privacy Policy</a> and agree to Snap\s <a href="${0}" target="_blank">Terms of Service</a>. Some Lenses use information about your face, hands and voice to work. <a href="${0}" target="_blank">Learn More</a>, and if you want to agree and continue, tap below.`),
    legalPromptAccept: `I agree`,
    legalPromptReject: `Dismiss`,
    legalPromptTermsOfService: `Terms of Service`,
    legalPromptVariantGMessage: `This feature uses information about face(s), hands and voice(s) detected by the camera and microphone to work. With this feature, you can apply fun and useful augmented reality effects on top of selfies and images. Our camera uses technology to locate certain features (like where your hands, eyes and nose are) and uses that information to accurately position the feature with the image sensed by the camera. Any information that is collected will be deleted as soon as possible (typically soon after the app is closed) and always within no more than three years.<br/><br/>If you want to agree and continue, tap below.`,
    legalPromptVariantGAdultOrChild: `Are you an adult or child?`,
    legalPromptVariantGFindYourParent: `Please find your parent or legal guardian.`,
    legalPromptVariantGIAmGuardian: `I am the childs guardian`,
    legalPromptVariantGCancel: `Cancel`,
    legalPromptVariantGAdult: `Adult`,
    legalPromptVariantGChild: `Child`
  },
  es: {
    legalPromptMessage: legalPromptMessage((tag) => tag`Al usar Lentes, confirmas que leste la <a href="${0}" target="_blank">Poltica de privacidad</a> de Snap y aceptas las <a href="${0}" target="_blank">Condiciones de servicio</a>. Algunos Lentes funcionan usando informacin acerca de tu cara, tus manos y tu voz. <a href="${0}" target="_blank">Obtn ms informacin</a> y, si quieres aceptar y continuar, toca a continuacin.`),
    legalPromptAccept: `Acepto`,
    legalPromptReject: `Ignorar`,
    legalPromptTermsOfService: `Condiciones de servicio`,
    legalPromptVariantGMessage: `Esta funcin utiliza informacin sobre caras, manos y voces detectadas por la cmara y el micrfono para funcionar. Con esta funcin, puedes aplicar divertidos y tiles efectos de realidad aumentada sobre selfies e imgenes. Nuestra cmara utiliza tecnologa para localizar ciertos rasgos (como dnde estn las manos, los ojos y la nariz) y utiliza dicha informacin para posicionar correctamente el rasgo sobre la imagen detectada por la cmara. Toda la informacin recopilada se eliminar tan pronto como sea posible (por lo general, poco despus de que se cierre la app), siempre en un plazo menor a tres aos.<br/><br/>Para aceptar y continuar, toca a continuacin.`,
    legalPromptVariantGAdultOrChild: `Eres mayor o menor de edad?`,
    legalPromptVariantGFindYourParent: `Busca a tu padre, madre o tutor legal.`,
    legalPromptVariantGIAmGuardian: `Soy el tutor legal del menor`,
    legalPromptVariantGCancel: `Cancelar`,
    legalPromptVariantGAdult: `Mayor de edad`,
    legalPromptVariantGChild: `Menor de edad`
  },
  "es-AR": {
    legalPromptMessage: legalPromptMessage((tag) => tag`Al usar los Lentes, confirms que leste la <a href="${0}" target="_blank">Poltica de privacidad</a> de Snap y que acepts sus <a href="${0}" target="_blank">Condiciones de servicio</a>. Algunos Lentes usan informacin sobre tu cara, tus manos y tu voz para funcionar. <a href="${0}" target="_blank">Obten ms informacin</a>, y si quers aceptar y continuar, toc el botn que aparece ms abajo.`),
    legalPromptAccept: `Acepto`,
    legalPromptReject: `Omitir`,
    legalPromptTermsOfService: `Condiciones de servicio`,
    legalPromptVariantGMessage: `Esta funcin utiliza la informacin sobre caras, manos y voces detectadas por la cmara y el micrfono. Con esta funcin, pods aplicar divertidos y tiles efectos de realidad aumentada sobre selfies e imgenes. Nuestra cmara utiliza tecnologa para localizar ciertos rasgos (como dnde estn las manos, los ojos y la nariz) y utiliza esa informacin para posicionar con precisin el rasgo con la imagen detectada por la cmara. Toda la informacin recopilada se eliminar lo antes posible (normalmente poco despus de cerrar la aplicacin) y siempre en un plazo mximo de tresaos.<br/><br/>Si deseas aceptar y continuar, toc a continuacin.`,
    legalPromptVariantGAdultOrChild: `Sos mayor o menor de edad?`,
    legalPromptVariantGFindYourParent: `Busc a tu padre, madre o tutor legal.`,
    legalPromptVariantGIAmGuardian: `Soy el tutor legal del menor`,
    legalPromptVariantGCancel: `Cancelar`,
    legalPromptVariantGAdult: `Mayor de edad`,
    legalPromptVariantGChild: `Menor de edad`
  },
  "es-ES": {
    legalPromptMessage: legalPromptMessage((tag) => tag`Al usar las Lentes, reconoces haber ledo la <a href="${0}" target="_blank">Poltica de privacidad</a> y aceptas los <a href="${0}" target="_blank">Trminos del servicio</a> de Snap. Algunas Lentes funcionan utilizando informacin de tu cara, tus manos o tu voz. Puedes obtener <a href="${0}" target="_blank">ms informacin</a>, y si quieres aceptar y continuar, toca el botn a continuacin.`),
    legalPromptAccept: `Acepto`,
    legalPromptReject: `Descartar`,
    legalPromptTermsOfService: `Trminos del servicio`,
    legalPromptVariantGMessage: `Para su funcionamiento, esta funcin hace uso de los datos sobre la cara, las manos y las voces detectados por la cmara y el micrfono. Con ella, puedes aplicar efectos de realidad aumentada, tanto tiles como divertidos, en selfies e imgenes. Nuestra cmara utiliza la tecnologa para localizar determinados elementos (como la posicin de las manos, los ojos o la nariz) y utiliza esta informacin para colocar el elemento sobre la imagen de forma fiel, segn lo detectado por la cmara. Cualquier informacin que se recopile se eliminar lo antes posible (normalmente, al cerrar la aplicacin) y nunca se almacenar durante ms de tres aos.<br/><br/>Si quieres aceptar y continuar, toca a continuacin.`,
    legalPromptVariantGAdultOrChild: `Eres una persona adulta o eres menor?`,
    legalPromptVariantGFindYourParent: `Habla con tu padre, madre o tutor/a legal.`,
    legalPromptVariantGIAmGuardian: `Soy el tutor o tutora legal del menor`,
    legalPromptVariantGCancel: `Cancelar`,
    legalPromptVariantGAdult: `Adulto`,
    legalPromptVariantGChild: `Menor`
  },
  "es-MX": {
    legalPromptMessage: legalPromptMessage((tag) => tag`Al usar Lentes, confirmas que leste la <a href="${0}" target="_blank">Poltica de privacidad</a> y aceptas los <a href="${0}" target="_blank">Trminos y condiciones de servicio</a> de Snap. Algunos lentes usan informacin sobre tu cara, manos o voz para funcionar. <a href="${0}" target="_blank">Obtn ms informacin</a> y, si quieres aceptarlo, toca a continuacin.`),
    legalPromptAccept: `Acepto`,
    legalPromptReject: `Ignorar`,
    legalPromptTermsOfService: `Trminos y condiciones de servicio`,
    legalPromptVariantGMessage: `Esta caracterstica utiliza informacin sobre la(s) cara(s), manos y voz o voces detectadas por la cmara y el micrfono para funcionar. Con ella, puedes aplicar efectos de realidad aumentada tiles y divertidos a selfies e imgenes. Nuestra cmara usa tecnologa para localizar ciertos rasgos (como dnde estn tus manos, ojos y nariz) y utiliza esa informacin para posicionar con precisin esta caracterstica con la imagen que la cmara percibi. Toda la informacin que se recopile se eliminar lo ms pronto posible (por lo general, poco despus de cerrar la app) y nunca exceder los tres das.<br/><br/>Si quieres aceptar y proseguir, toca a continuacin.`,
    legalPromptVariantGAdultOrChild: `Eres mayor o menor de edad?`,
    legalPromptVariantGFindYourParent: `Busca a tu madre, padre o quien tenga tu custodia legal.`,
    legalPromptVariantGIAmGuardian: `Tengo la custodia de la persona menor`,
    legalPromptVariantGCancel: `Cancelar`,
    legalPromptVariantGAdult: `Persona adulta`,
    legalPromptVariantGChild: `Persona menor`
  },
  "fi-FI": {
    legalPromptMessage: legalPromptMessage((tag) => tag`Kyttmll tehosteita ilmaiset lukeneesi Snapin <a href="${0}" target="_blank">tietosuojaselosteen</a> ja hyvksyvsi Snapin <a href="${0}" target="_blank">palveluehdot</a>. Jotkin tehosteet kyttvt toimintaan tietoja kasvoistasi, ksistsi ja nestsi. <a href="${0}" target="_blank">Listietoja saat tlt</a>. Hyvksy ja jatka napauttamalla alla olevaa painiketta.`),
    legalPromptAccept: `Hyvksyn`,
    legalPromptReject: `Hylk`,
    legalPromptTermsOfService: `Palveluehdot`,
    legalPromptVariantGMessage: `Tm ominaisuus kytt toimiakseen tietoja kameran ja mikrofonin havaitsemista kasvoista, ksist ja nist. Ominaisuudella voit list hauskoja ja hydyllisi listyn todellisuuden efektej selfieiden ja kuvien plle. Kameramme kytt teknologiaa tiettyjen piirteiden paikallistamiseen (kuten ksiesi, silmiesi ja nensi sijaintiin) ja kytt nit tietoja ominaisuuden asettamiseen oikeaan kohtaan kameran havaitsemassa kuvassa. Kaikki kertyt tiedot poistetaan mahdollisimman pian (yleens pian sovelluksen sulkemisen jlkeen) ja aina viimeistn kolmen vuoden kuluttua.<br/><br/>Jos haluat hyvksy ja jatkaa, napauta painiketta alla. `,
    legalPromptVariantGAdultOrChild: `Oletko aikuinen vai lapsi?`,
    legalPromptVariantGFindYourParent: `Etsi vanhempasi tai huoltajasi.`,
    legalPromptVariantGIAmGuardian: `Olen lapsen huoltaja`,
    legalPromptVariantGCancel: `Peruuta`,
    legalPromptVariantGAdult: `Aikuinen`,
    legalPromptVariantGChild: `Lapsi`
  },
  "fil-PH": {
    legalPromptMessage: legalPromptMessage((tag) => tag`Sa pamamagitan ng paggamit sa Lenses, kinikilala mong binasa mo ang <a href="${0}" target="_blank">Privacy Policy</a> ng Snap at sumasang-ayon ka sa <a href="${0}" target="_blank">Terms of Service</a> ng Snap. Ang ilang lens ay gumagamit ng impormasyon tungkol sa iyong mukha , mga kamay at boses para gumana. <a href="${0}" target="_blank">Alamin Pa</a>, at kung gusto mong sumang-ayon at magpatuloy, mag-tap sa ibaba.`),
    legalPromptAccept: `Sang-ayon Ako`,
    legalPromptReject: `I-dismiss`,
    legalPromptTermsOfService: `Terms of Service`,
    legalPromptVariantGMessage: `Ang feature na ito ay gumagamit ng impormasyon tungkol sa (mga) mukha, mga kamay at (mga) boses na nade-detect ng camera at microphone para gumana ito. Gamit ang feature na ito, pwede kang mag-apply ng nakakatuwa at kapaki-pakinabang na augmented reality effects sa ibabaw ng mga selfie at image. Gumagamit ang camera namin ng technology para matukoy ang mga partikular na anyo (tulad ng kung nasaan ang iyong mga kamay, mga mata, at ilong) at ginagamit nito ang impormasyong iyon para eksaktong mapwesto ang anyong iyon sa image na nase-sense ng camera. Ang anumang impormasyong kinokolekta ay ide-delete sa lalong madaling panahon (karaniwan ay maikling panahon lang matapos isara ang app) at palaging hindi lalampas nang tatlong taon.<br/><br/>Kung gusto mong sumang-ayon at magpatuloy, mag-tap sa ibaba.`,
    legalPromptVariantGAdultOrChild: `Isa ka bang adult o bata?`,
    legalPromptVariantGFindYourParent: `Pakihanap ang iyong magulang o legal guardian.`,
    legalPromptVariantGIAmGuardian: `Ako ang guardian ng bata`,
    legalPromptVariantGCancel: `I-cancel`,
    legalPromptVariantGAdult: `Adult`,
    legalPromptVariantGChild: `Bata`
  },
  "fr-FR": {
    legalPromptMessage: legalPromptMessage((tag) => tag`En utilisant les Lenses, vous reconnaissez avoir lu la <a href="${0}" target="_blank">Politique de confidentialit</a> de Snap et vous acceptez les <a href="${0}" target="_blank">Conditions d\'utilisation du service</a> de Snap. Le fonctionnement de certaines Lenses requiert l\'utilisation d\'informations sur votre visage, vos mains et votre voix. <a href="${0}" target="_blank">En savoir plus</a>. Si vous acceptez ces conditions et souhaitez continuer, appuyez ci-dessous.`),
    legalPromptAccept: `J'accepte`,
    legalPromptReject: `Ignorer`,
    legalPromptTermsOfService: `Conditions d'utilisation du service`,
    legalPromptVariantGMessage: `Pour fonctionner, cette fonctionnalit utilise des informations sur le ou les visages, les mains et la ou les voix dtects par l'appareil photo et le micro. Elle vous permet d'appliquer des effets en ralit augmente amusants et utiles sur vos selfies et vos images. Notre appareil photo utilise une technologie qui localise certaines caractristiques (comme l'emplacement de vos mains, de vos yeux et de votre nez) afin de positionner avec prcision la fonctionnalit sur l'image dtecte par l'appareil photo. Toutes les informations collectes sont supprimes ds que possible (gnralement peu aprs la fermeture de l'application) et toujours dans un dlai maximum de trois ans.<br/><br/>Si vous souhaitez accepter et continuer, appuyez ci-dessous.`,
    legalPromptVariantGAdultOrChild: `tes-vous adulte ou mineur?`,
    legalPromptVariantGFindYourParent: `Veuillez appeler votre parent ou votre tuteurrice.`,
    legalPromptVariantGIAmGuardian: `Je suis le ou la tuteurrice de l'enfant.`,
    legalPromptVariantGCancel: `Annuler`,
    legalPromptVariantGAdult: `Adulte`,
    legalPromptVariantGChild: `Mineur`
  },
  "gu-IN": {
    legalPromptMessage: legalPromptMessage((tag) => tag`  ,      Snap <a href="${0}" target="_blank"> </a>    Snap <a href="${0}" target="_blank"> </a>   .          ,      . <a href="${0}" target="_blank"> </a>,       ,    .`),
    legalPromptAccept: `  `,
    legalPromptReject: ` `,
    legalPromptTermsOfService: ` `,
    legalPromptVariantGMessage: `            (),   ()     .                  .     (   ,      )                       .          (       )        .<br/><br/>        ,    .`,
    legalPromptVariantGAdultOrChild: `    ?`,
    legalPromptVariantGFindYourParent: `   -    .`,
    legalPromptVariantGIAmGuardian: `   .`,
    legalPromptVariantGCancel: ` `,
    legalPromptVariantGAdult: ``,
    legalPromptVariantGChild: ``
  },
  "hi-IN": {
    legalPromptMessage: legalPromptMessage((tag) => tag`   ,       Snap  <a href="${0}" target="_blank"> </a>       Snap  <a href="${0}" target="_blank"> </a>           ,        <a href="${0}" target="_blank"> </a>,           ,    `),
    legalPromptAccept: `  `,
    legalPromptReject: ` `,
    legalPromptTermsOfService: ` `,
    legalPromptVariantGMessage: `          ,   ()                                   ( ,  ,     )                                         (     )            <br/><br/>        ,    `,
    legalPromptVariantGAdultOrChild: `     ?`,
    legalPromptVariantGFindYourParent: `  -      `,
    legalPromptVariantGIAmGuardian: `    `,
    legalPromptVariantGCancel: ` `,
    legalPromptVariantGAdult: ``,
    legalPromptVariantGChild: ``
  },
  "id-ID": {
    legalPromptMessage: legalPromptMessage((tag) => tag`Dengan menggunakan Lensa, kamu menyatakan bahwa kamu sudah membaca <a href="${0}" target="_blank">Kebijakan Privasi</a> Snap dan menyetujui <a href="${0}" target="_blank">Ketentuan Layanan</a> Snap. Beberapa lensa menggunakan informasi tentang wajah, tangan, dan suaramu agar bisa berfungsi dengan baik. <a href="${0}" target="_blank">Pelajari Selengkapnya</a>, dan silakan ketuk tombol di bawah jika kamu ingin menyetujuinya dan melanjutkan.`),
    legalPromptAccept: `Saya setuju`,
    legalPromptReject: `Tutup`,
    legalPromptTermsOfService: `Ketentuan Layanan`,
    legalPromptVariantGMessage: `Agar bisa berfungsi, fitur ini menggunakan informasi terkait wajah, tangan, dan suara yang dideteksi oleh kamera serta mikrofon. Dengan fitur ini, efek augmented reality yang menyenangkan dan berguna dapat diterapkan ke selfie dan gambar. Kamera kami menggunakan teknologi untuk menemukan lokasi fitur tertentu (misalnya menemukan bagian tangan, mata, dan hidung), lalu menggunakan informasi tersebut untuk menempatkan fitur secara akurat di gambar yang dideteksi oleh kamera. Informasi apa pun yang dikumpulkan akan segera dihapus (biasanya setelah aplikasi ditutup) dan selalu disimpan tidak lebih dari tiga tahun.<br/><br/>Jika ingin menyetujui dan melanjutkan, ketuk tombol di bawah ini.`,
    legalPromptVariantGAdultOrChild: `Apakah kamu orang dewasa atau anak-anak?`,
    legalPromptVariantGFindYourParent: `Panggil orang tua atau wali resmi.`,
    legalPromptVariantGIAmGuardian: `Saya wali si anak`,
    legalPromptVariantGCancel: `Batal`,
    legalPromptVariantGAdult: `Orang Dewasa`,
    legalPromptVariantGChild: `Anak-Anak`
  },
  "it-IT": {
    legalPromptMessage: legalPromptMessage((tag) => tag`Usando le Lenti, confermi di aver letto l\'<a href="${0}" target="_blank">Informativa sulla Privacy</a> di Snap Inc. e di accettare i <a href="${0}" target="_blank">Termini di Servizio</a> di Snap Inc. Alcune Lenti utilizzano informazioni sul tuo viso, le tue mani e la tua voce per funzionare. <a href="${0}" target="_blank">Scopri di pi</a> e, se sei d\'accordo e vuoi continuare, tocca qui sotto.`),
    legalPromptAccept: `Accetto`,
    legalPromptReject: `Ignora`,
    legalPromptTermsOfService: `Termini di Servizio`,
    legalPromptVariantGMessage: `Questa funzionalit utilizza le informazioni su viso, mani e voce rilevate dalla fotocamera e dal microfono per funzionare. Ti consente di applicare effetti in realt aumentata divertenti e utili ai selfie e alle immagini. La nostra Fotocamera sfrutta una tecnologia specifica per individuare certe parti del corpo (ad esempio mani, occhi e naso) e usa questi dati per posizionarle in modo accurato sull'immagine rilevata. Qualsiasi informazione raccolta viene eliminata appena possibile (di solito poco dopo la chiusura dell'app) e, in ogni caso, entro 3 anni.<br/><br/>Se sei d'accordo e vuoi continuare, tocca qui sotto.`,
    legalPromptVariantGAdultOrChild: `Sei un adulto o un minore?`,
    legalPromptVariantGFindYourParent: `C' bisogno di un genitore o tutore legale.`,
    legalPromptVariantGIAmGuardian: `Sono il tutore del minore`,
    legalPromptVariantGCancel: `Annulla`,
    legalPromptVariantGAdult: `Adulto`,
    legalPromptVariantGChild: `Minore`
  },
  "ja-JP": {
    legalPromptMessage: legalPromptMessage((tag) => tag`Snap<a href="${0}" target="_blank"></a><a href="${0}" target="_blank"></a><a href="${0}" target="_blank"></a>`),
    legalPromptAccept: ``,
    legalPromptReject: ``,
    legalPromptTermsOfService: ``,
    legalPromptVariantGMessage: `Snap3<br/><br/>`,
    legalPromptVariantGAdultOrChild: ``,
    legalPromptVariantGFindYourParent: ``,
    legalPromptVariantGIAmGuardian: ``,
    legalPromptVariantGCancel: ``,
    legalPromptVariantGAdult: ``,
    legalPromptVariantGChild: ``
  },
  "kn-IN": {
    legalPromptMessage: legalPromptMessage((tag) => tag`  , Snap  <a href="${0}" target="_blank"> </a>       Snap  <a href="${0}" target="_blank"> </a>  .     ,     . <a href="${0}" target="_blank"> </a>,       ,   .`),
    legalPromptAccept: ` `,
    legalPromptReject: ``,
    legalPromptTermsOfService: ` `,
    legalPromptVariantGMessage: `       (),   ()   .  ,            .     ( ,     )             .       (    )      . <br/><br/>     ,   .`,
    legalPromptVariantGAdultOrChild: `   ?`,
    legalPromptVariantGFindYourParent: `      .`,
    legalPromptVariantGIAmGuardian: `  `,
    legalPromptVariantGCancel: ``,
    legalPromptVariantGAdult: ``,
    legalPromptVariantGChild: ``
  },
  "ko-KR": {
    legalPromptMessage: legalPromptMessage((tag) => tag`  Snap <a href="${0}" target="_blank"> </a>  Snap <a href="${0}" target="_blank"> </a>   .    ,     . <a href="${0}" target="_blank"> </a>,     .`),
    legalPromptAccept: ``,
    legalPromptReject: ``,
    legalPromptTermsOfService: ` `,
    legalPromptVariantGMessage: `     , ,     .              . Snapchat   (: ,    )   ,          .      (   ) ,  3  .<br/><br/>   .`,
    legalPromptVariantGAdultOrChild: `, ?`,
    legalPromptVariantGFindYourParent: `     .`,
    legalPromptVariantGIAmGuardian: ` `,
    legalPromptVariantGCancel: ``,
    legalPromptVariantGAdult: ``,
    legalPromptVariantGChild: ``
  },
  "ml-IN": {
    legalPromptMessage: legalPromptMessage((tag) => tag`   Snap- <a href="${0}" target="_blank"> </a>   Snap- <a href="${0}" target="_blank"> </a>  .     , ,    . <a href="${0}" target="_blank"></a>,     .`),
    legalPromptAccept: ` `,
    legalPromptReject: ` `,
    legalPromptTermsOfService: ` `,
    legalPromptVariantGMessage: `   ,    (),  ()    .       ,     .       (  , ,   )  ,             .      (   )   () .<br/><br/>    .`,
    legalPromptVariantGAdultOrChild: `     ?`,
    legalPromptVariantGFindYourParent: `    .`,
    legalPromptVariantGIAmGuardian: `   `,
    legalPromptVariantGCancel: ``,
    legalPromptVariantGAdult: ``,
    legalPromptVariantGChild: ``
  },
  "mr-IN": {
    legalPromptMessage: legalPromptMessage((tag) => tag` ,      Snap  <a href="${0}" target="_blank"> </a>    Snap  <a href="${0}" target="_blank"> </a>  .      ,      . <a href="${0}" target="_blank">  </a>          .`),
    legalPromptAccept: `  `,
    legalPromptReject: ` `,
    legalPromptTermsOfService: ` `,
    legalPromptVariantGMessage: `        (),     .  ,             .     (   ,     )              .        (    )       .<br/><br/>       ,   .`,
    legalPromptVariantGAdultOrChild: `      ?`,
    legalPromptVariantGFindYourParent: `      .`,
    legalPromptVariantGIAmGuardian: `   `,
    legalPromptVariantGCancel: ` `,
    legalPromptVariantGAdult: ``,
    legalPromptVariantGChild: ``
  },
  "ms-MY": {
    legalPromptMessage: legalPromptMessage((tag) => tag`Dengan menggunakan Lensa, anda mengakui membaca <a href="${0}" target="_blank">Dasar Privasi</a> Snap dan bersetuju dengan <a href="${0}" target="_blank">Syarat Perkhidmatan</a> Snap. Sesetengan lensa menggunakan maklumat tentang muka anda, tangan dan suara untuk berfungsi. <a href="${0}" target="_blank">Ketahui Lebih Lanjut</a>, dan jika anda mahu bersetuju dan teruskan, ketik di bawah.`),
    legalPromptAccept: `Saya Setuju`,
    legalPromptReject: `Abaikan`,
    legalPromptTermsOfService: `Syarat Perkhidmatan`,
    legalPromptVariantGMessage: `Ciri ini menggunakan maklumat muka, tangan dan suara yang dikesan oleh kamera dan mikrofon untuk berfungsi. Dengan ciri ini, anda boleh menggunakan kesan realiti tambahan yang menyeronokkan dan berguna selain swafoto dan gambar. Kamera kami menggunakan teknologi untuk mengesan ciri tertentu (seperti di mana tangan, mata dan hidung anda) dan menggunakan maklumat tersebut untuk meletakkan ciri dengan tepat dengan imej yang dikesan oleh kamera. Sebarang maklumat yang dikumpul akan dipadamkan dengan segera (kebiasaannya sejurus aplikasi ditutup) dan sentiasa dalam tempoh tidak lebih daripada tiga tahun.<br/><br/>Jika anda bersetuju dan ingin teruskan, ketik dibawah.`,
    legalPromptVariantGAdultOrChild: `Adakah anda seorang dewasa atau kanak-kanak?`,
    legalPromptVariantGFindYourParent: `Sila cari ibu bapa atau penjaga anda yang sah.`,
    legalPromptVariantGIAmGuardian: `Saya penjaga kanak-kanak ini`,
    legalPromptVariantGCancel: `Batal`,
    legalPromptVariantGAdult: `Dewasa`,
    legalPromptVariantGChild: `Kanak-kanak`
  },
  "nb-NO": {
    legalPromptMessage: legalPromptMessage((tag) => tag`Ved  ta i bruk Linser bekrefter du at du har lest <a href="${0}" target="_blank">personvernbetingelsene</a> og at du godtar <a href="${0}" target="_blank">tjenestevilkrene</a> til Snap. Noen Linser bruker informasjon om ansiktet ditt, hendene dine og stemmen din for  fungere. <a href="${0}" target="_blank">Finn ut mer</a>. Hvis du godtar dette og vil g videre, klikker du nedenfor.`),
    legalPromptAccept: `Jeg godtar`,
    legalPromptReject: `Avvis`,
    legalPromptTermsOfService: `Tjenestevilkr`,
    legalPromptVariantGMessage: `Denne funksjonen bruker informasjon om ansikter, hender og stemmer som oppdages av kameraet og mikrofonen, for  fungere. Med denne funksjonen kan du legge til artige og nyttige effekter i utvidet virkelighet p selfier og bilder. Kameraet vrt bruker teknologi for  oppdage visse trekk (som hvor hendene, ynene og nesen er), og bruker denne informasjonen til  plassere funksjonen opp bildet som kameraet har fanget opp. All informasjon som samles inn, blir slettet s snart som mulig (vanligvis rett etter at appen lukkes) og alltid innen maks trer.<br/><br/>Hvis du nsker  godta og fortsette, trykker du nedenfor.`,
    legalPromptVariantGAdultOrChild: `Er du en voksen eller et barn?`,
    legalPromptVariantGFindYourParent: `Finn en forelder eller foresatt.`,
    legalPromptVariantGIAmGuardian: `Jeg er barnets foresatt`,
    legalPromptVariantGCancel: `Avbryt`,
    legalPromptVariantGAdult: `Voksen`,
    legalPromptVariantGChild: `Barn`
  },
  "nl-NL": {
    legalPromptMessage: legalPromptMessage((tag) => tag`Door Lenzen te gebruiken, geef je aan dat je het <a href="${0}" target="_blank">Privacybeleid</a> van Snap hebt gelezen en dat je akkoord gaat met de <a href="${0}" target="_blank">Servicevoorwaarden</a> van Snap. Sommige Lenzen gebruiken informatie over je gezicht, handen en stem om te functioneren. Lees <a href="${0}" target="_blank">meer informatie</a> en tik hieronder als je akkoord gaat en wilt doorgaan.`),
    legalPromptAccept: `Ik ga akkoord`,
    legalPromptReject: `Annuleren`,
    legalPromptTermsOfService: `Servicevoorwaarden`,
    legalPromptVariantGMessage: `Voor de werking van deze functie wordt informatie over gezicht(en), handen en stem(men) gebruikt die door camera en microfoon worden gedetecteerd. Je kunt met deze functie leuke en nuttige augmented reality-effecten op selfies en afbeeldingen plaatsen. Onze camera gebruikt technologie om de locatie te bepalen van bepaalde kenmerken (bijvoorbeeld waar je handen, ogen en neus zich bevinden) en gebruikt die informatie om het kenmerk nauwkeurig te positioneren in de afbeelding die is gedetecteerd met de camera. De verzamelde informatie wordt zo snel mogelijk verwijderd (gewoonlijk kort nadat de app is gesloten) en altijd binnen een periode van maximaal drie jaar.<br/><br/>Tik hieronder als je hiermee akkoord gaat en wilt doorgaan.`,
    legalPromptVariantGAdultOrChild: `Ben je een volwassene of een kind?`,
    legalPromptVariantGFindYourParent: `Vraag toestemming aan een ouder of wettelijke voogd.`,
    legalPromptVariantGIAmGuardian: `Ik ben de voogd van het kind`,
    legalPromptVariantGCancel: `Annuleren`,
    legalPromptVariantGAdult: `Volwassene`,
    legalPromptVariantGChild: `Kind`
  },
  pa: {
    legalPromptMessage: legalPromptMessage((tag) => tag`   ,          Snap  <a href="${0}" target="_blank">  </a>       Snap  <a href="${0}" target="_blank">  </a>          ,           <a href="${0}" target="_blank"> </a>          ,    `),
    legalPromptAccept: `  `,
    legalPromptReject: ` `,
    legalPromptTermsOfService: `  `,
    legalPromptVariantGMessage: `         (),   ()           ,                      (   ,     )                                          (  '      )      <br/><br/>        ,    `,
    legalPromptVariantGAdultOrChild: `      ?`,
    legalPromptVariantGFindYourParent: `   -    `,
    legalPromptVariantGIAmGuardian: `    `,
    legalPromptVariantGCancel: ` `,
    legalPromptVariantGAdult: ``,
    legalPromptVariantGChild: ``
  },
  "pl-PL": {
    legalPromptMessage: legalPromptMessage((tag) => tag`Korzystajc z nakadek, potwierdzasz zapoznanie si z <a href="${0}" target="_blank">Polityk prywatnoci</a> i akceptujesz <a href="${0}" target="_blank">Regulamin usugi</a>. Niektre nakadki wykorzystuj informacje o Twojej twarzy, doniach i gosie, aby dziaa poprawnie. <a href="${0}" target="_blank">Dowiedz si wicej</a>, a jeli chcesz wyrazi zgod i kontynuowa, stuknij poniej.`),
    legalPromptAccept: `Zgadzam si`,
    legalPromptReject: `Odrzu`,
    legalPromptTermsOfService: `Regulamin`,
    legalPromptVariantGMessage: `Ta funkcja wykorzystuje do dziaania informacje o twarzy (twarzach), rkach i gosie (gosach) wykrytych przez kamer i mikrofon. Dziki niej moesz nakada na selfie i zdjcia zabawne i przydatne efekty rozszerzonej rzeczywistoci. Nasza kamera wykorzystuje technologi do lokalizowania okrelonych cech (takich jak miejsce, w ktrym znajduj si Twoje rce, oczy i nos) i wykorzystuje te informacje do dokadnego umiejscowienia danej cechy na obrazie wykrywanym przez kamer. Wszelkie zebrane informacje zostan usunite moliwie jak najszybciej (zazwyczaj wkrtce po zamkniciu aplikacji) i zawsze nie pniej ni w cigu trzech lat.<br/><br/>Jeli chcesz wyrazi zgod i kontynuowa, stuknij poniej.`,
    legalPromptVariantGAdultOrChild: `Jeste osob doros czy dzieckiem?`,
    legalPromptVariantGFindYourParent: `Zwr si do swojego rodzica lub opiekuna prawnego.`,
    legalPromptVariantGIAmGuardian: `Jestem opiekunem prawnym dziecka`,
    legalPromptVariantGCancel: `Anuluj`,
    legalPromptVariantGAdult: `Osoba dorosa`,
    legalPromptVariantGChild: `Dziecko`
  },
  "pt-BR": {
    legalPromptMessage: legalPromptMessage((tag) => tag`Ao usar as Lentes, voc reconhece ter lido a <a href="${0}" target="_blank">Poltica de Privacidade</a> da Snap e concorda com os <a href="${0}" target="_blank">Termos de Servio</a> da Snap. Algumas Lentes usam informaes sobre seu rosto, mos e voz para funcionar. <a href="${0}" target="_blank">Saiba mais</a> e, se quiser concordar e continuar, toque abaixo.`),
    legalPromptAccept: `Eu concordo`,
    legalPromptReject: `Recusar`,
    legalPromptTermsOfService: `Termos de Servio`,
    legalPromptVariantGMessage: `Este recurso usa informaes sobre rosto(s), mos e voz(es) detectados pela cmera e pelo microfone para funcionar. Com este recurso, voc pode aplicar efeitos divertidos e teis de realidade aumentada em selfies e imagens. Nossa cmera usa tecnologia para localizar certos recursos (como onde esto suas mos, olhos e nariz) e usa esta informao para posicionar corretamente o recurso na imagem detectada pela cmera. Qualquer informao coletada ser apagada o mais rpido possvel (geralmente logo depois que o aplicativo  fechado) e sempre antes de trs dias.<br/><br/>Se voc quiser concordar e continuar, toque abaixo.`,
    legalPromptVariantGAdultOrChild: `Voc  adulto ou criana?`,
    legalPromptVariantGFindYourParent: `Localize seu pai/me ou representante legal.`,
    legalPromptVariantGIAmGuardian: `Sou representante da criana`,
    legalPromptVariantGCancel: `Cancelar`,
    legalPromptVariantGAdult: `Adulto`,
    legalPromptVariantGChild: `Criana`
  },
  "pt-PT": {
    legalPromptMessage: legalPromptMessage((tag) => tag`Ao utilizares as Lentes, confirmas a leitura da <a href="${0}" target="_blank">Poltica de Privacidade</a> da Snap e aceitas as <a href="${0}" target="_blank">Condies de Servio</a> da Snap. Algumas Lentes utilizam informaes sobre a tua cara, mos e voz para funcionarem. <a href="${0}" target="_blank">Obtm mais informaes</a> e, se quiseres aceitar e continuar, toca abaixo.`),
    legalPromptAccept: `Aceito`,
    legalPromptReject: `Fechar`,
    legalPromptTermsOfService: `Condies de Servio`,
    legalPromptVariantGMessage: `Esta funcionalidade utiliza informaes relacionadas com caras, mos e vozes detetadas pela cmara e o microfone para poder funcionar. Com esta funcionalidade, pode aplicar efeitos de realidade aumentada de forma divertida e til a selfies e imagens. A nossa cmara recorre a tecnologia para localizar determinadas caratersticas (como a localizao das tuas mos, dos olhos e do nariz) e utiliza essas informaes para posicionar de forma precisa a caraterstica na imagem captada pela cmara. Quaisquer informaes recolhidas sero eliminadas logo que possvel (normalmente pouco depois de a app ser fechada) e nunca aps um mximo de trs anos. <br/><br/>Se quiser aceitar e continuar, toque abaixo.`,
    legalPromptVariantGAdultOrChild: `s um adulto ou uma criana?`,
    legalPromptVariantGFindYourParent: `Recorre ao teus pais ou ao() teu(tua) representante legal`,
    legalPromptVariantGIAmGuardian: `Sou o(a) representante da criana`,
    legalPromptVariantGCancel: `Cancelar`,
    legalPromptVariantGAdult: `Adulto`,
    legalPromptVariantGChild: `Criana`
  },
  "ro-RO": {
    legalPromptMessage: legalPromptMessage((tag) => tag`Dac foloseti lentile, confirmi c ai citit <a href="${0}" target="_blank">Politica de confidenialitate</a> Snap i c eti de acord cu <a href="${0}" target="_blank">Condiiile de utilizare</a> Snap. Unele lentile folosesc informaii despre faa ta, despre minile tale i despre vocea ta pentru a funciona. <a href="${0}" target="_blank">Afl mai multe</a>, iar dac doreti s accepi i s continui, atinge dedesubt.`),
    legalPromptAccept: `Accept`,
    legalPromptReject: `Respinge`,
    legalPromptTermsOfService: `Termeni de utilizare`,
    legalPromptVariantGMessage: `Pentru a rula, funcia utilizeaz informaii despre chipul tu, minile tale i vocea ta detectate de camer i microfon. Cu ajutorul acestei funcii, poi s aplici efecte de realitate augumentat amuzante i utile peste selfie-uri i imagini. Camera noastr folosete tehnologia pentru a gsi anumite caracteristici (de exemplu, unde se afl minile, ochii i nasul tu) i utilizeaz aceste informaii pentru a poziiona corect funcia n imaginea detectat de camer. Toate informaiile colectate sunt terse ct mai curnd posibil (de obicei, la scurt timp dup ce se nchide aplicaia), limita maxim fiind de trei ani.<br/><br/>Dac eti de acord i doreti s continui, atinge mai jos.`,
    legalPromptVariantGAdultOrChild: `Eti adult sau copil?`,
    legalPromptVariantGFindYourParent: `Este necesar prezena printelui sau a tutorelui.`,
    legalPromptVariantGIAmGuardian: `Sunt tutorele copilului`,
    legalPromptVariantGCancel: `Anuleaz`,
    legalPromptVariantGAdult: `Adult`,
    legalPromptVariantGChild: `Copil`
  },
  "ru-RU": {
    legalPromptMessage: legalPromptMessage((tag) => tag` ,  ,   <a href="${0}" target="_blank"> </a> Snap   <a href="${0}" target="_blank">  </a>.         ,   . <a href="${0}" target="_blank"></a>.    ,  .`),
    legalPromptAccept: ``,
    legalPromptReject: ``,
    legalPromptTermsOfService: `  `,
    legalPromptVariantGMessage: `           ,   .               .    ,      (,  ,   ),          ,   .        ( ,    ),   ,    .<br/><br/>     ,  .`,
    legalPromptVariantGAdultOrChild: `   ?`,
    legalPromptVariantGFindYourParent: `    .`,
    legalPromptVariantGIAmGuardian: `   `,
    legalPromptVariantGCancel: ``,
    legalPromptVariantGAdult: ``,
    legalPromptVariantGChild: ``
  },
  "sv-SE": {
    legalPromptMessage: legalPromptMessage((tag) => tag`Genom att anvnda linser intygar du att du har lst Snaps <a href="${0}" target="_blank">sekretessvillkor</a> och godknner Snaps <a href="${0}" target="_blank">anvndarvillkor</a>. Vissa linser anvnder information om ditt ansikte, dina hnder och din rst fr att fungera. <a href="${0}" target="_blank">Ls mer</a> och om du vill godknna och fortstta s trycker du nedan.`),
    legalPromptAccept: `Jag godknner`,
    legalPromptReject: `Avvisa`,
    legalPromptTermsOfService: `Anvndarvillkor`,
    legalPromptVariantGMessage: `Fr att fungera anvnder funktionen information om ansikte(n), hnder och rst(er) som upptckts av kameran och mikrofonen. Funktionen gr att du kan tillmpa roliga och anvndbara AR-effekter ver selfies och bilder. Med hjlp av teknik kan vr kamera lokalisera vissa srdrag (som dina hnder, gon och din nsa). Informationen anvnds sedan fr att korrekt positionera funktionen ver bilden som kameran fngat upp. All information som samlats in raderas s snart som mjligt (vanligtvis inom kort efter att appen stngts) och alltid inom tre r.<br/><br/>Tryck nedan om du vill godknna och fortstta.`,
    legalPromptVariantGAdultOrChild: `r du vuxen eller ett barn?`,
    legalPromptVariantGFindYourParent: `Leta upp din frlder eller vrdnadshavare`,
    legalPromptVariantGIAmGuardian: `Jag r barnets vrdnadshavare`,
    legalPromptVariantGCancel: `Avbryt`,
    legalPromptVariantGAdult: `Vuxen`,
    legalPromptVariantGChild: `Barn`
  },
  "ta-IN": {
    legalPromptMessage: legalPromptMessage((tag) => tag`  ,  Snap  <a href="${0}" target="_blank"> </a>    Snap  <a href="${0}" target="_blank"> </a> .      ,      . <a href="${0}" target="_blank"> </a>,    ,  .`),
    legalPromptAccept: ``,
    legalPromptReject: ``,
    legalPromptTermsOfService: ` `,
    legalPromptVariantGMessage: `         (),   ()   .             .      (,  , ,      )  ,         .       (,  ). ,      .<br/><br/>   ,  .`,
    legalPromptVariantGAdultOrChild: `   ?`,
    legalPromptVariantGFindYourParent: `     .`,
    legalPromptVariantGIAmGuardian: `  `,
    legalPromptVariantGCancel: ``,
    legalPromptVariantGAdult: ``,
    legalPromptVariantGChild: ``
  },
  "te-IN": {
    legalPromptMessage: legalPromptMessage((tag) => tag`  ,  Snap  <a href="${0}" target="_blank"> </a>    Snap <a href="${0}" target="_blank"> </a> .      ,      . <a href="${0}" target="_blank"> </a>,   ,   .`),
    legalPromptAccept: ` `,
    legalPromptReject: ` `,
    legalPromptTermsOfService: ` `,
    legalPromptVariantGMessage: `         (),   ()   .  ,  ,         .     ( ,     )              .      (   )      .<br/><br/>  ,   .`,
    legalPromptVariantGAdultOrChild: `   ?`,
    legalPromptVariantGFindYourParent: `      .`,
    legalPromptVariantGIAmGuardian: `  `,
    legalPromptVariantGCancel: ``,
    legalPromptVariantGAdult: ``,
    legalPromptVariantGChild: ``
  },
  "th-TH": {
    legalPromptMessage: legalPromptMessage((tag) => tag` <a href="${0}" target="_blank"></a>  Snap  <a href="${0}" target="_blank"></a>  Snap    <a href="${0}" target="_blank"></a>  `),
    legalPromptAccept: ``,
    legalPromptReject: ``,
    legalPromptTermsOfService: ``,
    legalPromptVariantGMessage: `     (AR)   (   )     () <br/><br/> `,
    legalPromptVariantGAdultOrChild: `?`,
    legalPromptVariantGFindYourParent: ``,
    legalPromptVariantGIAmGuardian: ``,
    legalPromptVariantGCancel: ``,
    legalPromptVariantGAdult: ``,
    legalPromptVariantGChild: ``
  },
  "tr-TR": {
    legalPromptMessage: legalPromptMessage((tag) => tag`Lensleri kullanarak, Snap\'in <a href="${0}" target="_blank">Gizlilik Politikas</a> ieriini okuduunu dorulam ve Snap\'in <a href="${0}" target="_blank">Kullanm artlar</a> ieriini kabul etmi olursun. Baz lenslerin almas iin yzn, ellerin ve sesinle ilgili bilgiler kullanlr. <a href="${0}" target="_blank">Daha Fazlasn ren</a> ve kabul edip devam etmek istiyorsan aaya dokun.`),
    legalPromptAccept: `Kabul Ediyorum`,
    legalPromptReject: `Yoksay`,
    legalPromptTermsOfService: `Kullanm artlar`,
    legalPromptVariantGMessage: `Bu zelliin almas iin kamera ve mikrofon tarafndan alglanan yzler, eller ve sesler hakkndaki bilgiler kullanlr. Bu zellik sayesinde selfie'lerin ve grntlerin zerine elenceli ve kullanl artrlm gereklik efektleri uygulayabilirsin. Kameramz, belirli zellikleri (ellerinin, gzlerinin ve burnunun nerede olduu gibi) bulmak iin teknolojiden yararlanr ve bu bilgileri, kamera tarafndan alglanan grntyle zellii doru ekilde konumlandrmak iin kullanr. Toplanan tm bilgiler mmkn olan en ksa srede (genellikle uygulama kapatldktan ksa sre sonra) ve mutlaka en fazla  yl iinde silinir.<br/><br/>Kabul edip devam etmek istiyorsan aaya dokun.`,
    legalPromptVariantGAdultOrChild: `Yetikin mi yoksa ocuk musun?`,
    legalPromptVariantGFindYourParent: `Ltfen ebeveynini veya yasal vasini bul.`,
    legalPromptVariantGIAmGuardian: `Ben ocuun vasisiyim`,
    legalPromptVariantGCancel: `ptal Et`,
    legalPromptVariantGAdult: `Yetikin`,
    legalPromptVariantGChild: `ocuk`
  },
  "ur-PK": {
    legalPromptMessage: legalPromptMessage((tag) => tag`        Snap  <a href="${0}" target="_blank"> </a>       Snap  <a href="${0}" target="_blank">  </a>                      <a href="${0}" target="_blank"> </a>               `),
    legalPromptAccept: `  `,
    legalPromptReject: ` `,
    legalPromptTermsOfService: `  `,
    legalPromptVariantGMessage: `      ()                                                     (         )                                           (      )            <br/><br/>             `,
    legalPromptVariantGAdultOrChild: `      `,
    legalPromptVariantGFindYourParent: `   /      `,
    legalPromptVariantGIAmGuardian: `  /  `,
    legalPromptVariantGCancel: ` `,
    legalPromptVariantGAdult: ``,
    legalPromptVariantGChild: ``
  },
  "vi-VN": {
    legalPromptMessage: legalPromptMessage((tag) => tag`Bng cch s dng ng Knh, bn xc nhn  c <a href="${0}" target="_blank">Chnh Sch Bo Mt</a> ca Snap v ng  vi <a href="${0}" target="_blank">iu Khon Dch V</a>ca Snap. Mt s ng knh s dng thng tin v khun mt, bn tay v ging ni ca bn  hot ng. Bn c th <a href="${0}" target="_blank">Tm Hiu Thm</a>, cn nu bn mun ng  v tip tc, hy chm vo bn di.`),
    legalPromptAccept: `Ti ng `,
    legalPromptReject: `B Qua`,
    legalPromptTermsOfService: `iu Khon Dch V`,
    legalPromptVariantGMessage: `Tnh nng ny hot ng da trn vic s dng thng tin v khun mt, bn tay v ging ni m camera v micr pht hin c. Bn c th s dng tnh nng ny  p dng cc hiu ng thc t tng cng th v v hu ch ln nh t sng v hnh nh. Camera ca chng ti p dng cng ngh  tm nhng c im nht nh (chng hn nh v tr bn tay, mt v mi ca bn), ri s dng thng tin   xc nh chnh xc v tr ca c im trong hnh nh m camera chp c. Chng ti s xa mi thng tin c thu thp sm nht c th (thng ngay sau khi bn ng ng dng) v lun xa trong khong thi gian khng qu ba nm.<br/><br/>Nu bn mun ng  v tip tc, hy chm vo bn di.`,
    legalPromptVariantGAdultOrChild: `Bn l ngi ln hay tr em?`,
    legalPromptVariantGFindYourParent: `Vui lng tm ph huynh hoc ngi gim h hp php.`,
    legalPromptVariantGIAmGuardian: `Ti l ngi gim h ca tr`,
    legalPromptVariantGCancel: `Hy B`,
    legalPromptVariantGAdult: `Ngi ln`,
    legalPromptVariantGChild: `Tr em`
  },
  "zh-Hans": {
    legalPromptMessage: legalPromptMessage((tag) => tag` Snap <a href="${0}" target="_blank"></a> Snap <a href="${0}" target="_blank"></a><a href="${0}" target="_blank"></a>`),
    legalPromptAccept: ``,
    legalPromptReject: ``,
    legalPromptTermsOfService: ``,
    legalPromptVariantGMessage: `<br/><br/>`,
    legalPromptVariantGAdultOrChild: ``,
    legalPromptVariantGFindYourParent: ``,
    legalPromptVariantGIAmGuardian: ``,
    legalPromptVariantGCancel: ``,
    legalPromptVariantGAdult: ``,
    legalPromptVariantGChild: ``
  },
  "zh-Hant": {
    legalPromptMessage: legalPromptMessage((tag) => tag` Snap <a href="${0}" target="_blank"></a> Snap <a href="${0}" target="_blank"></a><a href="${0}" target="_blank"></a>`),
    legalPromptAccept: ``,
    legalPromptReject: ``,
    legalPromptTermsOfService: ``,
    legalPromptVariantGMessage: ` () ()<br/><br/>`,
    legalPromptVariantGAdultOrChild: ``,
    legalPromptVariantGFindYourParent: ``,
    legalPromptVariantGIAmGuardian: ``,
    legalPromptVariantGCancel: ``,
    legalPromptVariantGAdult: ``,
    legalPromptVariantGChild: ``
  }
};
var languageDefaultLocale = {
  bn: "bn-BD",
  da: "da-DK",
  de: "de-DE",
  el: "el-GR",
  en: "en-US",
  es: "es-ES",
  fi: "fi-FI",
  fil: "fil-PH",
  fr: "fr-FR",
  gu: "gu-IN",
  hi: "hi-IN",
  id: "id-ID",
  it: "it-IT",
  ja: "ja-JP",
  kn: "kn-IN",
  ko: "ko-KR",
  ml: "ml-IN",
  mr: "mr-IN",
  ms: "ms-MY",
  nb: "nb-NO",
  nl: "nl-NL",
  pl: "pl-PL",
  pt: "pt-BR",
  ro: "ro-RO",
  ru: "ru-RU",
  sv: "sv-SE",
  ta: "ta-IN",
  te: "te-IN",
  th: "th-TH",
  tr: "tr-TR",
  ur: "ur-PK",
  vi: "vi-VN",
  zh: "zh-Hans"
};
var synonyms = {
  "zh-TW": "zh-Hant",
  "zh-CN": "zh-Hans"
};
var isLocaleString = (value) => value in allStrings;
var defaultLocale = "en-US";
function getSupportedLocale() {
  const locale = getPlatformInfo().locale;
  if (isLocaleString(locale))
    return locale;
  const synonym = synonyms[locale];
  if (synonym && synonym in allStrings)
    return synonym;
  const langCode = locale.split("-")[0];
  if (langCode && langCode in allStrings)
    return langCode;
  if (langCode && langCode in languageDefaultLocale)
    return languageDefaultLocale[langCode];
  return defaultLocale;
}
var supportedLocale = getSupportedLocale();
function localizedString(stringId) {
  return allStrings[supportedLocale][stringId];
}

// node_modules/@snap/camera-kit/dist/common/dialog.js
var stylesCss = `
dialog {
    display: flex;
    flex-direction: column;

    background-color: #fff;
    border: #efefef 1px solid;
    border-radius: 20px;
    box-shadow: 0px 10px 20px rgba(0, 0, 0, 0.3);

    max-width: 80vw;
    max-height: 80vh;
    padding: 44px 0 24px 0;

    font-size: 16px;
    font-family: sans-serif;
    font-style: normal;
    font-weight: 600;
    line-height: 24px;
}

dialog::backdrop {
    background-color: rgba(0, 0, 0, 0.4);
}

.title {
    color: #16191C;
    padding: 0 32px;
    text-align: center;
}

.body {
    color: #656D78;
    font-size: 14px;
    font-weight: 500;
    margin-top: 16px;
    max-width: 350px;
    padding: 0 32px;
    overflow: auto;
}

a {
    color: rgb(78, 171, 248);
}

button {
    cursor: pointer;
}

button.dismiss {
    position: absolute;
    top: 7px;
    right: 7px;
    padding: 0;
    height: 36px;
    width: 36px;
    margin: 0;
    background-color: transparent;
    border: 0;
}

button.dismiss svg {
    fill: black;
}

.buttons {
    margin-top: 8px;
    padding: 0 32px;
}

.buttons button {
    background: #0FADFF;
    border: 0;
    border-radius: 25px;

    width: 100%;
    padding: 1rem;
    margin-top: 8px;

    color: #fff;
    font-weight: inherit;
    font-family: inherit;
    font-size: inherit;
    font-style: inherit;
}

.buttons button.secondary {
    background-color: transparent;
    color: #656D78;
}

// Proper filling of X button in High Contrast themes
@media (forced-colors: active) {
    button.dismiss svg {
        fill: ButtonText;
    }
}
`;
function getDismissButtonHtml(button) {
  return `
        <button class="dismiss" autofocus data-key=${button.key}>
            <svg xmlns="http://www.w3.org/2000/svg" role="img" width="36" height="36" viewBox="0 0 36 36">
                <title>${button.text}</title>
                <path fill-rule="evenodd" clip-rule="evenodd" d="M12.6763 11.2621C12.2858 10.8716 11.6527 10.8716 11.2621 11.2621C10.8716 11.6527 10.8716 12.2858 11.2621 12.6763L16.5858 18L11.2621 23.3237C10.8716 23.7142 10.8716 24.3474 11.2621 24.7379C11.6527 25.1284 12.2858 25.1284 12.6764 24.7379L18 19.4142L23.3237 24.7379C23.7142 25.1284 24.3474 25.1284 24.7379 24.7379C25.1284 24.3474 25.1284 23.7142 24.7379 23.3237L19.4142 18L24.7379 12.6763C25.1284 12.2858 25.1284 11.6527 24.7379 11.2621C24.3474 10.8716 23.7142 10.8716 23.3237 11.2621L18 16.5858L12.6763 11.2621Z" fill-opacity="0.4"/>
            </svg>
        </button>`;
}
function getTitleHtml(title) {
  return title ? `<div class="title" role="heading">${title}</div>` : "";
}
function getBodyHtml(body) {
  return body ? `<div class="body">${body}</div>` : "";
}
function getButtonHtml(button) {
  return `<button data-key="${button.key}"${button.isSecondary ? ` class="secondary"` : ""}>${button.text}</button>`;
}
function getButtonsHtml(buttons) {
  if (buttons.length === 0)
    return "";
  return `
        <div class="buttons">
        ${buttons.map((b2) => getButtonHtml(b2)).join("\n")}
        </div>`;
}
function setAttribute(element, attr, value) {
  if (value)
    element.setAttribute(attr, value);
}
function showDialog(options) {
  return new Promise((res) => {
    var _a, _b, _c;
    const element = document.createElement("div");
    setAttribute(element, "data-testid", options.dataTestId);
    const shadow = element.attachShadow({ mode: "open" });
    const style = document.createElement("style");
    shadow.appendChild(style);
    style.innerHTML = stylesCss;
    const prompt = document.createElement("dialog");
    setAttribute(prompt, "aria-label", (_a = options.titleText) !== null && _a !== void 0 ? _a : options.title);
    setAttribute(prompt, "lang", options.lang);
    setAttribute(prompt, "dir", "auto");
    shadow.appendChild(prompt);
    prompt.innerHTML = `
            ${getDismissButtonHtml({ key: "dismiss", text: (_b = options.dismissButtonText) !== null && _b !== void 0 ? _b : "Dismiss" })}
            ${getTitleHtml(options.title)}
            ${getBodyHtml(options.body)}
            ${getButtonsHtml((_c = options.buttons) !== null && _c !== void 0 ? _c : [])}
        `;
    const buttonsElements = Array.from(prompt.querySelectorAll("button"));
    merge(...buttonsElements.map((b2) => fromEvent(b2, "click").pipe(map(() => b2.dataset.key))), fromEvent(prompt, "cancel").pipe(map(() => "dismiss"))).pipe(take(1)).subscribe({ next: res, complete: () => element.remove() });
    options.container.appendChild(element);
    prompt.showModal();
  });
}

// node_modules/@snap/camera-kit/dist/common/hash.js
var computeHash = (str) => {
  let h1 = 3735928559;
  let h2 = 1103547991;
  for (let i = 0; i < str.length; i++) {
    const ch = str.charCodeAt(i);
    h1 = Math.imul(h1 ^ ch, 2654435761);
    h2 = Math.imul(h2 ^ ch, 1597334677);
  }
  h1 = Math.imul(h1 ^ h1 >>> 16, 2246822507) ^ Math.imul(h2 ^ h2 >>> 13, 3266489909);
  h2 = Math.imul(h2 ^ h2 >>> 16, 2246822507) ^ Math.imul(h1 ^ h1 >>> 13, 3266489909);
  return (4294967296 * (2097151 & h2) + (h1 >>> 0)).toString(16);
};

// node_modules/@snap/camera-kit/dist/legal/legalPrompt.js
var snapIcon = `
<svg xmlns="http://www.w3.org/2000/svg" role="img" viewBox="0 0 32 32" height="48px">
    <g>
        <path
            d="M 30.898 23.477 C 30.77 23.045 30.148 22.743 30.148 22.743 C 30.092 22.71 30.039 22.684 29.994 22.663 C 28.962 22.161 28.048 21.561 27.277 20.876 C 26.659 20.325 26.128 19.719 25.701 19.074 C 25.182 18.288 24.937 17.632 24.831 17.275 C 24.773 17.043 24.782 16.951 24.831 16.832 C 24.873 16.731 24.99 16.632 25.049 16.588 C 25.397 16.341 25.96 15.976 26.303 15.75 C 26.602 15.556 26.859 15.389 27.009 15.283 C 27.494 14.944 27.824 14.596 28.02 14.223 C 28.275 13.74 28.303 13.208 28.107 12.684 C 27.84 11.978 27.184 11.556 26.35 11.556 C 26.163 11.556 25.974 11.577 25.785 11.62 C 25.308 11.723 24.852 11.894 24.474 12.042 C 24.446 12.054 24.416 12.032 24.418 12.002 C 24.457 11.059 24.502 9.79 24.399 8.584 C 24.306 7.493 24.082 6.576 23.717 5.776 C 23.351 4.972 22.874 4.376 22.5 3.947 C 22.143 3.536 21.519 2.936 20.577 2.394 C 19.251 1.631 17.742 1.244 16.09 1.244 C 14.443 1.244 12.934 1.631 11.605 2.394 C 10.607 2.966 9.97 3.614 9.678 3.947 C 9.304 4.376 8.827 4.972 8.46 5.776 C 8.096 6.576 7.872 7.496 7.778 8.584 C 7.673 9.792 7.715 10.96 7.76 11.999 C 7.762 12.03 7.732 12.051 7.704 12.039 C 7.325 11.892 6.87 11.72 6.393 11.617 C 6.204 11.575 6.012 11.554 5.828 11.554 C 4.994 11.554 4.337 11.976 4.071 12.682 C 3.875 13.205 3.903 13.738 4.157 14.221 C 4.354 14.594 4.685 14.941 5.169 15.281 C 5.318 15.387 5.575 15.553 5.874 15.748 C 6.211 15.968 6.758 16.323 7.108 16.569 C 7.152 16.599 7.299 16.712 7.346 16.827 C 7.397 16.951 7.404 17.045 7.341 17.289 C 7.234 17.648 6.989 18.298 6.479 19.069 C 6.052 19.715 5.522 20.32 4.902 20.871 C 4.132 21.556 3.218 22.157 2.186 22.658 C 2.137 22.682 2.078 22.712 2.015 22.748 C 2.015 22.748 1.399 23.064 1.282 23.472 C 1.109 24.075 1.567 24.64 2.036 24.943 C 2.8 25.438 3.732 25.703 4.272 25.849 C 4.421 25.889 4.559 25.926 4.683 25.964 C 4.76 25.989 4.956 26.062 5.038 26.17 C 5.143 26.306 5.155 26.473 5.192 26.66 C 5.253 26.977 5.384 27.373 5.774 27.643 C 6.204 27.941 6.75 27.962 7.444 27.99 C 8.168 28.018 9.07 28.054 10.1 28.394 C 10.579 28.553 11.011 28.818 11.514 29.128 C 12.56 29.773 13.864 30.578 16.09 30.578 C 18.318 30.578 19.629 29.768 20.685 29.119 C 21.183 28.811 21.612 28.546 22.08 28.391 C 23.11 28.049 24.011 28.014 24.735 27.988 C 25.427 27.962 25.974 27.941 26.404 27.641 C 26.822 27.35 26.943 26.918 26.997 26.59 C 27.027 26.428 27.046 26.285 27.14 26.165 C 27.219 26.064 27.399 25.992 27.483 25.964 C 27.609 25.924 27.751 25.886 27.906 25.844 C 28.445 25.698 29.123 25.527 29.945 25.061 C 30.933 24.511 31.001 23.82 30.898 23.477"
            fill="#ffffff"
            stroke="#00000000"
            stroke-width="1"
        />
    </g>
    <g>
        <path
            d="M 29.56 24.299 C 28.21 25.045 27.312 24.965 26.613 25.414 C 26.021 25.795 26.37 26.618 25.939 26.915 C 25.411 27.279 23.843 26.889 21.822 27.555 C 20.155 28.107 19.09 29.689 16.089 29.689 C 13.081 29.689 12.047 28.114 10.357 27.555 C 8.335 26.889 6.768 27.279 6.24 26.915 C 5.809 26.618 6.16 25.795 5.566 25.414 C 4.869 24.965 3.969 25.045 2.619 24.299 C 1.758 23.825 2.247 23.53 2.532 23.393 C 7.426 21.027 8.204 17.372 8.24 17.096 C 8.282 16.769 8.328 16.509 7.966 16.175 C 7.615 15.853 6.066 14.895 5.636 14.593 C 4.925 14.098 4.612 13.6 4.841 12.99 C 5 12.569 5.395 12.41 5.812 12.41 C 5.94 12.41 6.071 12.426 6.2 12.452 C 6.981 12.623 7.741 13.013 8.179 13.118 C 8.24 13.132 8.293 13.139 8.34 13.139 C 8.574 13.139 8.656 13.022 8.639 12.754 C 8.59 11.9 8.469 10.234 8.602 8.677 C 8.787 6.536 9.477 5.476 10.298 4.538 C 10.693 4.087 12.543 2.133 16.082 2.133 C 19.633 2.133 21.474 4.087 21.867 4.538 C 22.688 5.478 23.378 6.536 23.563 8.677 C 23.698 10.234 23.581 11.898 23.525 12.754 C 23.506 13.034 23.591 13.139 23.825 13.139 C 23.872 13.139 23.925 13.132 23.986 13.118 C 24.426 13.013 25.184 12.62 25.965 12.452 C 26.091 12.424 26.222 12.41 26.353 12.41 C 26.77 12.41 27.165 12.569 27.324 12.99 C 27.555 13.6 27.242 14.095 26.529 14.593 C 26.098 14.892 24.547 15.85 24.199 16.175 C 23.836 16.509 23.883 16.767 23.925 17.096 C 23.96 17.372 24.739 21.025 29.633 23.393 C 29.932 23.53 30.421 23.825 29.56 24.299 M 31.709 23.12 C 31.489 22.523 31.07 22.203 30.594 21.939 C 30.505 21.887 30.423 21.845 30.355 21.812 C 30.212 21.74 30.067 21.667 29.922 21.592 C 28.435 20.806 27.275 19.812 26.469 18.635 C 26.198 18.238 26.008 17.88 25.877 17.587 C 25.809 17.391 25.811 17.281 25.86 17.178 C 25.898 17.101 25.996 17.019 26.05 16.979 C 26.305 16.811 26.57 16.64 26.748 16.525 C 27.067 16.319 27.317 16.156 27.481 16.043 C 28.093 15.617 28.519 15.164 28.786 14.658 C 29.163 13.945 29.21 13.131 28.919 12.363 C 28.517 11.301 27.509 10.642 26.291 10.642 C 26.038 10.642 25.783 10.67 25.527 10.726 C 25.46 10.74 25.394 10.756 25.328 10.773 C 25.34 10.05 25.324 9.278 25.258 8.524 C 25.029 5.872 24.099 4.48 23.129 3.371 C 22.724 2.908 22.021 2.232 20.964 1.628 C 19.491 0.781 17.821 0.356 16 0.356 C 14.185 0.356 12.518 0.781 11.044 1.623 C 9.983 2.229 9.278 2.905 8.875 3.366 C 7.905 4.475 6.975 5.867 6.746 8.52 C 6.68 9.273 6.663 10.045 6.675 10.768 C 6.61 10.752 6.544 10.735 6.476 10.721 C 6.221 10.665 5.965 10.637 5.713 10.637 C 4.494 10.637 3.487 11.297 3.084 12.359 C 2.794 13.126 2.841 13.94 3.218 14.654 C 3.485 15.159 3.911 15.613 4.522 16.039 C 4.686 16.153 4.937 16.314 5.256 16.52 C 5.427 16.633 5.68 16.794 5.926 16.958 C 5.963 16.984 6.097 17.082 6.141 17.173 C 6.193 17.279 6.195 17.393 6.118 17.604 C 5.987 17.891 5.801 18.242 5.535 18.631 C 4.747 19.782 3.62 20.757 2.18 21.536 C 1.419 21.941 0.54 22.355 0.29 23.118 C 0.039 23.88 0.203 24.582 0.842 25.239 C 1.053 25.466 1.318 25.665 1.653 25.85 C 2.438 26.283 3.105 26.496 3.63 26.641 C 3.721 26.669 3.937 26.736 4.031 26.819 C 4.265 27.022 4.23 27.331 4.543 27.78 C 4.731 28.061 4.949 28.25 5.129 28.374 C 5.783 28.826 6.516 28.854 7.294 28.881 C 7.997 28.908 8.793 28.94 9.702 29.24 C 10.079 29.364 10.47 29.605 10.922 29.883 C 12.011 30.552 13.501 31.467 15.998 31.467 C 18.493 31.467 19.995 30.547 21.091 29.876 C 21.541 29.6 21.93 29.361 22.297 29.242 C 23.206 28.942 24.003 28.912 24.706 28.884 C 25.483 28.854 26.216 28.826 26.87 28.377 C 27.076 28.234 27.331 28.004 27.535 27.651 C 27.76 27.272 27.753 27.003 27.964 26.821 C 28.05 26.746 28.238 26.68 28.338 26.65 C 28.868 26.505 29.545 26.292 30.344 25.852 C 30.697 25.658 30.976 25.443 31.192 25.2 C 31.194 25.197 31.196 25.192 31.199 25.19 C 31.805 24.544 31.955 23.787 31.709 23.12"
            fill="#000000"
            stroke="#00000000"
            stroke-width="1"
        />
    </g>
</svg>`;
function showTosDialog(title, titleText, body) {
  return __awaiter(this, void 0, void 0, function* () {
    const result = yield showDialog({
      container: document.body,
      dataTestId: "tos-dialog",
      lang: supportedLocale,
      title,
      titleText,
      body,
      dismissButtonText: localizedString("legalPromptReject"),
      buttons: [
        {
          text: localizedString("legalPromptAccept"),
          key: "accept"
        }
      ]
    });
    return result === "accept";
  });
}
function showAdultOrChildDialog() {
  return showDialog({
    container: document.body,
    dataTestId: "adult-or-child-dialog",
    lang: supportedLocale,
    title: localizedString("legalPromptVariantGAdultOrChild"),
    buttons: [
      {
        text: localizedString("legalPromptVariantGAdult"),
        key: "adult"
      },
      {
        text: localizedString("legalPromptVariantGChild"),
        key: "child"
      }
    ]
  });
}
function showFindGuardianDialog() {
  return showDialog({
    container: document.body,
    dataTestId: "find-guardian-dialog",
    lang: supportedLocale,
    title: localizedString("legalPromptVariantGFindYourParent"),
    buttons: [
      {
        text: localizedString("legalPromptVariantGIAmGuardian"),
        key: "guardian"
      },
      {
        text: localizedString("legalPromptVariantGCancel"),
        key: "cancel",
        isSecondary: true
      }
    ]
  });
}
var legalPromptFactory = Injectable("legalPrompt", () => {
  return function legalPrompt(privacyPolicy, termsOfService, learnMore, childrenProtectionActRestricted) {
    const legalMessage = childrenProtectionActRestricted ? localizedString("legalPromptVariantGMessage") : localizedString("legalPromptMessage")({
      privacyPolicyUrl: privacyPolicy.webUrl,
      termsOfServiceUrl: termsOfService.webUrl,
      learnMoreUrl: learnMore.webUrl
    });
    const legalTitleText = localizedString("legalPromptTermsOfService");
    const legalTitle = childrenProtectionActRestricted ? legalTitleText : snapIcon;
    return {
      contentHash: computeHash(legalMessage),
      show() {
        return __awaiter(this, void 0, void 0, function* () {
          if (!childrenProtectionActRestricted) {
            return showTosDialog(legalTitle, legalTitleText, legalMessage);
          }
          while (true) {
            const adultOrChild = yield showAdultOrChildDialog();
            switch (adultOrChild) {
              case "child": {
                const findGuardian = yield showFindGuardianDialog();
                switch (findGuardian) {
                  case "cancel":
                    continue;
                  case "guardian":
                    return showTosDialog(legalTitle, legalTitleText, legalMessage);
                  case "dismiss":
                    return false;
                  default:
                    assertUnreachable(findGuardian);
                }
              }
              case "adult":
                return showTosDialog(legalTitle, legalTitleText, legalMessage);
              case "dismiss":
                return false;
              default:
                assertUnreachable(adultOrChild);
            }
          }
        });
      }
    };
  };
});

// node_modules/@snap/camera-kit/dist/legal/legalState.js
var logger11 = getLogger("LegalState");
var tosContentHashExpiry = 12 * 60 * 60;
var tosContentHashKey = "lastAcceptedTosContentHash";
var createLegalState = () => {
  const states = defineStates(defineState("unknown")(), defineState("accepted")(), defineState("rejected")());
  const actions = defineActions(defineAction("requestLegalPrompt")(), defineAction("accept")(), defineAction("reject")());
  return new StateMachine(actions, states, states.unknown(), (actions2) => {
    return merge(actions2.pipe(inStates("unknown"), forActions("accept"), map(() => states.accepted())), actions2.pipe(inStates("unknown"), forActions("reject"), map(() => states.rejected())), actions2.pipe(inStates("rejected"), forActions("requestLegalPrompt"), map(() => states.unknown())));
  });
};
var defaultLegalDocumentDate = /* @__PURE__ */ new Date("2021-09-30T00:00:00+00:00");
var defaultLegalPrompt = LegalPrompt.fromPartial({
  documents: [
    LegalDocument.fromPartial({
      type: LegalDocument_Type.PRIVACY_POLICY,
      webUrl: "https://values.snap.com/privacy/privacy-policy",
      version: "1",
      timestamp: defaultLegalDocumentDate
    }),
    LegalDocument.fromPartial({
      type: LegalDocument_Type.TERMS_OF_SERVICE,
      webUrl: "https://snap.com/terms",
      version: "1",
      timestamp: defaultLegalDocumentDate
    }),
    LegalDocument.fromPartial({
      type: LegalDocument_Type.LEARN_MORE,
      webUrl: "https://support.snapchat.com/article/camera-information-use",
      version: "1",
      timestamp: defaultLegalDocumentDate
    })
  ],
  disabled: true
});
var defaultInitConfig = GetInitializationConfigResponse.fromPartial({});
var hasAnyValue = (c2) => {
  var _a, _b;
  return ((_b = (_a = c2.value) === null || _a === void 0 ? void 0 : _a.anyValue) === null || _b === void 0 ? void 0 : _b.value) instanceof Uint8Array;
};
var getDocumentOrDefault = (documents) => (type) => {
  var _a;
  return (_a = documents.find((d2) => d2.type === type)) !== null && _a !== void 0 ? _a : defaultLegalPrompt.documents.find((d2) => d2.type === type);
};
var legalStateFactory = Injectable("legalState", [remoteConfigurationFactory.token, legalPromptFactory.token], (remoteConfig, legalPrompt) => {
  const persistance = new ExpiringPersistence(() => tosContentHashExpiry, new IndexedDBPersistence({ databaseName: "Legal" }));
  const getLastAcceptedTosContentHash = () => from(persistance.retrieve(tosContentHashKey).catch((error) => logger11.warn(error)));
  const setLastAcceptedTosContentHash = (hash) => persistance.store(tosContentHashKey, hash).catch((error) => logger11.warn(error));
  const legalState = createLegalState();
  legalState.events.pipe(inStates("unknown"), forActions("requestLegalPrompt"), switchMap(() => forkJoin({
    cofConfig: remoteConfig.get("CAMERA_KIT_LEGAL_PROMPT").pipe(map((configResults) => {
      const config2 = configResults.find(hasAnyValue);
      if (!config2)
        return defaultLegalPrompt;
      return LegalPrompt.decode(config2.value.anyValue.value);
    }), catchError((error) => {
      logger11.error(error);
      return of(defaultLegalPrompt);
    })),
    initConfig: remoteConfig.getInitializationConfig().pipe(catchError((error) => {
      logger11.error(error);
      return of(defaultInitConfig);
    }))
  })), switchMap(({ cofConfig, initConfig }) => {
    var _a;
    if ((_a = initConfig.legalPrompt) === null || _a === void 0 ? void 0 : _a.disabled) {
      return of(legalState.actions.accept("disabled"));
    }
    if (cofConfig.disabled) {
      return of(legalState.actions.accept("disabled"));
    }
    const documentOfType = getDocumentOrDefault(cofConfig.documents);
    const prompt = legalPrompt(documentOfType(LegalDocument_Type.PRIVACY_POLICY), documentOfType(LegalDocument_Type.TERMS_OF_SERVICE), documentOfType(LegalDocument_Type.LEARN_MORE), initConfig.childrenProtectionActRestricted);
    return getLastAcceptedTosContentHash().pipe(switchMap((lastAcceptedTosContentHash) => {
      if (prompt.contentHash === lastAcceptedTosContentHash)
        return of(true);
      return prompt.show();
    }), map((didAccept) => {
      if (!didAccept)
        return legalState.actions.reject(prompt.contentHash);
      setLastAcceptedTosContentHash(prompt.contentHash);
      return legalState.actions.accept(prompt.contentHash);
    }));
  }), dispatch(legalState)).subscribe({
    error: logger11.error
  });
  return legalState;
});

// node_modules/@snap/camera-kit/dist/observable-operators/unsubscribed.js
function unsubscribed(callback) {
  return (source) => defer(() => {
    let completedOrErrored = false;
    return source.pipe(tap({
      complete: () => completedOrErrored = true,
      error: () => completedOrErrored = true
    }), finalize(() => {
      if (completedOrErrored)
        return;
      callback();
    }));
  });
}

// node_modules/@snap/camera-kit/dist/lens/fetchWatermarkLens.js
var logger12 = getLogger("fetchWatermarkLens");
var watermarksLensGroup = "watermarks";
var fetchWatermarkLens = Injectable("fetchWatermarkLens", [remoteConfigurationFactory.token, lensRepositoryFactory.token], (remoteConfiguration, lensRepository) => {
  remoteConfiguration.getInitializationConfig().pipe(take(1)).subscribe({
    next: (config2) => __awaiter(void 0, void 0, void 0, function* () {
      if (config2.watermarkEnabled) {
        const lens = yield lensRepository.loadLens("", watermarksLensGroup);
        yield lensRepository.cacheLensContent([lens]);
      }
    }),
    error: logger12.error
  });
});

// node_modules/@snap/camera-kit/dist/session/lensState.js
var logger13 = getLogger("LensState");
var createLensState = () => {
  const actions = defineActions(defineAction("applyLens")(), defineAction("downloadComplete")(), defineAction("turnedOn")(), defineAction("resourcesLoaded")(), defineAction("firstFrameProcessed")(), defineAction("applyLensComplete")(), defineAction("applyLensFailed")(), defineAction("applyLensAborted")(), defineAction("removeLens")(), defineAction("turnedOff")(), defineAction("removeLensComplete")(), defineAction("removeLensFailed")());
  const states = defineStates(defineState("noLensApplied")(), defineState("applyingLens")(), defineState("lensApplied")());
  return new StateMachine(actions, states, states.noLensApplied(), (events) => merge(events.pipe(inStates("noLensApplied", "applyingLens", "lensApplied"), forActions("applyLens"), map(([a2]) => states.applyingLens(a2.data.lens))), events.pipe(inStates("applyingLens"), forActions("applyLensComplete"), map(([a2]) => states.lensApplied(a2.data))), events.pipe(inStates("applyingLens"), forActions("applyLensFailed"), map(() => states.noLensApplied())), events.pipe(inStates("lensApplied"), forActions("removeLensComplete"), map(() => states.noLensApplied()))));
};
var lensStateFactory = Injectable("lensState", [
  lensCoreFactory.token,
  lensRepositoryFactory.token,
  lensAssetRepositoryFactory.token,
  lensPersistenceStoreFactory.token,
  legalStateFactory.token,
  metricsClientFactory.token,
  remoteConfigurationFactory.token
], (lensCore, lensRepository, lensAssetRepository, lensPersistence, legalState, metrics, remoteConfig) => {
  const lensState = createLensState();
  let firstLensApply = true;
  lensState.events.pipe(forActions("applyLens"), exhaustMap(([a2]) => of(legalState.actions.requestLegalPrompt()).pipe(dispatch(legalState), inStates("accepted", "rejected"), take(1), map(([, { name }]) => {
    if (name === "accepted")
      return a2;
    return lensState.actions.applyLensFailed({
      error: legalError(`Failed to apply lens ${a2.data.lens.id}. Required legal terms were not accepted.`),
      lens: a2.data.lens
    });
  }))), switchMap((a2) => {
    if (a2.name === "applyLensFailed")
      return of(a2);
    const { lens } = a2.data;
    const dispatch2 = (action) => {
      lensState.dispatch(action, lens);
    };
    const applyTimer = new Timer("lens").mark("apply", { first: `${firstLensApply}` });
    firstLensApply = false;
    return forkJoin({
      watermarkInput: remoteConfig.getInitializationConfig().pipe(mergeMap((config2) => {
        if (!config2.watermarkEnabled)
          return of(void 0);
        return from(lensRepository.loadLens("", watermarksLensGroup)).pipe(mergeMap((watermark) => from(lensRepository.getLensContent(watermark)).pipe(map(({ lensBuffer, lensChecksum }) => {
          return {
            lensId: watermark.id,
            lensDataBuffer: lensBuffer.slice(0),
            lensChecksum,
            launchData: new ArrayBuffer(0)
          };
        }))));
      })),
      lensInput: of(a2.data).pipe(mergeMap(({ lens: lens2, launchData }) => {
        return from(lensPersistence.retrieve(lens2.id).catch(() => void 0)).pipe(map((persistentStore) => ({ lens: lens2, launchData, persistentStore })));
      }), map(({ lens: lens2, launchData, persistentStore }) => {
        const lensDetails = lensRepository.getLensMetadata(lens2.id);
        if (!lensDetails) {
          throw new Error(`Cannot apply lens ${lens2.id}. It has not been loaded by the Lens repository. Use CameraKit.lensRepository.loadLens (or loadLensGroups) to load lens metadata before calling CameraKitSession.applyLens.`);
        }
        const { content } = lensDetails;
        if (!content) {
          throw new Error(`Cannot apply lens ${lens2.id}. Metadata retrieved for this lens does not include the lens content URL.`);
        }
        return {
          lens: lens2,
          launchData: encodeLensLaunchData(launchData !== null && launchData !== void 0 ? launchData : {}, persistentStore !== null && persistentStore !== void 0 ? persistentStore : new ArrayBuffer(0)),
          content
        };
      }), mergeMap(({ lens: lens2, launchData, content }) => {
        const networkTimer = applyTimer.mark("network");
        return from(Promise.all([
          lensRepository.getLensContent(lens2).finally(() => networkTimer.measure("lens")),
          content.assetManifest.length > 0 ? lensAssetRepository.cacheAssets(content.assetManifest, lens2).finally(() => networkTimer.measure("assets")) : Promise.resolve()
        ])).pipe(tap(() => {
          networkTimer.measure();
          lensState.dispatch("downloadComplete", lens2);
        }), map(([{ lensBuffer, lensChecksum }]) => {
          const lensDataBuffer = lensBuffer.slice(0);
          return { lensId: lens2.id, lensDataBuffer, lensChecksum, launchData };
        }));
      }))
    }).pipe(takeUntil(lensState.events.pipe(forActions("removeLens"))), mergeMap(({ lensInput, watermarkInput }) => new Observable((subscriber) => {
      const coreTimer = applyTimer.mark("core");
      lensCore.replaceLenses({
        lenses: [
          Object.assign(Object.assign({}, lensInput), { onTurnOn: () => dispatch2("turnedOn"), onResourcesLoaded: () => dispatch2("resourcesLoaded"), onFirstFrameProcessed: () => {
            coreTimer.measure("first-frame");
            applyTimer.measure("success");
            applyTimer.stopAndReport(metrics);
            dispatch2("firstFrameProcessed");
          }, onTurnOff: () => dispatch2("turnedOff") }),
          ...watermarkInput ? [watermarkInput] : []
        ]
      }).then(() => {
        coreTimer.measure("success");
        subscriber.next(lensState.actions.applyLensComplete(lens));
        subscriber.complete();
      }).catch((lensCoreError) => {
        coreTimer.measure("failure");
        applyTimer.measure("failure");
        applyTimer.stopAndReport(metrics);
        const message = `Failed to apply lens ${lensInput.lensId}.`;
        const error = /validation failed/.test(lensCoreError.message) ? lensContentValidationError(message, lensCoreError) : lensError(message, lensCoreError);
        subscriber.next(lensState.actions.applyLensFailed({ error, lens }));
        subscriber.complete();
      });
    })), catchError((error) => {
      applyTimer.measure("failure");
      applyTimer.stopAndReport(metrics);
      return of(lensState.actions.applyLensFailed({ error, lens }));
    }), unsubscribed(() => {
      applyTimer.measure("abort");
      applyTimer.stopAndReport(metrics);
    }));
  }), dispatch(lensState)).subscribe({
    error: logger13.error
  });
  lensState.events.pipe(inStates("lensApplied", "noLensApplied"), forActions("removeLens"), mergeMap(() => new Observable((subscriber) => {
    lensCore.clearAllLenses().then(() => {
      subscriber.next(lensState.actions.removeLensComplete());
      subscriber.complete();
    }).catch((lensCoreError) => {
      const error = new Error("Failed to remove lenses.", { cause: lensCoreError });
      subscriber.next(lensState.actions.removeLensFailed(error));
      subscriber.complete();
    });
  })), dispatch(lensState)).subscribe({
    error: logger13.error
  });
  lensState.events.pipe(inStates("applyingLens"), forActions("removeLens"), switchMap(([a2]) => lensState.events.pipe(inStates("lensApplied"), takeUntil(lensState.events.pipe(forActions("applyLens"))), map(() => a2))), dispatch(lensState)).subscribe({
    error: logger13.error
  });
  lensState.events.subscribe(([a2, s2]) => {
    const data = extractLoggableData(a2);
    logger13.debug(`Action: "${a2.name}", state: "${s2.name}"${data ? ", data: " + JSON.stringify(data) : ""}`);
  });
  return lensState;
});
function extractLoggableData(action) {
  switch (action.name) {
    case "applyLens":
      return { lensId: action.data.lens.id };
    case "applyLensFailed":
      return { lensId: action.data.lens.id, error: action.data.error.message };
    case "downloadComplete":
    case "turnedOn":
    case "resourcesLoaded":
    case "firstFrameProcessed":
    case "applyLensComplete":
    case "applyLensAborted":
    case "turnedOff":
      return { lensId: action.data.id };
    case "removeLens":
    case "removeLensComplete":
      return void 0;
    case "removeLensFailed":
      return { error: action.data.message };
    default:
      assertUnreachable(action);
  }
}

// node_modules/@snap/camera-kit/dist/session/sessionState.js
var createSessionState = () => {
  const actions = defineActions(defineAction("suspend")(), defineAction("resume")(), defineAction("destroy")());
  const states = defineStates(defineState("inactive")(), defineState("active")(), defineState("destroyed")());
  return new StateMachine(actions, states, defineState("inactive")()(), (events) => {
    return merge(events.pipe(forActions("resume"), map(([a2]) => states.active(a2.data))), events.pipe(forActions("suspend"), map(() => states.inactive())), events.pipe(forActions("destroy"), map(() => states.destroyed())));
  });
};
var sessionStateFactory = Injectable("sessionState", () => createSessionState());

// node_modules/@snap/camera-kit/dist/session/LensKeyboard.js
var LensKeyboard = class {
  constructor(lensState) {
    this.lensState = lensState;
    this.active = false;
    this.element = document.createElement("textarea");
    this.element.addEventListener("keypress", (event) => {
      if (event.code === "Enter" && !event.shiftKey) {
        event.preventDefault();
        this.handleReply(this.element.value);
      }
    });
    this.events = new TypedEventTarget();
    this.handleReply = () => {
    };
    this.uriHandler = {
      uri: "app://textInput/requestKeyboard",
      handleRequest: (_request, reply) => {
        this.element.autofocus = true;
        this.handleReply = (text) => {
          const opt = {
            text,
            start: text.length,
            end: text.length,
            done: true,
            shouldNotify: true
          };
          const output = new TextEncoder().encode(JSON.stringify(opt));
          reply({
            code: 200,
            description: "",
            contentType: "application/json",
            data: output
          });
        };
        this.active = true;
        this.updateStatus();
        this.element.focus();
      }
    };
    lensState.events.pipe(forActions("turnedOff")).subscribe(() => {
      this.dismiss();
    });
  }
  dismiss() {
    if (this.active) {
      this.active = false;
      this.element.value = "";
      this.updateStatus();
    }
  }
  getElement() {
    return this.element;
  }
  sendInputToLens(text) {
    this.element.value = text;
    this.handleReply(text);
  }
  addEventListener(type, callback, options) {
    this.events.addEventListener(type, callback, options);
  }
  removeEventListener(type, callback) {
    this.events.removeEventListener(type, callback);
  }
  toPublicInterface() {
    return {
      addEventListener: this.addEventListener.bind(this),
      removeEventListener: this.removeEventListener.bind(this),
      getElement: this.getElement.bind(this),
      sendInputToLens: this.sendInputToLens.bind(this),
      dismiss: this.dismiss.bind(this)
    };
  }
  updateStatus() {
    const state = this.lensState.getState();
    if (isState(state, "noLensApplied"))
      return;
    this.events.dispatchEvent(new TypedCustomEvent("active", {
      element: this.element,
      active: this.active,
      lens: state.data
    }));
  }
};
var lensKeyboardFactory = Injectable("lensKeyboard", [lensStateFactory.token], (lensState) => new LensKeyboard(lensState));

// node_modules/@snap/camera-kit/dist/session/CameraKitSessionEvents.js
var isReachable = (_) => false;
function isPublicLensError(value) {
  if (!(value instanceof Error))
    return false;
  const maybeSessionErrorName = value.name;
  switch (maybeSessionErrorName) {
    case "LensAbortError":
    case "LensExecutionError":
    case "LensImagePickerError":
      return true;
    default:
      return isReachable(maybeSessionErrorName);
  }
}

// node_modules/@snap/camera-kit/dist/session/CameraKitSession.js
var logger14 = getLogger("CameraKitSession");
function isAllowedSource(value) {
  return isCameraKitSource(value) || isMediaStream(value) || isHTMLVideoElement(value);
}
function isMediaStream(value) {
  return value instanceof MediaStream;
}
function isHTMLVideoElement(value) {
  return value instanceof HTMLVideoElement;
}
function isRenderTargetOrUndefined(value) {
  return isUndefined(value) || value === "live" || value === "capture";
}
var CameraKitSession2 = (() => {
  var _a;
  let _instanceExtraInitializers = [];
  let _applyLens_decorators;
  let _removeLens_decorators;
  let _play_decorators;
  let _pause_decorators;
  let _mute_decorators;
  let _unmute_decorators;
  let _setSource_decorators;
  let _setFPSLimit_decorators;
  let _destroy_decorators;
  return _a = class CameraKitSession {
    constructor(keyboard, lensCore, sessionState, lensState, logEntries, pageVisibility) {
      this.keyboard = (__runInitializers(this, _instanceExtraInitializers), keyboard);
      this.lensCore = lensCore;
      this.sessionState = sessionState;
      this.lensState = lensState;
      this.events = new TypedEventTarget();
      const outputs = this.lensCore.getOutputCanvases();
      this.output = {
        live: outputs[this.lensCore.CanvasType.Preview.value],
        capture: outputs[this.lensCore.CanvasType.Capture.value]
      };
      this.playing = {
        live: false,
        capture: false
      };
      this.metrics = new LensPerformanceMetrics(this.lensCore);
      const removeOnHidden = pageVisibility.onPageHidden(() => this.sessionState.dispatch("suspend", this));
      const removeOnVisible = pageVisibility.onPageVisible(() => this.sessionState.dispatch("resume", this));
      this.removePageVisibilityHandlers = () => {
        removeOnHidden();
        removeOnVisible();
      };
      this.subscriptions = [
        lensCore.errors.pipe(filter((error) => error.name === "LensCoreAbortError")).subscribe(() => this.destroy()),
        lensCore.errors.pipe(filter((error) => error.name !== "LensCoreAbortError" && error.isFrameError)).subscribe(() => this.removeLens()),
        logEntries.pipe(filter((entry) => entry.level === "error"), map((entry) => entry.messages.find((e2) => e2 instanceof Error)), filter(isPublicLensError)).subscribe((error) => {
          const state = lensState.getState();
          if (!isState(state, "noLensApplied")) {
            this.events.dispatchEvent(new TypedCustomEvent("error", { error, lens: state.data }));
          } else {
            logger14.warn("Lens error occurred even though there is no active lens.", error);
          }
        })
      ];
    }
    applyLens(lens, launchData) {
      return __awaiter(this, void 0, void 0, function* () {
        const action = this.lensState.actions.applyLens({ lens, launchData });
        return firstValueFrom(of(action).pipe(dispatch(this.lensState), takeUntil(this.lensState.events.pipe(forActions("applyLens"), filter(([a2]) => a2 !== action))), tap(([a2]) => {
          if (isAction(a2, "applyLensFailed") && a2.data.lens.id === lens.id)
            throw a2.data.error;
        }), inStates("lensApplied"), map(() => true)), { defaultValue: false });
      });
    }
    removeLens() {
      return __awaiter(this, void 0, void 0, function* () {
        if (isState(this.lensState.getState(), "noLensApplied"))
          return true;
        return firstValueFrom(of(this.lensState.actions.removeLens()).pipe(dispatch(this.lensState), tap(([a2]) => {
          if (isAction(a2, "removeLensFailed"))
            throw a2.data;
        }), inStates("noLensApplied"), takeUntil(this.lensState.events.pipe(forActions("applyLens"))), map(() => true)), { defaultValue: false });
      });
    }
    play(target = "live") {
      return __awaiter(this, void 0, void 0, function* () {
        if (this.playing[target])
          return;
        this.playing[target] = true;
        const type = this.renderTargetToCanvasType(target);
        return this.lensCore.playCanvas({ type }).catch((error) => {
          this.playing[target] = false;
          throw error;
        });
      });
    }
    pause(target = "live") {
      return __awaiter(this, void 0, void 0, function* () {
        if (this.playing[target] === false)
          return;
        this.playing[target] = false;
        const type = this.renderTargetToCanvasType(target);
        return this.lensCore.pauseCanvas({ type }).catch((error) => {
          this.playing[target] = true;
          throw error;
        });
      });
    }
    mute(fade = false) {
      this.lensCore.setAllSoundsMuted({
        muted: true,
        fade
      });
    }
    unmute(fade = false) {
      this.lensCore.setAllSoundsMuted({
        muted: false,
        fade
      });
    }
    setSource(source, options = {}) {
      return __awaiter(this, void 0, void 0, function* () {
        yield this.safelyDetachSource();
        const cameraKitSource = isMediaStream(source) ? createMediaStreamSource(source, options) : isHTMLVideoElement(source) ? createVideoSource(source, options) : source;
        const priorPlayingState = this.playing;
        this.playing = {
          live: false,
          capture: false
        };
        yield cameraKitSource.attach(this.lensCore, (error) => {
          logger14.error(cameraKitSourceError("Error occurred during source attachment.", error));
        });
        this.source = cameraKitSource;
        if (priorPlayingState.live)
          yield this.play("live");
        if (priorPlayingState.capture)
          yield this.play("capture");
        return cameraKitSource;
      });
    }
    setFPSLimit(fpsLimit) {
      return __awaiter(this, void 0, void 0, function* () {
        const fps = fpsLimit < Number.POSITIVE_INFINITY ? fpsLimit : 0;
        return this.lensCore.setFPSLimit({ fps });
      });
    }
    destroy() {
      return __awaiter(this, void 0, void 0, function* () {
        try {
          yield this.lensCore.clearAllLenses();
          yield this.lensCore.teardown();
        } catch (error) {
          logger14.warn("An error occurred in LensCore during the session termination process.", error);
        }
        this.subscriptions.forEach((sub) => sub.unsubscribe());
        yield this.safelyDetachSource();
        this.removePageVisibilityHandlers();
        this.sessionState.dispatch("destroy", void 0);
      });
    }
    renderTargetToCanvasType(target) {
      return target === "capture" ? this.lensCore.CanvasType.Capture : this.lensCore.CanvasType.Preview;
    }
    safelyDetachSource() {
      return __awaiter(this, void 0, void 0, function* () {
        if (this.source) {
          try {
            yield this.source.detach((error) => {
              logger14.error(cameraKitSourceError("Error occurred during source detachment.", error));
            });
          } catch (error) {
            logger14.error(cameraKitSourceError(`Detaching prior source of type ${getTypeName(this.source)} failed.`, error));
          }
        }
      });
    }
  }, (() => {
    _applyLens_decorators = [validate(isLens, isLensLaunchDataOrUndefined), errorLoggingDecorator(logger14)];
    _removeLens_decorators = [errorLoggingDecorator(logger14)];
    _play_decorators = [validate(isRenderTargetOrUndefined), errorLoggingDecorator(logger14)];
    _pause_decorators = [validate(isRenderTargetOrUndefined), errorLoggingDecorator(logger14)];
    _mute_decorators = [errorLoggingDecorator(logger14)];
    _unmute_decorators = [errorLoggingDecorator(logger14)];
    _setSource_decorators = [validate(isAllowedSource, isPartialCameraKitDeviceOptionsOrUndefined), errorLoggingDecorator(logger14)];
    _setFPSLimit_decorators = [validate(isValidNumber), errorLoggingDecorator(logger14)];
    _destroy_decorators = [errorLoggingDecorator(logger14)];
    __esDecorate(_a, null, _applyLens_decorators, { kind: "method", name: "applyLens", static: false, private: false, access: { has: (obj) => "applyLens" in obj, get: (obj) => obj.applyLens } }, null, _instanceExtraInitializers);
    __esDecorate(_a, null, _removeLens_decorators, { kind: "method", name: "removeLens", static: false, private: false, access: { has: (obj) => "removeLens" in obj, get: (obj) => obj.removeLens } }, null, _instanceExtraInitializers);
    __esDecorate(_a, null, _play_decorators, { kind: "method", name: "play", static: false, private: false, access: { has: (obj) => "play" in obj, get: (obj) => obj.play } }, null, _instanceExtraInitializers);
    __esDecorate(_a, null, _pause_decorators, { kind: "method", name: "pause", static: false, private: false, access: { has: (obj) => "pause" in obj, get: (obj) => obj.pause } }, null, _instanceExtraInitializers);
    __esDecorate(_a, null, _mute_decorators, { kind: "method", name: "mute", static: false, private: false, access: { has: (obj) => "mute" in obj, get: (obj) => obj.mute } }, null, _instanceExtraInitializers);
    __esDecorate(_a, null, _unmute_decorators, { kind: "method", name: "unmute", static: false, private: false, access: { has: (obj) => "unmute" in obj, get: (obj) => obj.unmute } }, null, _instanceExtraInitializers);
    __esDecorate(_a, null, _setSource_decorators, { kind: "method", name: "setSource", static: false, private: false, access: { has: (obj) => "setSource" in obj, get: (obj) => obj.setSource } }, null, _instanceExtraInitializers);
    __esDecorate(_a, null, _setFPSLimit_decorators, { kind: "method", name: "setFPSLimit", static: false, private: false, access: { has: (obj) => "setFPSLimit" in obj, get: (obj) => obj.setFPSLimit } }, null, _instanceExtraInitializers);
    __esDecorate(_a, null, _destroy_decorators, { kind: "method", name: "destroy", static: false, private: false, access: { has: (obj) => "destroy" in obj, get: (obj) => obj.destroy } }, null, _instanceExtraInitializers);
  })(), _a;
})();
var cameraKitSessionFactory = Injectable("CameraKitSession", [
  lensCoreFactory.token,
  logEntriesFactory.token,
  lensKeyboardFactory.token,
  sessionStateFactory.token,
  lensStateFactory.token,
  pageVisibilityFactory.token
], (lensCore, logEntries, keyboard, sessionState, lensState, pageVisibility) => new CameraKitSession2(keyboard, lensCore, sessionState, lensState, logEntries, pageVisibility));

// node_modules/@snap/camera-kit/dist/lens/assets/LensAssetsProvider.js
var logger15 = getLogger("LensAssetProvider");
var maxConsecutiveErrors = 3;
var registerLensAssetsProvider = Injectable("registerLensAssetsProvider", [
  lensCoreFactory.token,
  lensRepositoryFactory.token,
  lensAssetRepositoryFactory.token,
  lensStateFactory.token
], (lensCore, lensRepository, lensAssetRepository, lensState) => {
  const consecutiveErrorsPerAsset = /* @__PURE__ */ new Map();
  lensCore.setRemoteAssetsProvider((assetDescriptor) => __awaiter(void 0, void 0, void 0, function* () {
    var _a, _b, _c, _d, _e;
    const { assetId, assetType, effectId } = assetDescriptor;
    try {
      if (((_a = consecutiveErrorsPerAsset.get(assetId)) !== null && _a !== void 0 ? _a : 0) > maxConsecutiveErrors) {
        throw new Error(`Maximum consecutive asset load errors reached for asset ${assetId}`);
      }
      const lensId = effectId !== null && effectId !== void 0 ? effectId : (_b = lensState.getState().data) === null || _b === void 0 ? void 0 : _b.id;
      const lens = lensId ? lensRepository.getLensMetadata(lensId) : void 0;
      yield lensAssetRepository.loadAsset({
        assetDescriptor,
        lens: lens && toPublicLens(lens),
        assetManifest: (_d = (_c = lens === null || lens === void 0 ? void 0 : lens.content) === null || _c === void 0 ? void 0 : _c.assetManifest) !== null && _d !== void 0 ? _d : [],
        lowPriority: false
      });
      consecutiveErrorsPerAsset.set(assetId, 0);
    } catch (error) {
      lensCore.provideRemoteAssetsResponse({
        assetId,
        assetType
      });
      const consecutiveErrors = ((_e = consecutiveErrorsPerAsset.get(assetId)) !== null && _e !== void 0 ? _e : 0) + 1;
      consecutiveErrorsPerAsset.set(assetId, consecutiveErrors);
      if (consecutiveErrors <= maxConsecutiveErrors) {
        logger15.error(lensAssetError(`Error occurred while handling lens asset ${assetId} request.`, error));
      } else {
        logger15.warn(`Maximum consecutive asset load errors reached for asset ${assetId}`);
      }
    }
  }));
});

// node_modules/@snap/camera-kit/dist/generated-proto/pb_schema/camera_kit/v3/features/remote_api_info.js
var import_long28 = __toESM(require_long());
var import_minimal29 = __toESM(require_minimal2());
function createBaseRemoteApiInfo() {
  return { apiSpecIds: [] };
}
var RemoteApiInfo = {
  encode(message, writer = import_minimal29.default.Writer.create()) {
    for (const v2 of message.apiSpecIds) {
      writer.uint32(10).string(v2);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal29.default.Reader ? input : new import_minimal29.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseRemoteApiInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.apiSpecIds.push(reader.string());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(object) {
    var _a;
    const message = createBaseRemoteApiInfo();
    message.apiSpecIds = ((_a = object.apiSpecIds) === null || _a === void 0 ? void 0 : _a.map((e2) => e2)) || [];
    return message;
  }
};
if (import_minimal29.default.util.Long !== import_long28.default) {
  import_minimal29.default.util.Long = import_long28.default;
  import_minimal29.default.configure();
}

// node_modules/@snap/camera-kit/dist/generated-proto/pb_schema/lenses/remote_api/remote_api_service.js
var import_long29 = __toESM(require_long());
var import_minimal30 = __toESM(require_minimal2());
var HttpRequestMethod;
(function(HttpRequestMethod2) {
  HttpRequestMethod2["HTTP_METHOD_UNSET"] = "HTTP_METHOD_UNSET";
  HttpRequestMethod2["HTTP_METHOD_GET"] = "HTTP_METHOD_GET";
  HttpRequestMethod2["HTTP_METHOD_POST"] = "HTTP_METHOD_POST";
  HttpRequestMethod2["HTTP_METHOD_PUT"] = "HTTP_METHOD_PUT";
  HttpRequestMethod2["HTTP_METHOD_DELETE"] = "HTTP_METHOD_DELETE";
  HttpRequestMethod2["HTTP_METHOD_PATCH"] = "HTTP_METHOD_PATCH";
  HttpRequestMethod2["UNRECOGNIZED"] = "UNRECOGNIZED";
})(HttpRequestMethod || (HttpRequestMethod = {}));
var ResponseCode;
(function(ResponseCode2) {
  ResponseCode2["RESPONSE_CODE_UNSET"] = "RESPONSE_CODE_UNSET";
  ResponseCode2["SUCCESS"] = "SUCCESS";
  ResponseCode2["REDIRECTED"] = "REDIRECTED";
  ResponseCode2["BAD_REQUEST"] = "BAD_REQUEST";
  ResponseCode2["ACCESS_DENIED"] = "ACCESS_DENIED";
  ResponseCode2["NOT_FOUND"] = "NOT_FOUND";
  ResponseCode2["TIMEOUT"] = "TIMEOUT";
  ResponseCode2["REQUEST_TOO_LARGE"] = "REQUEST_TOO_LARGE";
  ResponseCode2["SERVER_ERROR"] = "SERVER_ERROR";
  ResponseCode2["CANCELLED"] = "CANCELLED";
  ResponseCode2["PROXY_ERROR"] = "PROXY_ERROR";
  ResponseCode2["UNRECOGNIZED"] = "UNRECOGNIZED";
})(ResponseCode || (ResponseCode = {}));
function responseCodeToNumber(object) {
  switch (object) {
    case ResponseCode.RESPONSE_CODE_UNSET:
      return 0;
    case ResponseCode.SUCCESS:
      return 1;
    case ResponseCode.REDIRECTED:
      return 2;
    case ResponseCode.BAD_REQUEST:
      return 3;
    case ResponseCode.ACCESS_DENIED:
      return 4;
    case ResponseCode.NOT_FOUND:
      return 5;
    case ResponseCode.TIMEOUT:
      return 6;
    case ResponseCode.REQUEST_TOO_LARGE:
      return 7;
    case ResponseCode.SERVER_ERROR:
      return 8;
    case ResponseCode.CANCELLED:
      return 9;
    case ResponseCode.PROXY_ERROR:
      return 10;
    default:
      return 0;
  }
}
var GetOAuth2InfoResponse_GrantType;
(function(GetOAuth2InfoResponse_GrantType2) {
  GetOAuth2InfoResponse_GrantType2["GRANT_TYPE_UNSET"] = "GRANT_TYPE_UNSET";
  GetOAuth2InfoResponse_GrantType2["AUTHORIZATION_CODE"] = "AUTHORIZATION_CODE";
  GetOAuth2InfoResponse_GrantType2["AUTHORIZATION_CODE_WITH_PKCE"] = "AUTHORIZATION_CODE_WITH_PKCE";
  GetOAuth2InfoResponse_GrantType2["IMPLICIT"] = "IMPLICIT";
  GetOAuth2InfoResponse_GrantType2["CLIENT_CREDENTIALS"] = "CLIENT_CREDENTIALS";
  GetOAuth2InfoResponse_GrantType2["UNRECOGNIZED"] = "UNRECOGNIZED";
})(GetOAuth2InfoResponse_GrantType || (GetOAuth2InfoResponse_GrantType = {}));
var TokenExchangeError_TokenExchangeErrorType;
(function(TokenExchangeError_TokenExchangeErrorType2) {
  TokenExchangeError_TokenExchangeErrorType2["ERROR_TYPE_UNSET"] = "ERROR_TYPE_UNSET";
  TokenExchangeError_TokenExchangeErrorType2["INVALID_REQUEST"] = "INVALID_REQUEST";
  TokenExchangeError_TokenExchangeErrorType2["INVALID_CLIENT"] = "INVALID_CLIENT";
  TokenExchangeError_TokenExchangeErrorType2["INVALID_GRANT"] = "INVALID_GRANT";
  TokenExchangeError_TokenExchangeErrorType2["UNAUTHORIZED_CLIENT"] = "UNAUTHORIZED_CLIENT";
  TokenExchangeError_TokenExchangeErrorType2["UNSUPPORTED_GRANT_TYPE"] = "UNSUPPORTED_GRANT_TYPE";
  TokenExchangeError_TokenExchangeErrorType2["INVALID_SCOPE"] = "INVALID_SCOPE";
  TokenExchangeError_TokenExchangeErrorType2["UNRECOGNIZED"] = "UNRECOGNIZED";
})(TokenExchangeError_TokenExchangeErrorType || (TokenExchangeError_TokenExchangeErrorType = {}));
if (import_minimal30.default.util.Long !== import_long29.default) {
  import_minimal30.default.util.Long = import_long29.default;
  import_minimal30.default.configure();
}

// node_modules/@snap/camera-kit/dist/extensions/UriHandlers.js
var SEPARATOR = "://";
function extractSchemeAndRoute(uri) {
  const separatorIndex = uri.indexOf(SEPARATOR);
  const scheme = uri.slice(0, separatorIndex);
  const route = uri.slice(separatorIndex + SEPARATOR.length);
  return { scheme, route };
}
function isUri(value) {
  return isString(value) && value.includes(SEPARATOR);
}
function isUriHandler(value) {
  return isRecord(value) && (isUri(value.uri) || isArrayOfType(isUri, value.uri)) && isFunction(value.handleRequest) && (isUndefined(value.cancelRequest) || isFunction(value.cancelRequest));
}
function isUriHandlers(value) {
  return isArrayOfType(isUriHandler, value);
}
function isUriResponse(value) {
  return isRecord(value) && isNumber(value.code) && isString(value.description) && isString(value.contentType) && (isArrayBuffer(value.data) || isTypedArray(value.data)) && (isUndefined(value.metadata) || predicateRecordValues(isString)(value.metadata));
}
var uriHandlersFactory = Injectable("UriHandlers", () => {
  const uriHandlers = [];
  return uriHandlers;
});

// node_modules/@snap/camera-kit/dist/extensions/RemoteApiServices.js
var logger16 = getLogger("RemoteApiServices");
var uriResponseOkCode = 200;
var apiResponseStatusHeader = ":sc_lens_api_status";
var apiBinaryContentType = "application/octet-stream";
var remoteApiInfoProtobufTypeUrl = "type.googleapis.com/com.snap.camerakit.v3.features.RemoteApiInfo";
var remoteApiUploadImageSpecId = "af3f69c8-2e62-441f-8b1c-d3956f7b336c";
var statusToResponseCodeMap = {
  success: ResponseCode.SUCCESS,
  redirected: ResponseCode.REDIRECTED,
  badRequest: ResponseCode.BAD_REQUEST,
  accessDenied: ResponseCode.ACCESS_DENIED,
  notFound: ResponseCode.NOT_FOUND,
  timeout: ResponseCode.TIMEOUT,
  requestTooLarge: ResponseCode.REQUEST_TOO_LARGE,
  serverError: ResponseCode.SERVER_ERROR,
  cancelled: ResponseCode.CANCELLED,
  proxyError: ResponseCode.PROXY_ERROR
};
function callCancellationHandler(cancellationHandlers, ...keys) {
  var _a;
  for (const key of keys) {
    (_a = cancellationHandlers.get(key)) === null || _a === void 0 ? void 0 : _a();
    cancellationHandlers.delete(key);
  }
}
function handleLensApplicationEnd(lensRequestState, ...lensIds) {
  for (const lensId of lensIds) {
    const state = lensRequestState.get(lensId);
    if (state) {
      callCancellationHandler(state.cancellationHandlers, ...state.cancellationHandlers.keys());
      lensRequestState.delete(lensId);
    }
  }
}
var remoteApiServicesFactory = Injectable("remoteApiServices", () => {
  const remoteApiServices = [];
  return remoteApiServices;
});
function getRemoteApiUriHandler(registeredServices, sessionState, lensState, lensRepository, metrics) {
  const registeredServiceMap = /* @__PURE__ */ new Map();
  for (const service of registeredServices) {
    const existingServices = registeredServiceMap.get(service.apiSpecId) || [];
    registeredServiceMap.set(service.apiSpecId, [...existingServices, service]);
  }
  const uriRequests = new Subject();
  const uriCancelRequests = new Subject();
  const lensRequestState = /* @__PURE__ */ new Map();
  const lensTurnOffEvents = lensState.events.pipe(forActions("turnedOff"), tap(([action]) => handleLensApplicationEnd(lensRequestState, action.data.id)));
  const uriRequestEvents = uriRequests.pipe(map((uriRequest) => {
    var _a, _b;
    const lensId = uriRequest.lens.id;
    if (!lensRequestState.has(lensId)) {
      lensRequestState.set(lensId, {
        cancellationHandlers: /* @__PURE__ */ new Map(),
        supportedSpecIds: /* @__PURE__ */ new Set([
          ...((_b = (_a = lensRepository.getLensMetadata(lensId)) === null || _a === void 0 ? void 0 : _a.featureMetadata) !== null && _b !== void 0 ? _b : []).filter((feature) => feature.typeUrl === remoteApiInfoProtobufTypeUrl).flatMap((any) => RemoteApiInfo.decode(any.value).apiSpecIds),
          remoteApiUploadImageSpecId
        ])
      });
    }
    const requestState = lensRequestState.get(lensId);
    const { route } = extractSchemeAndRoute(uriRequest.request.uri);
    const [specId, endpointIdWithQuery] = route.split("/").slice(2);
    const [endpointId] = endpointIdWithQuery.split("?");
    return { uriRequest, specId, endpointId, requestState };
  }), filter(({ specId, requestState }) => requestState.supportedSpecIds.has(specId)), filter(({ specId }) => registeredServiceMap.has(specId)), map(({ uriRequest, specId, endpointId, requestState }) => {
    var _a;
    const dimensions = { specId };
    const reportSingleCount = (name) => {
      metrics.setOperationalMetrics(Count.count(joinMetricNames(["lens", "remote-api", name]), 1, dimensions));
    };
    reportSingleCount("requests");
    const remoteApiRequest = {
      apiSpecId: specId,
      body: uriRequest.request.data,
      endpointId,
      parameters: uriRequest.request.metadata
    };
    for (const service of (_a = registeredServiceMap.get(specId)) !== null && _a !== void 0 ? _a : []) {
      let requestHandler = void 0;
      try {
        requestHandler = service.getRequestHandler(remoteApiRequest, uriRequest.lens);
      } catch (error) {
        logger16.warn("Client's Remote API request handler factory threw an error.", error);
      }
      if (requestHandler) {
        reportSingleCount("handled-requests");
        let cancellationHandler = void 0;
        try {
          cancellationHandler = requestHandler((response) => {
            var _a2;
            reportSingleCount("responses");
            const responseCode = (_a2 = statusToResponseCodeMap[response.status]) !== null && _a2 !== void 0 ? _a2 : ResponseCode.UNRECOGNIZED;
            const uriResponse = {
              code: uriResponseOkCode,
              description: "",
              contentType: apiBinaryContentType,
              data: response.body,
              metadata: Object.assign(Object.assign({}, response.metadata), { [apiResponseStatusHeader]: responseCodeToNumber(responseCode).toString() })
            };
            uriRequest.reply(uriResponse);
          });
        } catch (error) {
          logger16.warn("Client's Remote API request handler threw an error.", error);
        }
        if (typeof cancellationHandler === "function") {
          requestState.cancellationHandlers.set(uriRequest.request.identifier, () => {
            try {
              cancellationHandler();
            } catch (error) {
              logger16.warn("Client's Remote API request cancellation handler threw an error.", error);
            }
          });
        }
        break;
      }
    }
  }));
  const uriCancelRequestEvents = uriCancelRequests.pipe(tap((uriRequest) => {
    var _a;
    const cancellationHandlers = (_a = lensRequestState.get(uriRequest.lens.id)) === null || _a === void 0 ? void 0 : _a.cancellationHandlers;
    if (cancellationHandlers) {
      callCancellationHandler(cancellationHandlers, uriRequest.request.requestId);
    }
  }));
  merge(lensTurnOffEvents, uriRequestEvents, uriCancelRequestEvents).pipe(catchError((error, sourcePipe) => {
    logger16.error(error);
    metrics.setOperationalMetrics(Count.count(joinMetricNames(["lens", "remote-api", "errors"]), 1));
    return sourcePipe;
  }), retry(), takeUntil(sessionState.events.pipe(forActions("destroy")))).subscribe({
    complete: () => handleLensApplicationEnd(lensRequestState, ...lensRequestState.keys())
  });
  return {
    uri: "app://remote-api/performApiRequest",
    handleRequest(request, reply, lens) {
      uriRequests.next({ request, reply, lens });
    },
    cancelRequest(request, lens) {
      uriCancelRequests.next({ request, lens });
    }
  };
}

// node_modules/@snap/camera-kit/dist/extensions/uriHandlersRegister.js
var logger17 = getLogger("uriHandlersRegister");
var registerUriHandlers = Injectable("registerUriHandlers", [
  lensCoreFactory.token,
  lensStateFactory.token,
  uriHandlersFactory.token,
  lensKeyboardFactory.token,
  remoteApiServicesFactory.token,
  lensRepositoryFactory.token,
  sessionStateFactory.token,
  metricsClientFactory.token
], (lensCore, lensState, userHandlers, lensKeyboard, remoteApiServices, lensRepository, sessionState, metrics) => {
  if (!isUriHandlers(userHandlers)) {
    throw new Error("Expected an array of UriHandler objects");
  }
  const allHandlers = userHandlers.concat(lensKeyboard.uriHandler, getRemoteApiUriHandler(remoteApiServices, sessionState, lensState, lensRepository, metrics));
  for (const { uri, handleRequest, cancelRequest } of allHandlers) {
    const uris = Array.isArray(uri) ? uri : [uri];
    for (const { scheme, route } of uris.map(extractSchemeAndRoute)) {
      lensCore.registerUriListener(scheme, route, {
        handleRequest: (request) => {
          const reply = (response) => {
            if (!isUriResponse(response)) {
              throw new Error("Expected UriResponse object");
            }
            lensCore.provideUriResponse(request.identifier, response);
          };
          const state = lensState.getState();
          if (isState(state, "noLensApplied")) {
            logger17.warn(`Got a URI request for ${request.uri}, but there is no active lens. The request will not be processed.`);
            return;
          }
          handleRequest(request, reply, state.data);
        },
        cancelRequest: (request) => {
          if (cancelRequest) {
            const state = lensState.getState();
            if (isState(state, "noLensApplied")) {
              logger17.warn(`Got a URI cancel request for ${request.uri}, but there is no active lens. The cancel request will not be processed.`);
              return;
            }
            cancelRequest(request, state.data);
          }
        }
      });
    }
  }
});

// node_modules/@snap/camera-kit/dist/metrics/reporters/reportGlobalException.js
var logMethods = entries(logLevelMap).map(([level]) => level);
var maxBufferedEntries = 15;
var contextSeparator = "\n\n----------------- Context -----------------\n\n";
var methodLength = logMethods.reduce((max2, method) => Math.max(max2, method.length), 0);
function getContextString(logEntries) {
  const result = [];
  for (const { entry, count: count2, lastTime } of logEntries) {
    const time = entry.time.toISOString();
    const method = entry.level.padStart(methodLength);
    const messages = entry.messages.map(prettyPrintMessage).join(" ");
    let dupSuffix = count2 > 1 ? ` (Repeated ${count2} times with the last occurrence at ${lastTime.toISOString()})` : "";
    result.push(`${time} [${entry.module}] ${method}: ${messages}${dupSuffix}`);
  }
  return result.join("\n");
}
function prettyPrintMessage(message) {
  if (message instanceof Error)
    return stringifyErrorMessage(message);
  if (message instanceof Date)
    return message.toISOString();
  return message + "";
}
function reportExceptionToBlizzard(logEntries, metricsEventTarget, metrics, lensState) {
  logEntries.pipe(scan(({ entries: entries2 }, newEntry) => {
    const lastEntry = entries2[entries2.length - 1];
    const isNewEntryRepeated = lastEntry && lastEntry.entry.messages.join() === newEntry.messages.join() && lastEntry.entry.level === newEntry.level;
    if (isNewEntryRepeated) {
      lastEntry.count += 1;
      lastEntry.lastTime = newEntry.time;
    } else {
      entries2.push({
        entry: newEntry,
        count: 1,
        lastTime: newEntry.time
      });
    }
    return {
      entries: entries2.slice(-maxBufferedEntries),
      recent: newEntry
    };
  }, { entries: [], recent: { time: /* @__PURE__ */ new Date(), module: "any", level: "debug", messages: [] } }), filter(({ recent }) => recent.level === "error"), map(({ entries: entries2, recent }) => ({
    context: entries2,
    error: recent.messages.find((e2) => e2 instanceof Error)
  })), filter(({ error }) => !!error)).subscribe(({ error, context: context2 }) => {
    const currentLensState = lensState === null || lensState === void 0 ? void 0 : lensState.getState();
    const lensId = currentLensState && !isState(currentLensState, "noLensApplied") ? currentLensState.data.id : "none";
    metricsEventTarget.dispatchEvent(new TypedCustomEvent("exception", {
      name: "exception",
      lensId,
      type: error.name,
      reason: `${stringifyError(error)}${contextSeparator}${getContextString(context2)}`
    }));
    metrics.setOperationalMetrics(Count.count("handled_exception", 1, { type: error.name }));
  });
}
var reportGlobalException = Injectable("reportGlobalException", [logEntriesFactory.token, metricsEventTargetFactory.token, metricsClientFactory.token], (logEntries, metricsEventTarget, metrics) => {
  const cancellationSubject = new Subject();
  reportExceptionToBlizzard(logEntries.pipe(takeUntil(cancellationSubject)), metricsEventTarget, metrics);
  return {
    attachLensContext: (lensState) => {
      cancellationSubject.next();
      reportExceptionToBlizzard(logEntries, metricsEventTarget, metrics, lensState);
    }
  };
});

// node_modules/@snap/camera-kit/dist/metrics/reporters/reportSessionException.js
var reportSessionException = Injectable("reportSessionException", [reportGlobalException.token, lensStateFactory.token], (globalExceptionReporter, lensState) => {
  globalExceptionReporter.attachLensContext(lensState);
});

// node_modules/@snap/camera-kit/dist/metrics/operational/Histogram.js
var Histogram = class _Histogram extends Metric {
  static level(name, level, dimensions = {}) {
    const histogram = new _Histogram(name, dimensions);
    histogram.add(level);
    return histogram;
  }
  constructor(name, dimensions = {}) {
    super(name, dimensions);
    this.name = name;
    this.levels = [];
  }
  add(level) {
    this.levels.push(level);
  }
  toOperationalMetric() {
    const timestamp2 = /* @__PURE__ */ new Date();
    const name = `${this.name}${serializeMetricDimensions(this.dimensions)}`;
    return this.levels.map((level) => ({
      name,
      timestamp: timestamp2,
      metric: { $case: "histogram", histogram: `${Math.ceil(level)}` }
    }));
  }
};

// node_modules/@snap/camera-kit/dist/metrics/reporters/reportBenchmarks.js
var reportableBenchmarks = ["gflops"];
var reportBenchmarks = Injectable("reportBenchmarks", [metricsEventTargetFactory.token, metricsClientFactory.token, configurationToken], (metricsEventTarget, metrics, config2) => __awaiter(void 0, void 0, void 0, function* () {
  if (config2.lensPerformance === void 0)
    return;
  const lensPerformance = yield config2.lensPerformance;
  const baseBenchmark = {
    name: "benchmarkComplete",
    performanceCluster: `${lensPerformance.cluster}`,
    webglRendererInfo: lensPerformance.webglRendererInfo
  };
  const dimensions = { performance_cluster: lensPerformance.cluster.toString() };
  for (const benchmark of lensPerformance.benchmarks) {
    if (!reportableBenchmarks.includes(benchmark.name))
      continue;
    const benchmarkComplete = Object.assign(Object.assign({}, baseBenchmark), { benchmarkName: benchmark.name, benchmarkValue: benchmark.value });
    metricsEventTarget.dispatchEvent(new TypedCustomEvent("benchmarkComplete", benchmarkComplete));
    metrics.setOperationalMetrics(Histogram.level(`benchmark.${benchmark.name}`, benchmark.value, dimensions));
  }
}));

// node_modules/@snap/camera-kit/dist/events/scan.js
var scan2 = (seedState) => (source, eventTypes, accumulator) => {
  let state = seedState;
  const sink = new TypedEventTarget();
  const listener = (event) => {
    state = accumulator(state, event);
    sink.dispatchEvent(new TypedCustomEvent("state", state));
  };
  let hasListener = false;
  sink.addEventListener = new Proxy(sink.addEventListener, {
    apply: (target, thisArg, args) => {
      if (hasListener)
        throw new Error("Cannot add another event listener. The TypedEventTarget returned by scan only supports a single listener, and one has already been added.");
      hasListener = true;
      eventTypes.forEach((eventType) => source.addEventListener(eventType, listener));
      target.apply(thisArg, args);
    }
  });
  sink.removeEventListener = new Proxy(sink.removeEventListener, {
    apply: (target, thisArg, args) => {
      eventTypes.forEach((eventType) => source.removeEventListener(eventType, listener));
      target.apply(thisArg, args);
    }
  });
  return sink;
};

// node_modules/@snap/camera-kit/dist/metrics/reporters/reportLensAndAssetDownload.js
var relevantRequestTypes = ["lens_content", "asset"];
var isLensOrAssetRequest = (value) => {
  const requestType = value["requestType"];
  return typeof requestType === "string" && relevantRequestTypes.includes(requestType);
};
var reportLensAndAssetDownload = Injectable("reportLensAndAssetDownload", [metricsEventTargetFactory.token, metricsClientFactory.token, requestStateEventTargetFactory.token], (metricsEventTarget, metrics, requestStateEventTarget) => {
  scan2({ name: "inProgress", inProgress: /* @__PURE__ */ new Map() })(requestStateEventTarget, ["started", "completed", "errored"], (state, event) => {
    var _a;
    const { inProgress } = state;
    const { dimensions, requestId: requestId2 } = event.detail;
    if (!isLensOrAssetRequest(dimensions))
      return state;
    switch (event.type) {
      case "started":
        const timer2 = event.detail.timer;
        inProgress.set(requestId2, { timer: timer2 });
        return { name: "inProgress", inProgress };
      case "completed":
        const completedRequest = inProgress.get(requestId2);
        if (!completedRequest)
          return state;
        inProgress.delete(requestId2);
        const { duration } = (_a = completedRequest.timer.measure()) !== null && _a !== void 0 ? _a : { duration: 0 };
        const downloadTimeSec = duration / 1e3;
        const { sizeByte } = event.detail;
        switch (dimensions.requestType) {
          case "lens_content":
            return {
              name: "completed",
              inProgress,
              event: new TypedCustomEvent("lensDownload", {
                name: "lensDownload",
                lensId: dimensions.lensId,
                automaticDownload: false,
                sizeByte: `${Math.ceil(sizeByte)}`,
                downloadTimeSec
              })
            };
          case "asset":
            return {
              name: "completed",
              inProgress,
              event: new TypedCustomEvent("assetDownload", {
                name: "assetDownload",
                assetId: dimensions.assetId,
                automaticDownload: false,
                sizeByte: `${Math.ceil(sizeByte)}`,
                downloadTimeSec
              })
            };
          default:
            assertUnreachable(dimensions);
        }
      case "errored":
        const erroredRequest = inProgress.get(requestId2);
        if (!erroredRequest)
          return state;
        inProgress.delete(requestId2);
        const error = event.detail.error;
        return {
          name: "completed",
          inProgress,
          event: new TypedCustomEvent("exception", {
            name: "exception",
            lensId: dimensions.lensId,
            type: dimensions.requestType === "lens_content" ? "lens" : "asset",
            reason: stringifyError(error)
          })
        };
      default:
        assertUnreachable(event);
    }
  }).addEventListener("state", ({ detail: state }) => {
    if (state.name !== "completed")
      return;
    metricsEventTarget.dispatchEvent(state.event);
    if (state.event.detail.name === "exception") {
      metrics.setOperationalMetrics(Count.count("handled_exception", 1, { type: state.event.detail.type }));
    }
  });
});

// node_modules/@snap/camera-kit/dist/metrics/reporters/reportHttpMetrics.js
var getAdditionalDimensions = (dimensions) => {
  switch (dimensions.requestType) {
    case "lens_content":
    case "asset":
      return [];
    case COF_REQUEST_TYPE:
      return [["delta", dimensions.delta]];
    default:
      assertUnreachable(dimensions);
  }
};
var getContentType = (dimensions) => {
  switch (dimensions.requestType) {
    case "lens_content":
      return "lens_content";
    case "asset":
      return dimensions.assetType;
    case COF_REQUEST_TYPE:
      return COF_REQUEST_TYPE;
    default:
      assertUnreachable(dimensions);
  }
};
var getSizeKb = (event) => {
  switch (event.type) {
    case "started":
    case "errored":
      return 0;
    case "completed":
      return event.detail.sizeByte / 1024;
    default:
      assertUnreachable(event);
  }
};
var getStatus = (event) => {
  switch (event.type) {
    case "started":
    case "errored":
      return "0";
    case "completed":
      return event.detail.status.toString();
    default:
      assertUnreachable(event);
  }
};
var isRelevantRequest = (value) => {
  return isLensOrAssetRequest(value) || value["requestType"] === COF_REQUEST_TYPE;
};
var reportHttpMetrics = Injectable("reportHttpMetrics", [metricsClientFactory.token, requestStateEventTargetFactory.token], (metrics, requestStateEventTarget) => {
  scan2({ name: "inProgress", inProgress: /* @__PURE__ */ new Map() })(requestStateEventTarget, ["started", "completed", "errored"], (state, event) => {
    var _a;
    const { inProgress } = state;
    const { dimensions, requestId: requestId2 } = event.detail;
    if (!isRelevantRequest(dimensions))
      return state;
    switch (event.type) {
      case "started":
        const timer2 = event.detail.timer;
        inProgress.set(requestId2, { timer: timer2 });
        return { name: "inProgress", inProgress };
      case "completed":
      case "errored":
        const completedRequest = inProgress.get(requestId2);
        if (!completedRequest)
          return state;
        inProgress.delete(requestId2);
        const downloadSizeKb = getSizeKb(event);
        const status = getStatus(event);
        const operationalDimensions = {
          content_type: getContentType(dimensions),
          network_type: (_a = getPlatformInfo().connectionType) !== null && _a !== void 0 ? _a : "unknown",
          status
        };
        for (const [key, value] of getAdditionalDimensions(dimensions)) {
          operationalDimensions[key] = value;
        }
        completedRequest.timer.measure(operationalDimensions);
        return {
          name: "completed",
          inProgress: state.inProgress,
          dimensions: operationalDimensions,
          downloadSizeKb,
          timer: completedRequest.timer
        };
      default:
        assertUnreachable(event);
    }
  }).addEventListener("state", ({ detail: state }) => {
    if (state.name !== "completed")
      return;
    const { dimensions, timer: timer2, downloadSizeKb } = state;
    metrics.setOperationalMetrics(Count.count("download_finished", 1, dimensions));
    metrics.setOperationalMetrics(Histogram.level("download_size_kb", downloadSizeKb, dimensions));
    metrics.setOperationalMetrics(timer2);
  });
});

// node_modules/@snap/camera-kit/dist/metrics/reporters/reportLegalState.js
var reportLegalState = Injectable("reportLegalState", [legalStateFactory.token, metricsEventTargetFactory.token, metricsClientFactory.token], (legalState, metricsEventTarget, metrics) => {
  legalState.events.pipe(forActions("accept", "reject"), map(([{ data, name }]) => ({
    name: "legalPrompt",
    legalPromptId: data,
    legalPromptResult: name === "accept" ? CameraKitLegalPromptResult.CAMERA_KIT_LEGAL_PROMPT_ACCEPTED : CameraKitLegalPromptResult.CAMERA_KIT_LEGAL_PROMPT_DISMISSED
  }))).subscribe({
    next: (legalPromptEvent) => {
      metricsEventTarget.dispatchEvent(new TypedCustomEvent("legalPrompt", legalPromptEvent));
      metrics.setOperationalMetrics(Count.count("legal_prompt_interaction", 1, {
        accepted: (legalPromptEvent.legalPromptResult === CameraKitLegalPromptResult.CAMERA_KIT_LEGAL_PROMPT_ACCEPTED).toString()
      }));
    }
  });
});

// node_modules/@snap/camera-kit/dist/metrics/reporters/reportLensValidationFailed.js
var reportLensValidationFailed = Injectable("reportLensValidationFailed", [lensStateFactory.token, metricsEventTargetFactory.token], (lensState, metricsEventTarget) => {
  lensState.events.pipe(forActions("applyLensFailed"), filter(([a2]) => a2.data.error.name === "LensContentValidationError")).subscribe({
    next: ([{ data }]) => {
      const { lens } = data;
      const lensContentValidationFailed = {
        name: "lensContentValidationFailed",
        lensId: lens.id
      };
      metricsEventTarget.dispatchEvent(new TypedCustomEvent("lensContentValidationFailed", lensContentValidationFailed));
    }
  });
});

// node_modules/@snap/camera-kit/dist/common/date.js
var DEFAULT_TIMEZONE = "America/Los_Angeles";
var dayFormatter = new Intl.DateTimeFormat("en-US", {
  timeZone: DEFAULT_TIMEZONE,
  year: "numeric",
  month: "numeric",
  day: "numeric"
});
var monthFormatter = new Intl.DateTimeFormat("en-US", {
  timeZone: DEFAULT_TIMEZONE,
  year: "numeric",
  month: "numeric"
});

// node_modules/@snap/camera-kit/dist/metrics/reporters/reportLensView.js
var viewTimeThresholdSec = 0.1;
function isFirstTimeWithinPeriods(lensId, persistence) {
  return __awaiter(this, void 0, void 0, function* () {
    let isLensFirstWithinDay = false;
    let isLensFirstWithinMonth = false;
    try {
      const lensLastViewDate = yield persistence.retrieve(lensId);
      const currentDate = /* @__PURE__ */ new Date();
      if (!lensLastViewDate) {
        isLensFirstWithinDay = true;
        isLensFirstWithinMonth = true;
      } else {
        isLensFirstWithinDay = dayFormatter.format(lensLastViewDate) !== dayFormatter.format(currentDate);
        isLensFirstWithinMonth = monthFormatter.format(lensLastViewDate) !== monthFormatter.format(currentDate);
      }
      yield persistence.store(lensId, currentDate);
    } catch (error) {
      console.error(`Error handling persistence for lensId ${lensId}: ${error}`);
      isLensFirstWithinDay = false;
      isLensFirstWithinMonth = false;
    }
    return { isLensFirstWithinDay, isLensFirstWithinMonth };
  });
}
var reportLensView = Injectable("reportLensView", [
  cameraKitSessionFactory.token,
  lensStateFactory.token,
  sessionStateFactory.token,
  metricsEventTargetFactory.token,
  metricsClientFactory.token,
  configurationToken
], (session, lensState, sessionState, metricsEventTarget, metrics, configuration) => __awaiter(void 0, void 0, void 0, function* () {
  var _a;
  const { cluster: performanceCluster, webglRendererInfo } = (_a = yield configuration.lensPerformance) !== null && _a !== void 0 ? _a : {
    cluster: 0,
    webglRendererInfo: "unknown"
  };
  const lensViewPersistence = new ExpiringPersistence(() => 60 * 24 * 60 * 60, new IndexedDBPersistence({ databaseName: "recentLensViews" }));
  merge(lensState.events.pipe(forActions("downloadComplete"), map(([a2]) => a2.data)), lensState.events.pipe(inStates("lensApplied"), switchMap(([, s2]) => sessionState.events.pipe(forActions("resume"), takeUntil(lensState.events.pipe(forActions("removeLens"))), map(() => s2.data))))).pipe(map((lens) => [getTimeMs(), lens.id, lens.groupId]), mergeMap(([applyLensStartTime, lensId, lensGroupId]) => {
    const alreadyOn = isState(lensState.getState(), "lensApplied");
    const applyDelay = alreadyOn ? of(0) : lensState.events.pipe(forActions("resourcesLoaded"), filter(([a2]) => a2.data.id === lensId), take(1), map(() => (getTimeMs() - applyLensStartTime) / 1e3));
    const viewMetrics = (alreadyOn ? of([getTimeMs(), session.metrics.beginMeasurement()]) : lensState.events.pipe(forActions("turnedOn"), filter(([a2]) => a2.data.id === lensId), map(() => [getTimeMs(), session.metrics.beginMeasurement()]))).pipe(take(1), mergeMap(([lensTurnedOnTime, metricsMeasurement]) => lensState.events.pipe(forActions("turnedOff"), filter(([a2]) => a2.data.id === lensId), raceWith(sessionState.events.pipe(forActions("suspend"))), map(() => {
      metricsMeasurement.end();
      return Object.assign({ viewTimeSec: (getTimeMs() - lensTurnedOnTime) / 1e3 }, metricsMeasurement.measure());
    }))));
    return applyDelay.pipe(combineLatestWith(viewMetrics, from(isFirstTimeWithinPeriods(lensId, lensViewPersistence))), takeUntil(lensState.events.pipe(forActions("turnedOn"), filter(([a2]) => a2.data.id !== lensId))), take(1), map(([applyDelaySec, viewMetrics2, isFirstTimeResults]) => Object.assign(Object.assign({
      applyDelaySec,
      lensId,
      lensGroupId
    }, viewMetrics2), isFirstTimeResults)));
  })).subscribe({
    next: ({ applyDelaySec, lensId, lensGroupId, viewTimeSec, avgFps, lensFrameProcessingTimeMsAvg, lensFrameProcessingTimeMsStd, lensFrameProcessingTimeMsMedian, lensFrameProcessingN, isLensFirstWithinDay, isLensFirstWithinMonth }) => __awaiter(void 0, void 0, void 0, function* () {
      if (viewTimeSec < viewTimeThresholdSec)
        return;
      const lensView = {
        name: "lensView",
        applyDelaySec,
        avgFps,
        lensId,
        lensGroupId,
        lensFrameProcessingTimeMsAvg,
        lensFrameProcessingTimeMsStd,
        recordingTimeSec: 0,
        viewTimeSec,
        isLensFirstWithinDay,
        isLensFirstWithinMonth,
        performanceCluster: `${performanceCluster}`,
        webglRendererInfo
      };
      metricsEventTarget.dispatchEvent(new TypedCustomEvent("lensView", lensView));
      metrics.setOperationalMetrics(Histogram.level("lens_view", viewTimeSec * 1e3));
      if (lensFrameProcessingN >= 30) {
        metrics.setOperationalMetrics(Histogram.level("lens_view_frame-processing-time", lensFrameProcessingTimeMsMedian, {
          performance_cluster: performanceCluster.toString()
        }));
      }
    })
  });
}));

// node_modules/@snap/camera-kit/dist/metrics/reporters/reportLensWait.js
var viewTimeThresholdSec2 = 0.1;
var reportLensWait = Injectable("reportLensWait", [lensStateFactory.token, metricsEventTargetFactory.token], (lensState, metricsEventTarget) => {
  lensState.events.pipe(forActions("applyLens"), mergeMap(([a2]) => {
    const lensId = a2.data.lens.id;
    const lensGroupId = a2.data.lens.groupId;
    const applyLensStartTime = getTimeMs();
    return lensState.events.pipe(forActions("firstFrameProcessed", "applyLens"), take(1), map(() => [
      (getTimeMs() - applyLensStartTime) / 1e3,
      lensId,
      lensGroupId
    ]));
  })).subscribe({
    next: ([viewTimeSec, lensId, lensGroupId]) => {
      if (viewTimeSec < viewTimeThresholdSec2)
        return;
      const lensWait = {
        name: "lensWait",
        lensId,
        viewTimeSec,
        lensGroupId
      };
      metricsEventTarget.dispatchEvent(new TypedCustomEvent("lensWait", lensWait));
    }
  });
});

// node_modules/@snap/camera-kit/dist/metrics/reporters/reportUserSession.js
var reportUserSession = Injectable("reportUserSession", [metricsEventTargetFactory.token], (metricsEventTarget) => __awaiter(void 0, void 0, void 0, function* () {
  var _a, _b;
  const userSessionKey = "userSessionInfo";
  const db = new IndexedDBPersistence({ databaseName: "SessionHistory" });
  const date = /* @__PURE__ */ new Date();
  const formattedDate = dayFormatter.format(date);
  const formattedDateParts = dayFormatter.formatToParts(date);
  const { day, month, year } = formattedDateParts.reduce((acc, { type, value }) => Object.assign(Object.assign({}, acc), { [type]: parseInt(value) }), {});
  const userSessionInfo = yield db.retrieve(userSessionKey);
  const mostRecentSessionStartDate = userSessionInfo === null || userSessionInfo === void 0 ? void 0 : userSessionInfo.mostRecentSessionStartDate;
  const formattedMostRecentSessionStartDate = mostRecentSessionStartDate ? dayFormatter.format(mostRecentSessionStartDate) : null;
  const dailySessionBucketMap = /* @__PURE__ */ new Map([
    [1, DailySessionBucket.ONE_SESSION],
    [2, DailySessionBucket.TWO_SESSION],
    [3, DailySessionBucket.THREE_SESSION],
    [4, DailySessionBucket.FOUR_SESSION],
    [5, DailySessionBucket.FIVE_SESSION],
    [6, DailySessionBucket.SIX_SESSION],
    [7, DailySessionBucket.SEVEN_SESSION],
    [8, DailySessionBucket.EIGHT_SESSION],
    [9, DailySessionBucket.NINE_SESSION]
  ]);
  let dailySessionBucket = (_a = userSessionInfo === null || userSessionInfo === void 0 ? void 0 : userSessionInfo.dailySessionBucket) !== null && _a !== void 0 ? _a : DailySessionBucket.NO_SESSION_BUCKET;
  let isFirstWithinMonth = false;
  if (formattedMostRecentSessionStartDate === formattedDate) {
    dailySessionBucket = (_b = dailySessionBucketMap.get(dailySessionBucket + 1)) !== null && _b !== void 0 ? _b : DailySessionBucket.TEN_OR_MORE_SESSION;
    yield db.store(userSessionKey, {
      mostRecentSessionStartDate: date,
      dailySessionBucket
    });
  } else {
    isFirstWithinMonth = !mostRecentSessionStartDate || monthFormatter.format(mostRecentSessionStartDate) !== monthFormatter.format(date);
    yield db.store(userSessionKey, {
      mostRecentSessionStartDate: date,
      dailySessionBucket: dailySessionBucket = DailySessionBucket.ONE_SESSION
    });
  }
  const session = {
    name: "session",
    dailySessionBucket,
    isFirstWithinMonth,
    month: `${month}`,
    day: `${day}`,
    year: `${year}`
  };
  metricsEventTarget.dispatchEvent(new TypedCustomEvent("session", session));
}));

// node_modules/@snap/camera-kit/dist/metrics/reporters/reportPlatformCapabilities.js
var reportPlatformCapabilities = Injectable("reportPlatformCapabilities", [metricsClientFactory.token], (metrics) => __awaiter(void 0, void 0, void 0, function* () {
  const { webgl, wasm, webxr } = yield getPlatformCapabilities();
  metrics.setOperationalMetrics(Count.count(joinMetricNames(["platform", "webgl"]), webgl.supported ? 1 : 0));
  metrics.setOperationalMetrics(Count.count(joinMetricNames(["platform", "wasm"]), wasm.supported ? 1 : 0));
  metrics.setOperationalMetrics(Count.count(joinMetricNames(["platform", "webxr"]), webxr.supported ? 1 : 0));
}));

// node_modules/@snap/camera-kit/dist/metrics/reporters/reporters.js
var reportGloballyScopedMetrics = new PartialContainer({}).provides(reportHttpMetrics).provides(reportBenchmarks).provides(reportLensAndAssetDownload).provides(reportLegalState).provides(reportPlatformCapabilities);
var reportSessionScopedMetrics = new PartialContainer({}).provides(reportUserSession).provides(reportLensView).provides(reportLensWait).provides(reportSessionException).provides(reportLensValidationFailed);

// node_modules/browser-fs-access/dist/index.modern.js
var e = (() => {
  if ("undefined" == typeof self) return false;
  if ("top" in self && self !== top) try {
    top;
  } catch (e2) {
    return false;
  }
  else if ("showOpenFilePicker" in self) return "showOpenFilePicker";
  return false;
})();
var t = e ? Promise.resolve().then(function() {
  return l;
}) : Promise.resolve().then(function() {
  return h;
});
async function n(...e2) {
  return (await t).default(...e2);
}
var r = e ? Promise.resolve().then(function() {
  return y;
}) : Promise.resolve().then(function() {
  return P;
});
var a = e ? Promise.resolve().then(function() {
  return m;
}) : Promise.resolve().then(function() {
  return k;
});
var s = async (e2) => {
  const t2 = await e2.getFile();
  return t2.handle = e2, t2;
};
var c = async (e2 = [{}]) => {
  Array.isArray(e2) || (e2 = [e2]);
  const t2 = [];
  e2.forEach((e3, n3) => {
    t2[n3] = { description: e3.description || "Files", accept: {} }, e3.mimeTypes ? e3.mimeTypes.map((r3) => {
      t2[n3].accept[r3] = e3.extensions || [];
    }) : t2[n3].accept["*/*"] = e3.extensions || [];
  });
  const n2 = await window.showOpenFilePicker({ id: e2[0].id, startIn: e2[0].startIn, types: t2, multiple: e2[0].multiple || false, excludeAcceptAllOption: e2[0].excludeAcceptAllOption || false }), r2 = await Promise.all(n2.map(s));
  return e2[0].multiple ? r2 : r2[0];
};
var l = { __proto__: null, default: c };
function u(e2) {
  function t2(e3) {
    if (Object(e3) !== e3) return Promise.reject(new TypeError(e3 + " is not an object."));
    var t3 = e3.done;
    return Promise.resolve(e3.value).then(function(e4) {
      return { value: e4, done: t3 };
    });
  }
  return u = function(e3) {
    this.s = e3, this.n = e3.next;
  }, u.prototype = { s: null, n: null, next: function() {
    return t2(this.n.apply(this.s, arguments));
  }, return: function(e3) {
    var n2 = this.s.return;
    return void 0 === n2 ? Promise.resolve({ value: e3, done: true }) : t2(n2.apply(this.s, arguments));
  }, throw: function(e3) {
    var n2 = this.s.return;
    return void 0 === n2 ? Promise.reject(e3) : t2(n2.apply(this.s, arguments));
  } }, new u(e2);
}
var p = async (e2, t2, n2 = e2.name, r2) => {
  const i = [], a2 = [];
  var o, s2 = false, c2 = false;
  try {
    for (var l2, d2 = function(e3) {
      var t3, n3, r3, i2 = 2;
      for ("undefined" != typeof Symbol && (n3 = Symbol.asyncIterator, r3 = Symbol.iterator); i2--; ) {
        if (n3 && null != (t3 = e3[n3])) return t3.call(e3);
        if (r3 && null != (t3 = e3[r3])) return new u(t3.call(e3));
        n3 = "@@asyncIterator", r3 = "@@iterator";
      }
      throw new TypeError("Object is not async iterable");
    }(e2.values()); s2 = !(l2 = await d2.next()).done; s2 = false) {
      const o2 = l2.value, s3 = `${n2}/${o2.name}`;
      "file" === o2.kind ? a2.push(o2.getFile().then((t3) => (t3.directoryHandle = e2, t3.handle = o2, Object.defineProperty(t3, "webkitRelativePath", { configurable: true, enumerable: true, get: () => s3 })))) : "directory" !== o2.kind || !t2 || r2 && r2(o2) || i.push(p(o2, t2, s3, r2));
    }
  } catch (e3) {
    c2 = true, o = e3;
  } finally {
    try {
      s2 && null != d2.return && await d2.return();
    } finally {
      if (c2) throw o;
    }
  }
  return [...(await Promise.all(i)).flat(), ...await Promise.all(a2)];
};
var d = async (e2 = {}) => {
  e2.recursive = e2.recursive || false, e2.mode = e2.mode || "read";
  const t2 = await window.showDirectoryPicker({ id: e2.id, startIn: e2.startIn, mode: e2.mode });
  return p(t2, e2.recursive, void 0, e2.skipDirectory);
};
var y = { __proto__: null, default: d };
var f = async (e2, t2 = [{}], n2 = null, r2 = false, i = null) => {
  Array.isArray(t2) || (t2 = [t2]), t2[0].fileName = t2[0].fileName || "Untitled";
  const a2 = [];
  let o = null;
  if (e2 instanceof Blob && e2.type ? o = e2.type : e2.headers && e2.headers.get("content-type") && (o = e2.headers.get("content-type")), t2.forEach((e3, t3) => {
    a2[t3] = { description: e3.description || "Files", accept: {} }, e3.mimeTypes ? (0 === t3 && o && e3.mimeTypes.push(o), e3.mimeTypes.map((n3) => {
      a2[t3].accept[n3] = e3.extensions || [];
    })) : o ? a2[t3].accept[o] = e3.extensions || [] : a2[t3].accept["*/*"] = e3.extensions || [];
  }), n2) try {
    await n2.getFile();
  } catch (e3) {
    if (n2 = null, r2) throw e3;
  }
  const s2 = n2 || await window.showSaveFilePicker({ suggestedName: t2[0].fileName, id: t2[0].id, startIn: t2[0].startIn, types: a2, excludeAcceptAllOption: t2[0].excludeAcceptAllOption || false });
  !n2 && i && i(s2);
  const c2 = await s2.createWritable();
  if ("stream" in e2) {
    const t3 = e2.stream();
    return await t3.pipeTo(c2), s2;
  }
  return "body" in e2 ? (await e2.body.pipeTo(c2), s2) : (await c2.write(await e2), await c2.close(), s2);
};
var m = { __proto__: null, default: f };
var w = async (e2 = [{}]) => (Array.isArray(e2) || (e2 = [e2]), new Promise((t2, n2) => {
  const r2 = document.createElement("input");
  r2.type = "file";
  const i = [...e2.map((e3) => e3.mimeTypes || []), ...e2.map((e3) => e3.extensions || [])].join();
  r2.multiple = e2[0].multiple || false, r2.accept = i || "", r2.style.display = "none", document.body.append(r2);
  const a2 = (e3) => {
    "function" == typeof o && o(), t2(e3);
  }, o = e2[0].legacySetup && e2[0].legacySetup(a2, () => o(n2), r2), s2 = () => {
    window.removeEventListener("focus", s2), r2.remove();
  };
  r2.addEventListener("click", () => {
    window.addEventListener("focus", s2);
  }), r2.addEventListener("change", () => {
    window.removeEventListener("focus", s2), r2.remove(), a2(r2.multiple ? Array.from(r2.files) : r2.files[0]);
  }), "showPicker" in HTMLInputElement.prototype ? r2.showPicker() : r2.click();
}));
var h = { __proto__: null, default: w };
var v = async (e2 = [{}]) => (Array.isArray(e2) || (e2 = [e2]), e2[0].recursive = e2[0].recursive || false, new Promise((t2, n2) => {
  const r2 = document.createElement("input");
  r2.type = "file", r2.webkitdirectory = true;
  const i = (e3) => {
    "function" == typeof a2 && a2(), t2(e3);
  }, a2 = e2[0].legacySetup && e2[0].legacySetup(i, () => a2(n2), r2);
  r2.addEventListener("change", () => {
    let t3 = Array.from(r2.files);
    e2[0].recursive ? e2[0].recursive && e2[0].skipDirectory && (t3 = t3.filter((t4) => t4.webkitRelativePath.split("/").every((t5) => !e2[0].skipDirectory({ name: t5, kind: "directory" })))) : t3 = t3.filter((e3) => 2 === e3.webkitRelativePath.split("/").length), i(t3);
  }), "showPicker" in HTMLInputElement.prototype ? r2.showPicker() : r2.click();
}));
var P = { __proto__: null, default: v };
var b = async (e2, t2 = {}) => {
  Array.isArray(t2) && (t2 = t2[0]);
  const n2 = document.createElement("a");
  let r2 = e2;
  "body" in e2 && (r2 = await async function(e3, t3) {
    const n3 = e3.getReader(), r3 = new ReadableStream({ start: (e4) => async function t4() {
      return n3.read().then(({ done: n4, value: r4 }) => {
        if (!n4) return e4.enqueue(r4), t4();
        e4.close();
      });
    }() }), i2 = new Response(r3), a3 = await i2.blob();
    return n3.releaseLock(), new Blob([a3], { type: t3 });
  }(e2.body, e2.headers.get("content-type"))), n2.download = t2.fileName || "Untitled", n2.href = URL.createObjectURL(await r2);
  const i = () => {
    "function" == typeof a2 && a2();
  }, a2 = t2.legacySetup && t2.legacySetup(i, () => a2(), n2);
  return n2.addEventListener("click", () => {
    setTimeout(() => URL.revokeObjectURL(n2.href), 3e4), i();
  }), n2.click(), null;
};
var k = { __proto__: null, default: b };

// node_modules/@snap/camera-kit/dist/lens-client-interface/exif.js
var JPEG_ID = 65496;
var APP1_MARKER = 65505;
var EXIF_ID = 1165519206;
var LITTLE_ENDIAN = 18761;
var ORIENTATION_TAG_OFFSET = 274;
var Orientation;
(function(Orientation2) {
  Orientation2[Orientation2["TopLeft"] = 1] = "TopLeft";
  Orientation2[Orientation2["TopRight"] = 2] = "TopRight";
  Orientation2[Orientation2["BottomRight"] = 3] = "BottomRight";
  Orientation2[Orientation2["BottomLeft"] = 4] = "BottomLeft";
  Orientation2[Orientation2["LeftTop"] = 5] = "LeftTop";
  Orientation2[Orientation2["RightTop"] = 6] = "RightTop";
  Orientation2[Orientation2["RightBottom"] = 7] = "RightBottom";
  Orientation2[Orientation2["LeftBottom"] = 8] = "LeftBottom";
})(Orientation || (Orientation = {}));
function extractJpegOrientationTag(data) {
  const view = new DataView(data);
  if (view.getUint16(0, false) !== JPEG_ID)
    return void 0;
  const length = view.byteLength;
  let offset = 2;
  while (offset < length) {
    if (view.getUint16(offset + 2, false) <= 8)
      return void 0;
    let marker = view.getUint16(offset, false);
    offset += 2;
    if (marker === APP1_MARKER) {
      if (view.getUint32(offset += 2, false) !== EXIF_ID) {
        return void 0;
      }
      let little = view.getUint16(offset += 6, false) === LITTLE_ENDIAN;
      offset += view.getUint32(offset + 4, little);
      let tags = view.getUint16(offset, little);
      offset += 2;
      for (let i = 0; i < tags; i++) {
        if (view.getUint16(offset + i * 12, little) === ORIENTATION_TAG_OFFSET) {
          return view.getUint16(offset + i * 12 + 8, little);
        }
      }
    } else if ((marker & 65280) !== 65280) {
      break;
    } else {
      offset += view.getUint16(offset, false);
    }
  }
  return void 0;
}

// node_modules/@snap/camera-kit/dist/lens-client-interface/imagePicker.js
var logger18 = getLogger("lensClientInterfaceImagePicker");
var mimeTypes = {
  image: [
    "image/avif",
    "image/bmp",
    "image/gif",
    "image/jpeg",
    "image/png",
    "image/svg+xml",
    "image/tiff",
    "image/webp"
  ],
  video: [
    "video/3gpp",
    "video/3gpp2",
    "video/mp2t",
    "video/mp4",
    "video/mpeg",
    "video/ogg",
    "video/quicktime",
    "video/webm",
    "video/x-msvideo"
  ]
};
function* enumerateSupportedVideoTypes(types) {
  const testVideoElement = typeof document !== "undefined" ? document.createElement("video") : void 0;
  for (const type of types) {
    if ((testVideoElement === null || testVideoElement === void 0 ? void 0 : testVideoElement.canPlayType(type)) || false) {
      yield type;
    }
  }
}
function readFileAsArrayBuffer(file) {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.addEventListener("load", (event) => {
      resolve(event.target.result);
    });
    reader.addEventListener("error", (event) => {
      reject(event.target.error);
    });
    reader.readAsArrayBuffer(file);
  });
}
function getMimeType({ ImageEnabled, VideoEnabled }) {
  const types = [];
  if (ImageEnabled === "1")
    types.push(...mimeTypes.image);
  if (VideoEnabled === "1")
    types.push(...enumerateSupportedVideoTypes(mimeTypes.video));
  if (types.length === 0) {
    throw new Error("Unknown media type requested.");
  }
  return types;
}
function getOrientation(data, lensCore) {
  var _a;
  const orientationMap = {
    [1]: lensCore.ExternalMediaOrientation.CW0,
    [2]: lensCore.ExternalMediaOrientation.CW0,
    [3]: lensCore.ExternalMediaOrientation.CW180,
    [4]: lensCore.ExternalMediaOrientation.CW180,
    [5]: lensCore.ExternalMediaOrientation.CW90,
    [6]: lensCore.ExternalMediaOrientation.CW90,
    [7]: lensCore.ExternalMediaOrientation.CW270,
    [8]: lensCore.ExternalMediaOrientation.CW270
  };
  try {
    return orientationMap[(_a = extractJpegOrientationTag(data)) !== null && _a !== void 0 ? _a : 1];
  } catch (error) {
    logger18.info("Error occured while reading EXIF orientation tag.", error);
    return lensCore.ExternalMediaOrientation.CW0;
  }
}
function pickClientImage(clientInterfaceData, lensCore) {
  return __awaiter(this, void 0, void 0, function* () {
    const mimeTypes2 = getMimeType(clientInterfaceData);
    logger18.debug(`Opening file dialog for MIME types: ${mimeTypes2}`);
    const file = yield n({ mimeTypes: mimeTypes2 });
    logger18.debug(`Selected file MIME type: ${file.type}`);
    const data = yield readFileAsArrayBuffer(file);
    if (file.type.startsWith("image/")) {
      lensCore.provideExternalImage({
        data,
        orientation: getOrientation(data, lensCore),
        faceRects: [
          {
            origin: {
              x: 0,
              y: 0
            },
            size: {
              width: 1,
              height: 1
            }
          }
        ]
      });
    } else {
      lensCore.provideExternalVideo({
        data,
        orientation: lensCore.ExternalMediaOrientation.CW0
      });
    }
  });
}

// node_modules/@snap/camera-kit/dist/lens-client-interface/lensClientInterface.js
var logger19 = getLogger("lensClientInterface");
var registerLensClientInterfaceHandler = Injectable("registerLensClientInterfaceHandler", [lensCoreFactory.token], (lensCore) => {
  if (!lensCore.setClientInterfaceRequestHandler) {
    logger19.warn("Current LensCore version doesn't support lens client interface requests");
    return;
  }
  lensCore.setClientInterfaceRequestHandler(({ data, interfaceControl, interfaceAction }) => __awaiter(void 0, void 0, void 0, function* () {
    if (interfaceControl === lensCore.InterfaceControl.ImagePicker && interfaceAction === lensCore.InterfaceAction.Show) {
      yield pickClientImage(data, lensCore).catch((error) => {
        logger19.error(lensImagePickerError("Error occurred while attempting to select an image file for the lens request.", error));
      });
    }
  }));
});

// node_modules/@snap/camera-kit/dist/remote-configuration/preloadConfiguration.js
var logger20 = getLogger("setPreloadedConfiguration");
var setPreloadedConfiguration = Injectable("setPreloadedConfiguration", [lensCoreFactory.token, remoteConfigurationFactory.token], (lensCore, remoteConfiguration) => {
  remoteConfiguration.getNamespace(Namespace.LENS_CORE_CONFIG).pipe(take(1)).subscribe({
    next: (configs) => {
      const inputs = configs.map(({ configId, value }) => ({ configId, value }));
      lensCore.setPreloadedConfiguration(inputs);
    },
    error: logger20.error
  });
});

// node_modules/@snap/camera-kit/dist/CameraKit.js
var logger21 = getLogger("CameraKit");
var publicMetricsEventNames = ["lensView", "lensWait"];
var CameraKit = (() => {
  var _a;
  let _instanceExtraInitializers = [];
  let _createSession_decorators;
  let _destroy_decorators;
  return _a = class CameraKit {
    constructor(lensRepository, lensCore, pageVisibility, container, allMetrics) {
      this.lensRepository = (__runInitializers(this, _instanceExtraInitializers), lensRepository);
      this.lensCore = lensCore;
      this.pageVisibility = pageVisibility;
      this.container = container;
      this.metrics = new TypedEventTarget();
      this.sessions = [];
      this.lenses = { repository: this.lensRepository };
      publicMetricsEventNames.forEach((eventName) => {
        allMetrics.addEventListener(eventName, (e2) => this.metrics.dispatchEvent(e2));
      });
    }
    createSession({ liveRenderTarget, renderWhileTabHidden } = {}) {
      return __awaiter(this, void 0, void 0, function* () {
        const exceptionHandler = (error) => {
          if (error.name === "LensCoreAbortError") {
            logger21.error(lensAbortError("Unrecoverable error occurred during lens execution. The CameraKitSession will be destroyed.", error));
          } else {
            logger21.error(lensExecutionError("Error occurred during lens execution. The lens cannot be rendered and will be removed from the CameraKitSession.", error));
          }
        };
        yield this.lensCore.initialize({
          canvas: liveRenderTarget,
          shouldUseWorker: !renderWhileTabHidden && this.container.get(configurationToken).shouldUseWorker,
          exceptionHandler
        });
        yield this.lensCore.setRenderLoopMode({
          mode: renderWhileTabHidden ? this.lensCore.RenderLoopMode.SetTimeout : this.lensCore.RenderLoopMode.RequestAnimationFrame
        });
        const sessionContainer = this.container.copy().provides(sessionStateFactory).provides(lensStateFactory).provides(lensKeyboardFactory).provides(cameraKitSessionFactory).run(registerLensAssetsProvider).run(registerLensClientInterfaceHandler).run(setPreloadedConfiguration).run(reportSessionScopedMetrics).run(registerUriHandlers);
        const session = sessionContainer.get(cameraKitSessionFactory.token);
        this.sessions.push(session);
        return session;
      });
    }
    destroy() {
      return __awaiter(this, void 0, void 0, function* () {
        resetLogger();
        this.pageVisibility.destroy();
        yield Promise.all(this.sessions.map((session) => session.destroy()));
        this.sessions = [];
      });
    }
  }, (() => {
    _createSession_decorators = [errorLoggingDecorator(logger21)];
    _destroy_decorators = [errorLoggingDecorator(logger21)];
    __esDecorate(_a, null, _createSession_decorators, { kind: "method", name: "createSession", static: false, private: false, access: { has: (obj) => "createSession" in obj, get: (obj) => obj.createSession } }, null, _instanceExtraInitializers);
    __esDecorate(_a, null, _destroy_decorators, { kind: "method", name: "destroy", static: false, private: false, access: { has: (obj) => "destroy" in obj, get: (obj) => obj.destroy } }, null, _instanceExtraInitializers);
  })(), _a;
})();
var cameraKitFactory = Injectable("CameraKit", [
  lensRepositoryFactory.token,
  metricsEventTargetFactory.token,
  lensCoreFactory.token,
  pageVisibilityFactory.token,
  CONTAINER
], (lensRepository, metrics, lensCore, pageVisibility, container) => new CameraKit(lensRepository, lensCore, pageVisibility, container, metrics));

// node_modules/@snap/camera-kit/dist/platform/assertPlatformSupported.js
function assertPlatformSupported() {
  return __awaiter(this, void 0, void 0, function* () {
    const { wasm, webgl } = yield getPlatformCapabilities();
    if (!wasm.supported)
      throw wasm.error;
    if (!webgl.supported)
      throw webgl.error;
  });
}

// node_modules/uuid/dist/esm-browser/rng.js
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues) {
    getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);
    if (!getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
  }
  return getRandomValues(rnds8);
}

// node_modules/uuid/dist/esm-browser/regex.js
var regex_default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;

// node_modules/uuid/dist/esm-browser/validate.js
function validate2(uuid) {
  return typeof uuid === "string" && regex_default.test(uuid);
}
var validate_default = validate2;

// node_modules/uuid/dist/esm-browser/stringify.js
var byteToHex = [];
for (let i = 0; i < 256; ++i) {
  byteToHex.push((i + 256).toString(16).slice(1));
}
function unsafeStringify(arr, offset = 0) {
  return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];
}

// node_modules/uuid/dist/esm-browser/parse.js
function parse(uuid) {
  if (!validate_default(uuid)) {
    throw TypeError("Invalid UUID");
  }
  let v2;
  const arr = new Uint8Array(16);
  arr[0] = (v2 = parseInt(uuid.slice(0, 8), 16)) >>> 24;
  arr[1] = v2 >>> 16 & 255;
  arr[2] = v2 >>> 8 & 255;
  arr[3] = v2 & 255;
  arr[4] = (v2 = parseInt(uuid.slice(9, 13), 16)) >>> 8;
  arr[5] = v2 & 255;
  arr[6] = (v2 = parseInt(uuid.slice(14, 18), 16)) >>> 8;
  arr[7] = v2 & 255;
  arr[8] = (v2 = parseInt(uuid.slice(19, 23), 16)) >>> 8;
  arr[9] = v2 & 255;
  arr[10] = (v2 = parseInt(uuid.slice(24, 36), 16)) / 1099511627776 & 255;
  arr[11] = v2 / 4294967296 & 255;
  arr[12] = v2 >>> 24 & 255;
  arr[13] = v2 >>> 16 & 255;
  arr[14] = v2 >>> 8 & 255;
  arr[15] = v2 & 255;
  return arr;
}
var parse_default = parse;

// node_modules/uuid/dist/esm-browser/v35.js
function stringToBytes(str) {
  str = unescape(encodeURIComponent(str));
  const bytes = [];
  for (let i = 0; i < str.length; ++i) {
    bytes.push(str.charCodeAt(i));
  }
  return bytes;
}
var DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
var URL2 = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
function v35(name, version, hashfunc) {
  function generateUUID(value, namespace, buf, offset) {
    var _namespace;
    if (typeof value === "string") {
      value = stringToBytes(value);
    }
    if (typeof namespace === "string") {
      namespace = parse_default(namespace);
    }
    if (((_namespace = namespace) === null || _namespace === void 0 ? void 0 : _namespace.length) !== 16) {
      throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
    }
    let bytes = new Uint8Array(16 + value.length);
    bytes.set(namespace);
    bytes.set(value, namespace.length);
    bytes = hashfunc(bytes);
    bytes[6] = bytes[6] & 15 | version;
    bytes[8] = bytes[8] & 63 | 128;
    if (buf) {
      offset = offset || 0;
      for (let i = 0; i < 16; ++i) {
        buf[offset + i] = bytes[i];
      }
      return buf;
    }
    return unsafeStringify(bytes);
  }
  try {
    generateUUID.name = name;
  } catch (err) {
  }
  generateUUID.DNS = DNS;
  generateUUID.URL = URL2;
  return generateUUID;
}

// node_modules/uuid/dist/esm-browser/md5.js
function md5(bytes) {
  if (typeof bytes === "string") {
    const msg = unescape(encodeURIComponent(bytes));
    bytes = new Uint8Array(msg.length);
    for (let i = 0; i < msg.length; ++i) {
      bytes[i] = msg.charCodeAt(i);
    }
  }
  return md5ToHexEncodedArray(wordsToMd5(bytesToWords(bytes), bytes.length * 8));
}
function md5ToHexEncodedArray(input) {
  const output = [];
  const length32 = input.length * 32;
  const hexTab = "0123456789abcdef";
  for (let i = 0; i < length32; i += 8) {
    const x = input[i >> 5] >>> i % 32 & 255;
    const hex = parseInt(hexTab.charAt(x >>> 4 & 15) + hexTab.charAt(x & 15), 16);
    output.push(hex);
  }
  return output;
}
function getOutputLength(inputLength8) {
  return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;
}
function wordsToMd5(x, len) {
  x[len >> 5] |= 128 << len % 32;
  x[getOutputLength(len) - 1] = len;
  let a2 = 1732584193;
  let b2 = -271733879;
  let c2 = -1732584194;
  let d2 = 271733878;
  for (let i = 0; i < x.length; i += 16) {
    const olda = a2;
    const oldb = b2;
    const oldc = c2;
    const oldd = d2;
    a2 = md5ff(a2, b2, c2, d2, x[i], 7, -680876936);
    d2 = md5ff(d2, a2, b2, c2, x[i + 1], 12, -389564586);
    c2 = md5ff(c2, d2, a2, b2, x[i + 2], 17, 606105819);
    b2 = md5ff(b2, c2, d2, a2, x[i + 3], 22, -1044525330);
    a2 = md5ff(a2, b2, c2, d2, x[i + 4], 7, -176418897);
    d2 = md5ff(d2, a2, b2, c2, x[i + 5], 12, 1200080426);
    c2 = md5ff(c2, d2, a2, b2, x[i + 6], 17, -1473231341);
    b2 = md5ff(b2, c2, d2, a2, x[i + 7], 22, -45705983);
    a2 = md5ff(a2, b2, c2, d2, x[i + 8], 7, 1770035416);
    d2 = md5ff(d2, a2, b2, c2, x[i + 9], 12, -1958414417);
    c2 = md5ff(c2, d2, a2, b2, x[i + 10], 17, -42063);
    b2 = md5ff(b2, c2, d2, a2, x[i + 11], 22, -1990404162);
    a2 = md5ff(a2, b2, c2, d2, x[i + 12], 7, 1804603682);
    d2 = md5ff(d2, a2, b2, c2, x[i + 13], 12, -40341101);
    c2 = md5ff(c2, d2, a2, b2, x[i + 14], 17, -1502002290);
    b2 = md5ff(b2, c2, d2, a2, x[i + 15], 22, 1236535329);
    a2 = md5gg(a2, b2, c2, d2, x[i + 1], 5, -165796510);
    d2 = md5gg(d2, a2, b2, c2, x[i + 6], 9, -1069501632);
    c2 = md5gg(c2, d2, a2, b2, x[i + 11], 14, 643717713);
    b2 = md5gg(b2, c2, d2, a2, x[i], 20, -373897302);
    a2 = md5gg(a2, b2, c2, d2, x[i + 5], 5, -701558691);
    d2 = md5gg(d2, a2, b2, c2, x[i + 10], 9, 38016083);
    c2 = md5gg(c2, d2, a2, b2, x[i + 15], 14, -660478335);
    b2 = md5gg(b2, c2, d2, a2, x[i + 4], 20, -405537848);
    a2 = md5gg(a2, b2, c2, d2, x[i + 9], 5, 568446438);
    d2 = md5gg(d2, a2, b2, c2, x[i + 14], 9, -1019803690);
    c2 = md5gg(c2, d2, a2, b2, x[i + 3], 14, -187363961);
    b2 = md5gg(b2, c2, d2, a2, x[i + 8], 20, 1163531501);
    a2 = md5gg(a2, b2, c2, d2, x[i + 13], 5, -1444681467);
    d2 = md5gg(d2, a2, b2, c2, x[i + 2], 9, -51403784);
    c2 = md5gg(c2, d2, a2, b2, x[i + 7], 14, 1735328473);
    b2 = md5gg(b2, c2, d2, a2, x[i + 12], 20, -1926607734);
    a2 = md5hh(a2, b2, c2, d2, x[i + 5], 4, -378558);
    d2 = md5hh(d2, a2, b2, c2, x[i + 8], 11, -2022574463);
    c2 = md5hh(c2, d2, a2, b2, x[i + 11], 16, 1839030562);
    b2 = md5hh(b2, c2, d2, a2, x[i + 14], 23, -35309556);
    a2 = md5hh(a2, b2, c2, d2, x[i + 1], 4, -1530992060);
    d2 = md5hh(d2, a2, b2, c2, x[i + 4], 11, 1272893353);
    c2 = md5hh(c2, d2, a2, b2, x[i + 7], 16, -155497632);
    b2 = md5hh(b2, c2, d2, a2, x[i + 10], 23, -1094730640);
    a2 = md5hh(a2, b2, c2, d2, x[i + 13], 4, 681279174);
    d2 = md5hh(d2, a2, b2, c2, x[i], 11, -358537222);
    c2 = md5hh(c2, d2, a2, b2, x[i + 3], 16, -722521979);
    b2 = md5hh(b2, c2, d2, a2, x[i + 6], 23, 76029189);
    a2 = md5hh(a2, b2, c2, d2, x[i + 9], 4, -640364487);
    d2 = md5hh(d2, a2, b2, c2, x[i + 12], 11, -421815835);
    c2 = md5hh(c2, d2, a2, b2, x[i + 15], 16, 530742520);
    b2 = md5hh(b2, c2, d2, a2, x[i + 2], 23, -995338651);
    a2 = md5ii(a2, b2, c2, d2, x[i], 6, -198630844);
    d2 = md5ii(d2, a2, b2, c2, x[i + 7], 10, 1126891415);
    c2 = md5ii(c2, d2, a2, b2, x[i + 14], 15, -1416354905);
    b2 = md5ii(b2, c2, d2, a2, x[i + 5], 21, -57434055);
    a2 = md5ii(a2, b2, c2, d2, x[i + 12], 6, 1700485571);
    d2 = md5ii(d2, a2, b2, c2, x[i + 3], 10, -1894986606);
    c2 = md5ii(c2, d2, a2, b2, x[i + 10], 15, -1051523);
    b2 = md5ii(b2, c2, d2, a2, x[i + 1], 21, -2054922799);
    a2 = md5ii(a2, b2, c2, d2, x[i + 8], 6, 1873313359);
    d2 = md5ii(d2, a2, b2, c2, x[i + 15], 10, -30611744);
    c2 = md5ii(c2, d2, a2, b2, x[i + 6], 15, -1560198380);
    b2 = md5ii(b2, c2, d2, a2, x[i + 13], 21, 1309151649);
    a2 = md5ii(a2, b2, c2, d2, x[i + 4], 6, -145523070);
    d2 = md5ii(d2, a2, b2, c2, x[i + 11], 10, -1120210379);
    c2 = md5ii(c2, d2, a2, b2, x[i + 2], 15, 718787259);
    b2 = md5ii(b2, c2, d2, a2, x[i + 9], 21, -343485551);
    a2 = safeAdd(a2, olda);
    b2 = safeAdd(b2, oldb);
    c2 = safeAdd(c2, oldc);
    d2 = safeAdd(d2, oldd);
  }
  return [a2, b2, c2, d2];
}
function bytesToWords(input) {
  if (input.length === 0) {
    return [];
  }
  const length8 = input.length * 8;
  const output = new Uint32Array(getOutputLength(length8));
  for (let i = 0; i < length8; i += 8) {
    output[i >> 5] |= (input[i / 8] & 255) << i % 32;
  }
  return output;
}
function safeAdd(x, y2) {
  const lsw = (x & 65535) + (y2 & 65535);
  const msw = (x >> 16) + (y2 >> 16) + (lsw >> 16);
  return msw << 16 | lsw & 65535;
}
function bitRotateLeft(num, cnt) {
  return num << cnt | num >>> 32 - cnt;
}
function md5cmn(q, a2, b2, x, s2, t2) {
  return safeAdd(bitRotateLeft(safeAdd(safeAdd(a2, q), safeAdd(x, t2)), s2), b2);
}
function md5ff(a2, b2, c2, d2, x, s2, t2) {
  return md5cmn(b2 & c2 | ~b2 & d2, a2, b2, x, s2, t2);
}
function md5gg(a2, b2, c2, d2, x, s2, t2) {
  return md5cmn(b2 & d2 | c2 & ~d2, a2, b2, x, s2, t2);
}
function md5hh(a2, b2, c2, d2, x, s2, t2) {
  return md5cmn(b2 ^ c2 ^ d2, a2, b2, x, s2, t2);
}
function md5ii(a2, b2, c2, d2, x, s2, t2) {
  return md5cmn(c2 ^ (b2 | ~d2), a2, b2, x, s2, t2);
}
var md5_default = md5;

// node_modules/uuid/dist/esm-browser/v3.js
var v3 = v35("v3", 48, md5_default);

// node_modules/uuid/dist/esm-browser/native.js
var randomUUID = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
var native_default = {
  randomUUID
};

// node_modules/uuid/dist/esm-browser/v4.js
function v4(options, buf, offset) {
  if (native_default.randomUUID && !buf && !options) {
    return native_default.randomUUID();
  }
  options = options || {};
  const rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    for (let i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }
    return buf;
  }
  return unsafeStringify(rnds);
}
var v4_default = v4;

// node_modules/uuid/dist/esm-browser/sha1.js
function f2(s2, x, y2, z) {
  switch (s2) {
    case 0:
      return x & y2 ^ ~x & z;
    case 1:
      return x ^ y2 ^ z;
    case 2:
      return x & y2 ^ x & z ^ y2 & z;
    case 3:
      return x ^ y2 ^ z;
  }
}
function ROTL(x, n2) {
  return x << n2 | x >>> 32 - n2;
}
function sha1(bytes) {
  const K = [1518500249, 1859775393, 2400959708, 3395469782];
  const H = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
  if (typeof bytes === "string") {
    const msg = unescape(encodeURIComponent(bytes));
    bytes = [];
    for (let i = 0; i < msg.length; ++i) {
      bytes.push(msg.charCodeAt(i));
    }
  } else if (!Array.isArray(bytes)) {
    bytes = Array.prototype.slice.call(bytes);
  }
  bytes.push(128);
  const l2 = bytes.length / 4 + 2;
  const N = Math.ceil(l2 / 16);
  const M = new Array(N);
  for (let i = 0; i < N; ++i) {
    const arr = new Uint32Array(16);
    for (let j = 0; j < 16; ++j) {
      arr[j] = bytes[i * 64 + j * 4] << 24 | bytes[i * 64 + j * 4 + 1] << 16 | bytes[i * 64 + j * 4 + 2] << 8 | bytes[i * 64 + j * 4 + 3];
    }
    M[i] = arr;
  }
  M[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);
  M[N - 1][14] = Math.floor(M[N - 1][14]);
  M[N - 1][15] = (bytes.length - 1) * 8 & 4294967295;
  for (let i = 0; i < N; ++i) {
    const W = new Uint32Array(80);
    for (let t2 = 0; t2 < 16; ++t2) {
      W[t2] = M[i][t2];
    }
    for (let t2 = 16; t2 < 80; ++t2) {
      W[t2] = ROTL(W[t2 - 3] ^ W[t2 - 8] ^ W[t2 - 14] ^ W[t2 - 16], 1);
    }
    let a2 = H[0];
    let b2 = H[1];
    let c2 = H[2];
    let d2 = H[3];
    let e2 = H[4];
    for (let t2 = 0; t2 < 80; ++t2) {
      const s2 = Math.floor(t2 / 20);
      const T = ROTL(a2, 5) + f2(s2, b2, c2, d2) + e2 + K[s2] + W[t2] >>> 0;
      e2 = d2;
      d2 = c2;
      c2 = ROTL(b2, 30) >>> 0;
      b2 = a2;
      a2 = T;
    }
    H[0] = H[0] + a2 >>> 0;
    H[1] = H[1] + b2 >>> 0;
    H[2] = H[2] + c2 >>> 0;
    H[3] = H[3] + d2 >>> 0;
    H[4] = H[4] + e2 >>> 0;
  }
  return [H[0] >> 24 & 255, H[0] >> 16 & 255, H[0] >> 8 & 255, H[0] & 255, H[1] >> 24 & 255, H[1] >> 16 & 255, H[1] >> 8 & 255, H[1] & 255, H[2] >> 24 & 255, H[2] >> 16 & 255, H[2] >> 8 & 255, H[2] & 255, H[3] >> 24 & 255, H[3] >> 16 & 255, H[3] >> 8 & 255, H[3] & 255, H[4] >> 24 & 255, H[4] >> 16 & 255, H[4] >> 8 & 255, H[4] & 255];
}
var sha1_default = sha1;

// node_modules/uuid/dist/esm-browser/v5.js
var v5 = v35("v5", 80, sha1_default);

// node_modules/@snap/camera-kit/dist/metrics/businessEventsReporter.js
var logger22 = getLogger("BusinessEventsReporter");
var connectivityTypeMapping = {
  cellular: CameraKitConnectivityType2.CAMERA_KIT_CONNECTIVITY_TYPE_MOBILE,
  bluetooth: CameraKitConnectivityType2.CAMERA_KIT_CONNECTIVITY_TYPE_BLUETOOTH,
  wifi: CameraKitConnectivityType2.CAMERA_KIT_CONNECTIVITY_TYPE_WIFI,
  unknown: CameraKitConnectivityType2.CAMERA_KIT_CONNECTIVITY_TYPE_UNKNOWN,
  none: CameraKitConnectivityType2.CAMERA_KIT_CONNECTIVITY_TYPE_UNREACHABLE
};
var vendorUuidKey = "vendorUuid";
var vendorUuidExpiry = convertDaysToSeconds(60);
var getOrGenerateVendorUuid = (persistence) => __awaiter(void 0, void 0, void 0, function* () {
  try {
    const storedUuid = yield persistence.retrieve(vendorUuidKey);
    if (storedUuid) {
      return storedUuid;
    }
    const newUuid = v4_default();
    yield persistence.store(vendorUuidKey, newUuid);
    return newUuid;
  } catch (error) {
    throw new Error("Failed to generate vendor UUID");
  }
});
function listenAndReport(metricsEventTarget, metricsClient, eventHandlers, appVendorAndPartnerUuid) {
  const sessionId = v4_default();
  logger22.log(`Session ID: ${sessionId}`);
  let sequenceId = 1;
  const makeBlizzardEvent = (event, appVendorUuid, partnerUuid) => {
    var _a;
    const { sdkShortVersion, sdkLongVersion, lensCore, locale, origin, deviceModel, connectionType } = getPlatformInfo();
    const deviceConnectivity = (_a = connectivityTypeMapping[connectionType]) !== null && _a !== void 0 ? _a : CameraKitConnectivityType2.CAMERA_KIT_CONNECTIVITY_TYPE_UNKNOWN;
    return Object.assign(Object.assign({}, event), { cameraKitEventBase: CameraKitEventBase.fromPartial({
      kitEventBase: KitEventBase.fromPartial({
        locale,
        kitVariant: KitType.CAMERA_KIT_WEB,
        kitVariantVersion: sdkShortVersion,
        kitClientTimestampMillis: `${Date.now()}`
      }),
      deviceCluster: "0",
      cameraKitVersion: sdkLongVersion,
      lensCoreVersion: lensCore.version,
      deviceModel,
      cameraKitVariant: CameraKitVariant.CAMERA_KIT_VARIANT_PARTNER,
      cameraKitFlavor: CameraKitFlavor2.CAMERA_KIT_FLAVOR_DEBUG,
      appId: origin,
      deviceConnectivity,
      sessionId,
      appVendorUuid,
      partnerUuid
    }) });
  };
  const sendServerEvent = (eventName, eventData) => {
    const { osName: osType, osVersion } = getPlatformInfo();
    return metricsClient.setBusinessEvents(ServerEvent.fromPartial({
      eventName,
      osType,
      osVersion,
      maxSequenceIdOnInstance: "0",
      sequenceId: `${sequenceId++}`,
      eventData
    }));
  };
  const metricsEvents = entries(eventHandlers).map(([eventType, createEventData]) => fromEvent(metricsEventTarget, eventType).pipe(map((event) => ({ event, createEventData }))));
  merge(...metricsEvents).pipe(combineLatestWith(appVendorAndPartnerUuid)).subscribe(([{ event, createEventData }, { appVendorUuid, partnerUuid }]) => {
    const [eventName, eventData] = createEventData(makeBlizzardEvent(event.detail, appVendorUuid, partnerUuid));
    sendServerEvent(eventName, eventData);
  });
}
function getAppVendorAndPartnerUuid(configuration, remoteConfiguration) {
  const vendorAnalyticsPersistence = new ExpiringPersistence(() => vendorUuidExpiry, new IndexedDBPersistence({ databaseName: "VendorAnalytics" }));
  return remoteConfiguration.getInitializationConfig().pipe(take(1), switchMap(({ appVendorUuidOptIn }) => {
    const partnerUuid = configuration.analyticsId;
    if (appVendorUuidOptIn) {
      return from(getOrGenerateVendorUuid(vendorAnalyticsPersistence)).pipe(map((appVendorUuid) => ({ appVendorUuid, partnerUuid })));
    }
    return of({ appVendorUuid: void 0, partnerUuid });
  }), catchError((error) => {
    logger22.warn(`Failed to retrieve or generate vendor UUID.`, error);
    return of({ appVendorUuid: void 0, partnerUuid: configuration.analyticsId });
  }));
}
var businessEventsReporterFactory = Injectable("businessEventsReporter", [
  metricsEventTargetFactory.token,
  metricsClientFactory.token,
  configurationToken,
  remoteConfigurationFactory.token
], (metricsEventTarget, metricsClient, configuration, remoteConfiguration) => {
  const appVendorAndPartnerUuid = getAppVendorAndPartnerUuid(configuration, remoteConfiguration);
  listenAndReport(metricsEventTarget, metricsClient, {
    assetDownload: (event) => [
      "CAMERA_KIT_ASSET_DOWNLOAD",
      { cameraKitAssetDownload: CameraKitAssetDownload.fromPartial(event) }
    ],
    assetValidationFailed: (event) => [
      "CAMERA_KIT_ASSET_VALIDATION_FAILED",
      {
        cameraKitAssetValidationFailed: CameraKitAssetValidationFailed.fromPartial(event)
      }
    ],
    benchmarkComplete: (event) => [
      "CAMERA_KIT_WEB_BENCHMARK_COMPLETE",
      {
        cameraKitWebBenchmarkComplete: CameraKitWebBenchmarkComplete.fromPartial(event)
      }
    ],
    exception: (event) => [
      "CAMERA_KIT_EXCEPTION",
      { cameraKitException: CameraKitException.fromPartial(event) }
    ],
    legalPrompt: (event) => [
      "CAMERA_KIT_LEGAL_PROMPT",
      { cameraKitLegalPrompt: CameraKitLegalPrompt.fromPartial(event) }
    ],
    lensDownload: (event) => [
      "CAMERA_KIT_LENS_DOWNLOAD",
      { cameraKitLensDownload: CameraKitLensDownload.fromPartial(event) }
    ],
    lensView: (event) => [
      "CAMERA_KIT_WEB_LENS_SWIPE",
      { cameraKitWebLensSwipe: CameraKitWebLensSwipe.fromPartial(event) }
    ],
    lensWait: (event) => [
      "CAMERA_KIT_LENS_SPIN",
      { cameraKitLensSpin: CameraKitLensSpin.fromPartial(event) }
    ],
    lensContentValidationFailed: (event) => [
      "CAMERA_KIT_LENS_CONTENT_VALIDATION_FAILED",
      {
        cameraKitLensContentValidationFailed: CameraKitLensContentValidationFailed.fromPartial(event)
      }
    ],
    session: (event) => [
      "CAMERA_KIT_SESSION",
      { cameraKitSession: CameraKitSession.fromPartial(event) }
    ]
  }, appVendorAndPartnerUuid);
});

// node_modules/@snap/camera-kit/dist/logger/registerLogEntriesSubscriber.js
var registerLogEntriesSubscriber = Injectable("registerLogEntriesSubscriber", [configurationToken, logEntriesFactory.token], (configuration, logEntries) => {
  logEntries.pipe(filter((entry) => logLevelMap[entry.level] >= logLevelMap[configuration.logLevel])).subscribe((logEntry) => {
    switch (configuration.logger) {
      case "console":
        const messages = getPlatformInfo().browser.brand === "Chrome" ? logEntry.messages.map((message) => {
          if (!(message instanceof Error))
            return message;
          message.stack = stringifyError(message);
          return message;
        }) : logEntry.messages;
        console[logEntry.level](`[CameraKit.${logEntry.module}]`, ...messages);
        break;
    }
  });
});

// node_modules/@snap/camera-kit/dist/clients/lensesClient.js
var lensesClientFactory = Injectable("lensesClient", [grpcHandlerFactory.token], (grpcHandler) => createTsProtoClient(LensesDefinition, grpcHandler));

// node_modules/@snap/camera-kit/dist/lens/cameraKitLensSource.js
var import_protobufjs = __toESM(require_protobufjs());
var logger23 = getLogger("CameraKitLensSource");
var hasAnyValue2 = (c2) => {
  var _a, _b;
  return ((_b = (_a = c2.value) === null || _a === void 0 ? void 0 : _a.anyValue) === null || _b === void 0 ? void 0 : _b.value) instanceof Uint8Array;
};
var defaultWatermarkLens = {
  id: "60515300902",
  name: "Watermark",
  content: {
    lnsSha256: "3EDEAEBCD51A547FF4D1F5708FBD6F4D628AD736BEE07AB3844B14E6C69EC510",
    lnsUrlBolt: "https://bolt-gcdn.sc-cdn.net/3/L6uAe5Fhyg0ZFf3RLsCVZ?bo=EhgaABoAMgF9OgEEQgYIkbHPpgZIAlASYAE%3D&uc=18"
  }
};
var cameraKitLensSourceFactory = Injectable(lensSourcesFactory.token, [lensSourcesFactory.token, lensesClientFactory.token, remoteConfigurationFactory.token], (lensSources, lensesClient, remoteConfig) => [
  {
    isGroupOwner(groupId) {
      return groupId === watermarksLensGroup;
    },
    loadLens() {
      return __awaiter(this, void 0, void 0, function* () {
        const lensMessage = yield firstValueFrom(remoteConfig.get("CAMERA_KIT_WATERMARK_LENS").pipe(map((configResults) => {
          var _a;
          const lensMessage2 = (_a = configResults.find(hasAnyValue2)) === null || _a === void 0 ? void 0 : _a.value.anyValue.value;
          if (!lensMessage2)
            throw new Error("Failed to read watermark Lens from COF response.");
          return lensMessage2;
        }), catchError((error) => {
          logger23.error(error);
          return of(Lens.encode(Lens.fromPartial(defaultWatermarkLens)).finish());
        })));
        return import_protobufjs.Writer.create().uint32(10).bytes(lensMessage).finish();
      });
    },
    loadLensGroup() {
      return __awaiter(this, void 0, void 0, function* () {
        throw new Error("Not implemented.");
      });
    }
  },
  ...lensSources,
  {
    isGroupOwner() {
      return true;
    },
    loadLens(lensId, groupId) {
      var _a;
      return __awaiter(this, void 0, void 0, function* () {
        const result = yield lensesClient.getGroupLens({ lensId, groupId });
        if (!result.ok) {
          const error = result.unwrapErr();
          throw new Error(`Cannot load lens lens ${lensId} from group ${groupId}. An error occured in the gRPC client:
	[${error.status}] ${error.statusMessage}`);
        }
        const response = result.unwrap();
        if (!((_a = response.message) === null || _a === void 0 ? void 0 : _a.lens)) {
          throw new Error(`Cannot load lens ${lensId} from group ${groupId}. The response did not contain a lens.
	${JSON.stringify(result)} for requestId ${response.headers.get("x-request-id")}`);
        }
        return Lens.encode(response.message.lens, import_protobufjs.Writer.create().uint32(10).fork()).ldelim().finish();
      });
    },
    loadLensGroup(groupId) {
      var _a;
      return __awaiter(this, void 0, void 0, function* () {
        const result = yield lensesClient.getGroup({ id: groupId });
        if (!result.ok) {
          const error = result.unwrapErr();
          throw new Error(`Cannot load lens group ${groupId}. An error occurred in the gRPC client:
	[${error.status}] ${error.statusMessage}`);
        }
        const response = result.unwrap();
        if (!((_a = response.message) === null || _a === void 0 ? void 0 : _a.lenses)) {
          throw new Error(`Cannot load lens group ${groupId}. The response contained no lenses 
	${JSON.stringify(response)} for requestId ${response.headers.get("x-request-id")}`);
        }
        const writer = import_protobufjs.Writer.create();
        response.message.lenses.forEach((lens) => Lens.encode(lens, writer.uint32(10).fork()).ldelim());
        return writer.finish();
      });
    }
  }
]);

// node_modules/@snap/camera-kit/dist/bootstrapCameraKit.js
var logger24 = getLogger("bootstrapCameraKit");
var nonWrappableErrors = [
  "ConfigurationError",
  "PlatformNotSupportedError"
];
function shouldWrapError(error) {
  if (error instanceof Error) {
    return !nonWrappableErrors.some((name) => error.name === name);
  }
  return true;
}
function bootstrapCameraKit(configuration, provide) {
  return __awaiter(this, void 0, void 0, function* () {
    console.info(`Camera Kit SDK: ${environment_default.PACKAGE_VERSION} (${lensCoreWasmVersions_default.version}/${lensCoreWasmVersions_default.buildNumber})`);
    try {
      const bootstrapLatency = new Timer("bootstrap_time");
      assert(isSafeString(configuration.apiToken), configurationError("Invalid or unsafe apiToken provided."));
      const configurationFactory = createCameraKitConfigurationFactory(configuration);
      const defaultPublicContainer = Container.provides(configurationFactory).provides(defaultFetchHandlerFactory).provides(remoteMediaAssetLoaderFactory).provides(lensSourcesFactory).provides(remoteApiServicesFactory).provides(uriHandlersFactory).provides(externalMetricsSubjectFactory);
      const publicContainer = provide ? provide(defaultPublicContainer) : defaultPublicContainer;
      const telemetryContainer = Container.provides(publicContainer).provides(pageVisibilityFactory).provides(cameraKitServiceFetchHandlerFactory).provides(grpcHandlerFactory).provides(metricsClientFactory).provides(logEntriesFactory).run(registerLogEntriesSubscriber).provides(requestStateEventTargetFactory).provides(metricsEventTargetFactory).provides(reportGlobalException).provides(cofHandlerFactory).provides(remoteConfigurationFactory).provides(legalPromptFactory).provides(legalStateFactory).run(reportGloballyScopedMetrics).run(businessEventsReporterFactory);
      telemetryContainer.get(reportGlobalException.token);
      yield assertPlatformSupported();
      const lensCore = yield telemetryContainer.provides(lensCoreFactory).get(lensCoreFactory.token);
      const container = telemetryContainer.provides(Injectable(lensCoreFactory.token, () => lensCore)).provides(lensesClientFactory).provides(cameraKitLensSourceFactory).provides(lensPersistenceStoreFactory).provides(deviceDependentAssetLoaderFactory).provides(staticAssetLoaderFactory).provides(lensAssetRepositoryFactory).provides(lensRepositoryFactory).provides(cameraKitFactory).run(fetchWatermarkLens);
      const cameraKit = container.get(cameraKitFactory.token);
      bootstrapLatency.measure();
      container.get(metricsClientFactory.token).setOperationalMetrics(bootstrapLatency);
      return cameraKit;
    } catch (error) {
      if (shouldWrapError(error)) {
        error = bootstrapError("Error occurred during Camera Kit bootstrapping.", error);
      }
      logger24.error(error);
      throw error;
    }
  });
}
function createExtension() {
  return new PartialContainer({});
}

// node_modules/@snap/camera-kit/dist/extensions/extensionRequestContext.js
function getExtensionRequestContext() {
  return ExtensionRequestContext.encode({
    userAgent: getCameraKitUserAgent(),
    locale: getPlatformInfo().fullLocale
  }).finish();
}
var extensionRequestContext = getExtensionRequestContext();

// node_modules/@snap/camera-kit/dist/media-sources/FunctionSource.js
var getYUVImageData = (canvas, lensCore) => __awaiter(void 0, void 0, void 0, function* () {
  const { width: width2, height: height2 } = canvas;
  const outputBuffer = new ArrayBuffer(width2 * height2 * 3 / 2);
  yield lensCore.imageToYuvBuffer({ image: canvas, width: width2, height: height2, outputBuffer });
  const pixels = new Uint8ClampedArray(outputBuffer);
  return new ImageData(pixels, width2, height2);
});
var getRGBImageData = (output, imageReader2D) => {
  if (imageReader2D === null)
    return new ImageData(0, 0);
  imageReader2D.drawImage(output, 0, 0);
  return imageReader2D.getImageData(0, 0, output.width, output.height);
};
var getImageBitmap = (imageData, format) => __awaiter(void 0, void 0, void 0, function* () {
  switch (format) {
    case "nv12":
    case "yuv":
      if (!window.VideoFrame)
        return Promise.reject(new Error(`Cannot process frame. ImageData in ${format} is not supported by this browser.`));
      const frame = new VideoFrame(imageData.data.buffer, {
        format: "NV12",
        codedWidth: imageData.width,
        codedHeight: imageData.height,
        timestamp: 0
      });
      return createImageBitmap(frame);
    case "rgb":
      return createImageBitmap(imageData);
  }
});
var createFunctionSource = (sourceFunction, options = {}) => {
  let width2 = 0;
  let height2 = 0;
  let shouldProcessFrame = true;
  const imageReaderCanvas = document.createElement("canvas");
  const imageReader2D = imageReaderCanvas.getContext("2d");
  const subscriber = {
    onAttach: (source, lensCore, reportError) => {
      const outputs = lensCore.getOutputCanvases();
      const output = {
        live: outputs[lensCore.CanvasType.Preview.value],
        capture: outputs[lensCore.CanvasType.Capture.value]
      };
      const processFrame = (source2, lensCore2, reportError2) => requestAnimationFrame(() => __awaiter(void 0, void 0, void 0, function* () {
        var _a;
        if (!shouldProcessFrame)
          return;
        try {
          yield sourceFunction(({ format, imageData, timestampMillis }) => {
            const frameOutput = new Promise((resolve, reject) => __awaiter(void 0, void 0, void 0, function* () {
              const inputFrame = yield getImageBitmap(imageData, format !== null && format !== void 0 ? format : "rgb");
              if (inputFrame.width !== width2 || inputFrame.height !== height2) {
                width2 = imageReaderCanvas.width = inputFrame.width;
                height2 = imageReaderCanvas.height = inputFrame.height;
                source2.setRenderSize(width2, height2);
              }
              lensCore2.processFrame({ inputFrame, timestampMillis }).then(() => __awaiter(void 0, void 0, void 0, function* () {
                inputFrame.close();
                switch (format !== null && format !== void 0 ? format : "rgb") {
                  case "nv12":
                  case "yuv":
                    const [live, capture] = yield Promise.all([
                      getYUVImageData(output.live, lensCore2),
                      getYUVImageData(output.capture, lensCore2)
                    ]).catch((error) => {
                      reject(error);
                      return [void 0, void 0];
                    });
                    if (!live || !capture)
                      return;
                    return resolve({ live, capture });
                  case "rgb":
                    return resolve({
                      live: getRGBImageData(output.live, imageReader2D),
                      capture: getRGBImageData(output.capture, imageReader2D)
                    });
                }
              })).catch((error) => {
                inputFrame.close();
                reject(error);
              });
            }));
            frameOutput.finally(() => processFrame(source2, lensCore2, reportError2));
            return frameOutput;
          });
        } catch (error) {
          reportError2(new Error(`Failure to process frame, which was not handled by the provided MediaSourceFunction ${(_a = sourceFunction.name) !== null && _a !== void 0 ? _a : "anonymous"}.`, { cause: error }));
        }
      }));
      processFrame(source, lensCore, reportError);
    },
    onDetach: () => {
      shouldProcessFrame = false;
    }
  };
  return new CameraKitSource({ useManualFrameProcessing: true }, subscriber, options);
};

// node_modules/@snap/camera-kit/dist/media-sources/ImageSource.js
function createImageSource(image, options = {}) {
  return new CameraKitSource({
    media: image
  }, {}, options);
}
export {
  Any,
  CameraKit,
  CameraKitSession2 as CameraKitSession,
  CameraKitSource,
  ConcatInjectable,
  Container,
  Count,
  Histogram,
  Injectable,
  LensPerformanceMeasurement,
  LensPerformanceMetrics,
  LensRepository,
  Lens_CameraFacing,
  Metric,
  PartialContainer,
  Timer,
  Transform2D,
  TypedCustomEvent,
  TypedEventTarget,
  argumentValidationError,
  benchmarkError,
  bootstrapCameraKit,
  bootstrapError,
  cacheKeyNotFoundError,
  cameraKitSourceError,
  configurationError,
  configurationToken,
  createExtension,
  createFunctionSource,
  createImageSource,
  createMediaStreamSource,
  createVideoSource,
  defaultFetchHandlerFactory,
  estimateLensPerformance,
  extensionRequestContext,
  externalMetricsSubjectFactory,
  legalError,
  lensAbortError,
  lensAssetError,
  lensContentValidationError,
  lensError,
  lensExecutionError,
  lensImagePickerError,
  lensSourcesFactory,
  namedError,
  persistentStoreError,
  platformNotSupportedError,
  remoteApiServicesFactory,
  remoteMediaAssetLoaderFactory,
  toPublicLens,
  uriHandlersFactory,
  webGLError
};
//# sourceMappingURL=@snap_camera-kit.js.map
