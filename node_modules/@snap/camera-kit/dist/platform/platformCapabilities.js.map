{"version":3,"file":"platformCapabilities.js","sourceRoot":"","sources":["../../src/platform/platformCapabilities.ts"],"names":[],"mappings":"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","sourcesContent":["import { exceptions, simd } from \"wasm-feature-detect\";\nimport { memoize } from \"../common/memoize\";\nimport type { XrCapabilities } from \"../lens-core-module/generated-types\";\nimport { platformNotSupportedError } from \"../namedErrors\";\nimport { getPlatformInfo } from \"./platformInfo\";\n\n/** @internal */\nexport type SupportedCapability<T> = T & { supported: true };\n/** @internal */\nexport type UnsupportedCapability = { supported: false; error: Error };\n/** @internal */\nexport type Capability<T = void> = SupportedCapability<T> | UnsupportedCapability;\n\n//-----------\n// WebGL\n//-----------\n\ntype WebGlCapability = Capability<{ maxTextureSize: number }>;\n\n// This required minimum max texture size is based on data from\n// https://web3dsurvey.com/webgl/parameters/MAX_TEXTURE_SIZE. Checking for a reasonable minimum MAX_TEXTURE_SIZE avoids\n// attempting to run lenses on platforms that will not support them -- most commonly, we've seen some platforms that\n// report 0 MAX_TEXTURE_SIZE, which will cause errors for all lenses.\nconst minRequiredMaxTextureSize = 1024;\n\n/**\n * @returns An object with fields describing support for various WebGL features.\n *\n * @internal\n */\nfunction getWebGlSupport(): WebGlCapability {\n    const ctx = globalThis.document?.createElement(\"canvas\").getContext(\"webgl2\");\n    if (!ctx) {\n        const cause = globalThis.document?.createElement(\"canvas\").getContext(\"webgl\")\n            ? \"platform_not_supported_only_webgl1\"\n            : typeof globalThis.WebGLRenderingContext === \"function\"\n            ? \"platform_not_supported_likely_no_hw_accel\"\n            : \"platform_not_supported_no_webgl_browser_support\";\n        return {\n            supported: false,\n            error: platformNotSupportedError(\n                \"CameraKit requires WebGL2, but this browser does not support WebGL2.\",\n                new Error(cause)\n            ),\n        };\n    }\n    const maxTextureSize = ctx.getParameter(ctx.MAX_TEXTURE_SIZE);\n    const supported = maxTextureSize >= minRequiredMaxTextureSize;\n    return supported\n        ? { supported, maxTextureSize }\n        : {\n              supported,\n              error: platformNotSupportedError(\n                  `CameraKit requires WebGL's MAX_TEXTURE_SIZE exceed a minimum value of ` +\n                      `${minRequiredMaxTextureSize}, but the browser's reported MAX_TEXTURE_SIZE is ${maxTextureSize}.`\n              ),\n          };\n}\n\n//-----------\n// WASM\n//-----------\n\ntype WasmCapability = Capability<{ wasmFeatures: number }>;\n\n/**\n * Because there may be a large number of WASM-related capabilities, and because these may correspond to various builds\n * of LensCore, we encode the various WASM capabilities into a single number by bitwise OR-ing together the numbers\n * corresponding to each capability.\n *\n * Since each combindation of capabilities is represented by a single number, we can easily map between that number and\n * the corresponding LensCore build name that makes use of those capabilities.\n *\n * @internal\n */\nexport enum WasmFeatures {\n    Default = 0b00000000,\n    SIMD = 0b00000001,\n    ExceptionHandling = 0b00000010,\n}\n\n/**\n * @returns A non-negative integer representing the combination of supported WebAssembly features, or -1 if WebAssembly\n * is not supported at all.\n *\n * @internal\n */\nasync function getWebAssemblyCapabilities(): Promise<WasmCapability> {\n    if (globalThis.WebAssembly === undefined)\n        return {\n            supported: false,\n            error: platformNotSupportedError(\n                \"CameraKit requires WebAssembly, but this browser does not support WebAssembly.\"\n            ),\n        };\n    return {\n        supported: true,\n        wasmFeatures: (\n            await Promise.all([\n                simd().then((supported) => {\n                    // Although Safari 16.4 reports SIMD support, LensCore encounters rendering bugs when using\n                    // SIMD in Safari 16.4. We will disable SIMD for now until Safari stabilizes the feature.\n                    if (getPlatformInfo().browser.brand === \"Safari\") return WasmFeatures.Default;\n                    return supported ? WasmFeatures.SIMD : WasmFeatures.Default;\n                }),\n                exceptions().then((supported) => (supported ? WasmFeatures.ExceptionHandling : WasmFeatures.Default)),\n            ])\n        ).reduce((features, feature) => features | feature, WasmFeatures.Default),\n    };\n}\n\n//-----------\n// WebXR\n//-----------\n\ntype WebXrCapability = Capability<XrCapabilities>;\n\nfunction getGenericWebXrNotSupported(cause?: unknown): WebXrCapability {\n    return {\n        supported: false,\n        error: platformNotSupportedError(\n            `Use of this feature requires WebXR support for immersive AR sessions, but ` +\n                `this browser does not support immersive AR sessions.`,\n            cause\n        ),\n    };\n}\n\n/**\n * @returns A Promise containing an object with fields describing the support of various WebXR features. This object's\n * type is defined by LensCore, as they consume these capabilities and adjust behavior accordingly.\n *\n * @internal\n */\nexport async function getWebXrCapabilities(): Promise<WebXrCapability> {\n    try {\n        if (!isSecureContext || !navigator.xr) return getGenericWebXrNotSupported();\n        const isImmersiveArSupported = await navigator.xr.isSessionSupported(\"immersive-ar\");\n        return isImmersiveArSupported\n            ? {\n                  supported: true,\n                  sixDofSupported: true,\n                  sceneDepthSupported: true,\n              }\n            : getGenericWebXrNotSupported();\n    } catch (error) {\n        if (error instanceof Error && error.name === \"SecurityError\") {\n            return {\n                supported: false,\n                error: platformNotSupportedError(\n                    \"Failed to check XR capabilities due to permissions or other issues.\",\n                    error\n                ),\n            };\n        }\n        return getGenericWebXrNotSupported(error);\n    }\n}\n\n/** @internal */\nexport interface PlatformCapabilities {\n    webgl: WebGlCapability;\n    wasm: WasmCapability;\n    webxr: WebXrCapability;\n}\n\n/**\n * Get information about the current platform capabilities, including:\n * - WebGL support and various WebGL parameters.\n * - WASM support and support for various WASM features.\n * - WebXR support and support for various WebXR features.\n *\n * @internal\n */\nexport const getPlatformCapabilities = memoize(async function getPlatformCapabilities(): Promise<PlatformCapabilities> {\n    return {\n        webgl: getWebGlSupport(),\n        wasm: await getWebAssemblyCapabilities(),\n        webxr: await getWebXrCapabilities(),\n    };\n});\n"]}