import { __awaiter } from "tslib";
import { exceptions, simd } from "wasm-feature-detect";
import { memoize } from "../common/memoize";
import { platformNotSupportedError } from "../namedErrors";
import { getPlatformInfo } from "./platformInfo";
const minRequiredMaxTextureSize = 1024;
function getWebGlSupport() {
    var _a, _b;
    const ctx = (_a = globalThis.document) === null || _a === void 0 ? void 0 : _a.createElement("canvas").getContext("webgl2");
    if (!ctx) {
        const cause = ((_b = globalThis.document) === null || _b === void 0 ? void 0 : _b.createElement("canvas").getContext("webgl"))
            ? "platform_not_supported_only_webgl1"
            : typeof globalThis.WebGLRenderingContext === "function"
                ? "platform_not_supported_likely_no_hw_accel"
                : "platform_not_supported_no_webgl_browser_support";
        return {
            supported: false,
            error: platformNotSupportedError("CameraKit requires WebGL2, but this browser does not support WebGL2.", new Error(cause)),
        };
    }
    const maxTextureSize = ctx.getParameter(ctx.MAX_TEXTURE_SIZE);
    const supported = maxTextureSize >= minRequiredMaxTextureSize;
    return supported
        ? { supported, maxTextureSize }
        : {
            supported,
            error: platformNotSupportedError(`CameraKit requires WebGL's MAX_TEXTURE_SIZE exceed a minimum value of ` +
                `${minRequiredMaxTextureSize}, but the browser's reported MAX_TEXTURE_SIZE is ${maxTextureSize}.`),
        };
}
export var WasmFeatures;
(function (WasmFeatures) {
    WasmFeatures[WasmFeatures["Default"] = 0] = "Default";
    WasmFeatures[WasmFeatures["SIMD"] = 1] = "SIMD";
    WasmFeatures[WasmFeatures["ExceptionHandling"] = 2] = "ExceptionHandling";
})(WasmFeatures || (WasmFeatures = {}));
function getWebAssemblyCapabilities() {
    return __awaiter(this, void 0, void 0, function* () {
        if (globalThis.WebAssembly === undefined)
            return {
                supported: false,
                error: platformNotSupportedError("CameraKit requires WebAssembly, but this browser does not support WebAssembly."),
            };
        return {
            supported: true,
            wasmFeatures: (yield Promise.all([
                simd().then((supported) => {
                    if (getPlatformInfo().browser.brand === "Safari")
                        return WasmFeatures.Default;
                    return supported ? WasmFeatures.SIMD : WasmFeatures.Default;
                }),
                exceptions().then((supported) => (supported ? WasmFeatures.ExceptionHandling : WasmFeatures.Default)),
            ])).reduce((features, feature) => features | feature, WasmFeatures.Default),
        };
    });
}
function getGenericWebXrNotSupported(cause) {
    return {
        supported: false,
        error: platformNotSupportedError(`Use of this feature requires WebXR support for immersive AR sessions, but ` +
            `this browser does not support immersive AR sessions.`, cause),
    };
}
export function getWebXrCapabilities() {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            if (!isSecureContext || !navigator.xr)
                return getGenericWebXrNotSupported();
            const isImmersiveArSupported = yield navigator.xr.isSessionSupported("immersive-ar");
            return isImmersiveArSupported
                ? {
                    supported: true,
                    sixDofSupported: true,
                    sceneDepthSupported: true,
                }
                : getGenericWebXrNotSupported();
        }
        catch (error) {
            if (error instanceof Error && error.name === "SecurityError") {
                return {
                    supported: false,
                    error: platformNotSupportedError("Failed to check XR capabilities due to permissions or other issues.", error),
                };
            }
            return getGenericWebXrNotSupported(error);
        }
    });
}
export const getPlatformCapabilities = memoize(function getPlatformCapabilities() {
    return __awaiter(this, void 0, void 0, function* () {
        return {
            webgl: getWebGlSupport(),
            wasm: yield getWebAssemblyCapabilities(),
            webxr: yield getWebXrCapabilities(),
        };
    });
});
//# sourceMappingURL=platformCapabilities.js.map