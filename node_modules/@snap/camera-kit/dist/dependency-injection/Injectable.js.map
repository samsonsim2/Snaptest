{"version":3,"file":"Injectable.js","sourceRoot":"","sources":["../../src/dependency-injection/Injectable.ts"],"names":[],"mappings":"AA0DA,MAAM,UAAU,UAAU,CACtB,KAAa,EACb,gBAAkD,EAClD,OAAiC;IAEjC,MAAM,YAAY,GAAa,KAAK,CAAC,OAAO,CAAC,gBAAgB,CAAC,CAAC,CAAC,CAAC,gBAAgB,CAAC,CAAC,CAAC,EAAE,CAAC;IACvF,MAAM,EAAE,GAAG,OAAO,gBAAgB,KAAK,UAAU,CAAC,CAAC,CAAC,gBAAgB,CAAC,CAAC,CAAC,OAAO,CAAC;IAE/E,IAAI,CAAC,EAAE,EAAE;QACL,MAAM,IAAI,SAAS,CACf,0FAA0F;YACtF,oBAAoB,CAC3B,CAAC;KACL;IAED,IAAI,EAAE,CAAC,MAAM,KAAK,YAAY,CAAC,MAAM,EAAE;QACnC,MAAM,IAAI,SAAS,CACf,4FAA4F;YACxF,GAAG,EAAE,CAAC,MAAM,SAAS,YAAY,CAAC,MAAM,+BAA+B;YACvE,mBAAmB,IAAI,CAAC,SAAS,CAAC,YAAY,CAAC,EAAE,CACxD,CAAC;KACL;IAED,MAAM,OAAO,GAAG,CAAC,GAAG,IAAW,EAAE,EAAE,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,CAAC;IAChD,OAAO,CAAC,KAAK,GAAG,KAAK,CAAC;IACtB,OAAO,CAAC,YAAY,GAAG,YAAY,CAAC;IACpC,OAAO,OAAO,CAAC;AACnB,CAAC;AAuED,MAAM,UAAU,gBAAgB,CAC5B,KAAa,EACb,gBAAkD,EAClD,OAAiC;IAEjC,MAAM,YAAY,GAAa,KAAK,CAAC,OAAO,CAAC,gBAAgB,CAAC,CAAC,CAAC,CAAC,gBAAgB,CAAC,CAAC,CAAC,EAAE,CAAC;IACvF,MAAM,EAAE,GAAG,OAAO,gBAAgB,KAAK,UAAU,CAAC,CAAC,CAAC,gBAAgB,CAAC,CAAC,CAAC,OAAO,CAAC;IAE/E,IAAI,CAAC,EAAE,EAAE;QACL,MAAM,IAAI,SAAS,CACf,gGAAgG;YAC5F,oBAAoB,CAC3B,CAAC;KACL;IAED,IAAI,EAAE,CAAC,MAAM,KAAK,YAAY,CAAC,MAAM,EAAE;QACnC,MAAM,IAAI,SAAS,CACf,4FAA4F;YACxF,GAAG,EAAE,CAAC,MAAM,SAAS,YAAY,CAAC,MAAM,+BAA+B;YACvE,mBAAmB,IAAI,CAAC,SAAS,CAAC,YAAY,CAAC,EAAE,CACxD,CAAC;KACL;IAED,MAAM,OAAO,GAAG,CAAC,KAAY,EAAE,GAAG,IAAW,EAAE,EAAE;QAC7C,OAAO,KAAK,CAAC,MAAM,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,CAAC,CAAC;IACrC,CAAC,CAAC;IACF,OAAO,CAAC,KAAK,GAAG,KAAK,CAAC;IACtB,OAAO,CAAC,YAAY,GAAG,CAAC,KAAK,EAAE,GAAG,YAAY,CAAC,CAAC;IAChD,OAAO,OAAO,CAAC;AACnB,CAAC","sourcesContent":["import type { InjectableFunction, ServicesFromTokenizedParams } from \"./types\";\n\n/**\n * Create an Injectable factory function with no dependencies (i.e. the factory function has no arguments).\n *\n * Ex:\n * ```ts\n * const createMyService = Injectable(\n *   'MyService',\n *   () => { return ... },\n * )\n * ```\n *\n * @param token A unique string Token which will correspond to the created Service.\n * @param fn A function with no arguments which returns the Service.\n */\nexport function Injectable<Token extends string, Service>(\n    token: Token,\n    fn: () => Service\n): InjectableFunction<any, [], Token, Service>;\n\n/**\n * Create an Injectable factory function with dependencies (i.e. the factory function has arguments).\n *\n * **Note:** the list of dependencies must contain only string literals or string consts.\n *\n * Ex:\n * ```ts\n * const DependencyB = 'DependencyB'\n * const createMyService = Injectable(\n *   'MyService',\n *   ['DependencyA', DependencyB] as const,\n *   (a: A, b: B) => { return ... },\n * )\n * ```\n *\n * @param token A unique string Token which will correspond to the created Service.\n * @param dependencies A *readonly* list of Tokens corresponding to dependencies (i.e. arguments to the Factory), which\n * will be resolved by the Container to which this Injectable is provided.\n * @param fn A function with arguments matching in type and length to the given list of dependencies. When called, it\n * must return the Service.\n */\nexport function Injectable<\n    Token extends string,\n    Tokens extends readonly string[],\n    Params extends readonly any[],\n    Service\n>(\n    token: Token,\n    dependencies: Tokens,\n    // The function arity (number of arguments) must match the number of dependencies specified â€“ if they don't, we'll\n    // force a compiler error by saying the arguments should be `void[]`. We'll also throw at runtime, so the return\n    // type will be `never`.\n    fn: (...args: Tokens[\"length\"] extends Params[\"length\"] ? Params : void[]) => Service\n): Tokens[\"length\"] extends Params[\"length\"]\n    ? InjectableFunction<ServicesFromTokenizedParams<Tokens, Params>, Tokens, Token, Service>\n    : never;\n\nexport function Injectable(\n    token: string,\n    dependenciesOrFn?: readonly string[] | (() => any),\n    maybeFn?: (...args: any[]) => any\n): InjectableFunction<any, readonly string[], string, any> {\n    const dependencies: string[] = Array.isArray(dependenciesOrFn) ? dependenciesOrFn : [];\n    const fn = typeof dependenciesOrFn === \"function\" ? dependenciesOrFn : maybeFn;\n\n    if (!fn) {\n        throw new TypeError(\n            \"[Injectable] Received invalid arguments. The factory function must be either the second \" +\n                \"or third argument.\"\n        );\n    }\n\n    if (fn.length !== dependencies.length) {\n        throw new TypeError(\n            \"[Injectable] Function arity does not match the number of dependencies. Function has arity \" +\n                `${fn.length}, but ${dependencies.length} dependencies were specified.` +\n                `\\nDependencies: ${JSON.stringify(dependencies)}`\n        );\n    }\n\n    const factory = (...args: any[]) => fn(...args);\n    factory.token = token;\n    factory.dependencies = dependencies;\n    return factory;\n}\n\n/**\n * Create an Injectable factory function without dependencies (i.e. the factory function has no arguments) that appends\n * a Service onto an existing array of Services of the same type.\n *\n * Ex:\n * ```ts\n * import { myServiceFactory, MyService } from './my-service'\n *\n * const createMyService = ConcatInjectable(\n *   myServiceFactory.token,\n *   (): MyService => { return ... },\n * )\n *\n * // Consumers then do:\n * const myConsumingServiceFactory = Injectable(\n *   'myConsumingService',\n *   [myServiceFactory.token] as const,\n *   (myServices: MyService[]) => { return ... }\n * )\n * ```\n *\n * @param token A string Token identifying an existing Service that has an Array type, to which will be appended the\n * Service created by this factory function.\n * @param fn A function with no arguments which returns the Service.\n */\nexport function ConcatInjectable<Token extends string, Service>(\n    token: Token,\n    fn: () => Service\n): InjectableFunction<{ [T in keyof Token]: Service[] }, [], Token, Service[]>;\n\n/**\n * Create an Injectable factory function with dependencies (i.e. the factory function has arguments) that appends\n * a Service onto an existing array of Services of the same type.\n *\n * Ex:\n * ```ts\n * import { myServiceFactory, MyService } from './my-service'\n *\n * const createMyService = ConcatInjectable(\n *   myServiceFactory.token,\n *   ['DependencyA', 'DependencyB'] as const,\n *   (a: A, b: B): MyService => { return ... },\n * )\n *\n * // Consumers then do:\n * const myConsumingServiceFactory = Injectable(\n *   'myConsumingService',\n *   [myServiceFactory.token] as const,\n *   (myServices: MyService[]) => { return ... }\n * )\n * ```\n *\n * @param token A string Token identifying an existing Service that has an Array type, to which will be appended the\n * Service created by this factory function.\n * @param dependencies A *readonly* list of Tokens corresponding to dependencies (i.e. arguments to the Factory), which\n * will be resolved by the Container to which this Injectable is provided.\n * @param fn A function with no arguments which returns the Service.\n */\nexport function ConcatInjectable<\n    Token extends string,\n    Tokens extends readonly string[],\n    Params extends readonly any[],\n    Service\n>(\n    token: Token,\n    dependencies: Tokens,\n    fn: (...args: Tokens[\"length\"] extends Params[\"length\"] ? Params : void[]) => Service\n): InjectableFunction<ServicesFromTokenizedParams<Tokens, Params>, Tokens, Token, Service[]>;\n\nexport function ConcatInjectable(\n    token: string,\n    dependenciesOrFn?: readonly string[] | (() => any),\n    maybeFn?: (...args: any[]) => any\n): InjectableFunction<any, readonly string[], string, any[]> {\n    const dependencies: string[] = Array.isArray(dependenciesOrFn) ? dependenciesOrFn : [];\n    const fn = typeof dependenciesOrFn === \"function\" ? dependenciesOrFn : maybeFn;\n\n    if (!fn) {\n        throw new TypeError(\n            \"[ConcatInjectable] Received invalid arguments. The factory function must be either the second \" +\n                \"or third argument.\"\n        );\n    }\n\n    if (fn.length !== dependencies.length) {\n        throw new TypeError(\n            \"[Injectable] Function arity does not match the number of dependencies. Function has arity \" +\n                `${fn.length}, but ${dependencies.length} dependencies were specified.` +\n                `\\nDependencies: ${JSON.stringify(dependencies)}`\n        );\n    }\n\n    const factory = (array: any[], ...args: any[]) => {\n        return array.concat(fn(...args));\n    };\n    factory.token = token;\n    factory.dependencies = [token, ...dependencies];\n    return factory;\n}\n"]}