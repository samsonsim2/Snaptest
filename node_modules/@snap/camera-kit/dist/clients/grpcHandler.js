import { __awaiter } from "tslib";
import { grpc } from "@improbable-eng/grpc-web";
import { Injectable } from "../dependency-injection/Injectable";
import { configurationToken } from "../configuration";
import { Err, Ok } from "../common/result";
import { cameraKitServiceFetchHandlerFactory } from "../handlers/cameraKitServiceFetchHandlerFactory";
export const grpcHandlerFactory = Injectable("grpcHandlerFactory", [configurationToken, cameraKitServiceFetchHandlerFactory.token], (configuration, handler) => {
    const host = `https://${configuration.apiHostname}`;
    const transport = (options) => {
        let metadata = undefined;
        const controller = globalThis.AbortController ? new AbortController() : undefined;
        let cancelled = false;
        return {
            sendMessage(msgBytes) {
                var _a;
                handler(options.url, {
                    headers: (_a = metadata === null || metadata === void 0 ? void 0 : metadata.toHeaders()) !== null && _a !== void 0 ? _a : {},
                    method: "POST",
                    body: msgBytes,
                    signal: controller === null || controller === void 0 ? void 0 : controller.signal,
                })
                    .then((response) => {
                    options.onHeaders(new grpc.Metadata(response.headers), response.status);
                    return response.arrayBuffer();
                })
                    .then((body) => {
                    if (cancelled)
                        return;
                    options.onChunk(new Uint8Array(body));
                    options.onEnd();
                })
                    .catch((error) => {
                    if (cancelled)
                        return;
                    cancelled = true;
                    options.onEnd(error);
                });
            },
            start(m) {
                metadata = m;
            },
            finishSend() { },
            cancel() {
                if (cancelled)
                    return;
                cancelled = true;
                controller === null || controller === void 0 ? void 0 : controller.abort();
            },
        };
    };
    return (request) => __awaiter(void 0, void 0, void 0, function* () {
        return new Promise((resolve) => {
            grpc.unary({
                methodName: request.methodName,
                service: { serviceName: request.serviceName },
                requestStream: false,
                responseStream: false,
                requestType: request.requestType,
                responseType: request.responseType,
            }, {
                request: new request.requestType(),
                host,
                onEnd: (response) => {
                    if (isUnaryOutputOk(response)) {
                        resolve(Ok(response));
                    }
                    else {
                        resolve(Err(response));
                    }
                },
                transport,
            });
        });
    });
});
function isUnaryOutputOk(value) {
    return value.status === grpc.Code.OK;
}
//# sourceMappingURL=grpcHandler.js.map