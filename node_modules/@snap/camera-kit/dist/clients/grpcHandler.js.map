{"version":3,"file":"grpcHandler.js","sourceRoot":"","sources":["../../src/clients/grpcHandler.ts"],"names":[],"mappings":";AAAA,OAAO,EAAE,IAAI,EAAE,MAAM,0BAA0B,CAAC;AAEhD,OAAO,EAAE,UAAU,EAAE,MAAM,oCAAoC,CAAC;AAEhE,OAAO,EAAE,kBAAkB,EAAE,MAAM,kBAAkB,CAAC;AAEtD,OAAO,EAAE,GAAG,EAAE,EAAE,EAAE,MAAM,kBAAkB,CAAC;AAE3C,OAAO,EAAE,mCAAmC,EAAE,MAAM,iDAAiD,CAAC;AAsBtG,MAAM,CAAC,MAAM,kBAAkB,GAAG,UAAU,CACxC,oBAAoB,EACpB,CAAC,kBAAkB,EAAE,mCAAmC,CAAC,KAAK,CAAU,EACxE,CAAC,aAAqC,EAAE,OAAqB,EAAe,EAAE;IAC1E,MAAM,IAAI,GAAG,WAAW,aAAa,CAAC,WAAW,EAAE,CAAC;IAOpD,MAAM,SAAS,GAA0B,CAAC,OAAO,EAAE,EAAE;QACjD,IAAI,QAAQ,GAA8B,SAAS,CAAC;QACpD,MAAM,UAAU,GAAG,UAAU,CAAC,eAAe,CAAC,CAAC,CAAC,IAAI,eAAe,EAAE,CAAC,CAAC,CAAC,SAAS,CAAC;QAClF,IAAI,SAAS,GAAG,KAAK,CAAC;QACtB,OAAO;YACH,WAAW,CAAC,QAAQ;;gBAChB,OAAO,CAAC,OAAO,CAAC,GAAG,EAAE;oBACjB,OAAO,EAAE,MAAA,QAAQ,aAAR,QAAQ,uBAAR,QAAQ,CAAE,SAAS,EAAE,mCAAI,EAAE;oBACpC,MAAM,EAAE,MAAM;oBACd,IAAI,EAAE,QAAQ;oBACd,MAAM,EAAE,UAAU,aAAV,UAAU,uBAAV,UAAU,CAAE,MAAM;iBAC7B,CAAC;qBACG,IAAI,CAAC,CAAC,QAAQ,EAAE,EAAE;oBACf,OAAO,CAAC,SAAS,CAAC,IAAI,IAAI,CAAC,QAAQ,CAAC,QAAQ,CAAC,OAAO,CAAC,EAAE,QAAQ,CAAC,MAAM,CAAC,CAAC;oBACxE,OAAO,QAAQ,CAAC,WAAW,EAAE,CAAC;gBAClC,CAAC,CAAC;qBACD,IAAI,CAAC,CAAC,IAAI,EAAE,EAAE;oBACX,IAAI,SAAS;wBAAE,OAAO;oBACtB,OAAO,CAAC,OAAO,CAAC,IAAI,UAAU,CAAC,IAAI,CAAC,CAAC,CAAC;oBACtC,OAAO,CAAC,KAAK,EAAE,CAAC;gBACpB,CAAC,CAAC;qBACD,KAAK,CAAC,CAAC,KAAK,EAAE,EAAE;oBACb,IAAI,SAAS;wBAAE,OAAO;oBACtB,SAAS,GAAG,IAAI,CAAC;oBACjB,OAAO,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC;gBACzB,CAAC,CAAC,CAAC;YACX,CAAC;YAED,KAAK,CAAC,CAAC;gBACH,QAAQ,GAAG,CAAC,CAAC;YACjB,CAAC;YAED,UAAU,KAAI,CAAC;YAEf,MAAM;gBACF,IAAI,SAAS;oBAAE,OAAO;gBACtB,SAAS,GAAG,IAAI,CAAC;gBACjB,UAAU,aAAV,UAAU,uBAAV,UAAU,CAAE,KAAK,EAAE,CAAC;YACxB,CAAC;SACJ,CAAC;IACN,CAAC,CAAC;IAEF,OAAO,CAAO,OAAO,EAAE,EAAE;QACrB,OAAA,IAAI,OAAO,CAAC,CAAC,OAAO,EAAE,EAAE;YACpB,IAAI,CAAC,KAAK,CACN;gBACI,UAAU,EAAE,OAAO,CAAC,UAAU;gBAC9B,OAAO,EAAE,EAAE,WAAW,EAAE,OAAO,CAAC,WAAW,EAAE;gBAC7C,aAAa,EAAE,KAAK;gBACpB,cAAc,EAAE,KAAK;gBACrB,WAAW,EAAE,OAAO,CAAC,WAAW;gBAChC,YAAY,EAAE,OAAO,CAAC,YAAY;aACrC,EACD;gBACI,OAAO,EAAE,IAAI,OAAO,CAAC,WAAW,EAAE;gBAClC,IAAI;gBACJ,KAAK,EAAE,CAAC,QAAQ,EAAE,EAAE;oBAChB,IAAI,eAAe,CAAC,QAAQ,CAAC,EAAE;wBAC3B,OAAO,CAAC,EAAE,CAAC,QAAQ,CAAC,CAAC,CAAC;qBACzB;yBAAM;wBACH,OAAO,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC,CAAC;qBAC1B;gBACL,CAAC;gBACD,SAAS;aACZ,CACJ,CAAC;QACN,CAAC,CAAC,CAAA;MAAA,CAAC;AACX,CAAC,CACJ,CAAC;AAEF,SAAS,eAAe,CACpB,KAA6C;IAE7C,OAAO,KAAK,CAAC,MAAM,KAAK,IAAI,CAAC,IAAI,CAAC,EAAE,CAAC;AACzC,CAAC","sourcesContent":["import { grpc } from \"@improbable-eng/grpc-web\";\nimport type { Handler, RequestMetadata } from \"../handlers/HandlerChainBuilder\";\nimport { Injectable } from \"../dependency-injection/Injectable\";\nimport type { CameraKitConfiguration } from \"../configuration\";\nimport { configurationToken } from \"../configuration\";\nimport type { Result } from \"../common/result\";\nimport { Err, Ok } from \"../common/result\";\nimport type { FetchHandler } from \"../handlers/defaultFetchHandler\";\nimport { cameraKitServiceFetchHandlerFactory } from \"../handlers/cameraKitServiceFetchHandlerFactory\";\n\nexport interface GrpcRequest {\n    serviceName: string;\n    methodName: string;\n    requestType: grpc.ProtobufMessageClass<grpc.ProtobufMessage>;\n    responseType: grpc.ProtobufMessageClass<grpc.ProtobufMessage>;\n}\n\nexport type GrpcHandler = Handler<GrpcRequest, GrpcResult, RequestMetadata>;\n\nexport type GrpcResult = Result<\n    grpc.UnaryOutput<grpc.ProtobufMessage> & { status: grpc.Code.OK },\n    grpc.UnaryOutput<grpc.ProtobufMessage>\n>;\n\n/**\n * An Injectable handler that can make requests to the CameraKit backend service via grpc-web. This handler can be\n * passed to {@link createTsProtoClient} to produce a well-typed service client.\n *\n * @internal\n */\nexport const grpcHandlerFactory = Injectable(\n    \"grpcHandlerFactory\",\n    [configurationToken, cameraKitServiceFetchHandlerFactory.token] as const,\n    (configuration: CameraKitConfiguration, handler: FetchHandler): GrpcHandler => {\n        const host = `https://${configuration.apiHostname}`;\n\n        // We define our own Transport so that we can use our custom `fetch` implementation. This is important for two\n        // reasons:\n        //   1. Our custom fetch includes features like retries that we want to use for these requests.\n        //   2. Applications may override this fetch implementation (via our DI system) to support more advanced\n        //      use-cases.\n        const transport: grpc.TransportFactory = (options) => {\n            let metadata: grpc.Metadata | undefined = undefined;\n            const controller = globalThis.AbortController ? new AbortController() : undefined;\n            let cancelled = false;\n            return {\n                sendMessage(msgBytes) {\n                    handler(options.url, {\n                        headers: metadata?.toHeaders() ?? {},\n                        method: \"POST\",\n                        body: msgBytes,\n                        signal: controller?.signal,\n                    })\n                        .then((response) => {\n                            options.onHeaders(new grpc.Metadata(response.headers), response.status);\n                            return response.arrayBuffer();\n                        })\n                        .then((body) => {\n                            if (cancelled) return;\n                            options.onChunk(new Uint8Array(body));\n                            options.onEnd();\n                        })\n                        .catch((error) => {\n                            if (cancelled) return;\n                            cancelled = true;\n                            options.onEnd(error);\n                        });\n                },\n\n                start(m) {\n                    metadata = m;\n                },\n\n                finishSend() {},\n\n                cancel() {\n                    if (cancelled) return;\n                    cancelled = true;\n                    controller?.abort();\n                },\n            };\n        };\n\n        return async (request) =>\n            new Promise((resolve) => {\n                grpc.unary(\n                    {\n                        methodName: request.methodName,\n                        service: { serviceName: request.serviceName },\n                        requestStream: false,\n                        responseStream: false,\n                        requestType: request.requestType,\n                        responseType: request.responseType,\n                    },\n                    {\n                        request: new request.requestType(),\n                        host,\n                        onEnd: (response) => {\n                            if (isUnaryOutputOk(response)) {\n                                resolve(Ok(response));\n                            } else {\n                                resolve(Err(response));\n                            }\n                        },\n                        transport,\n                    }\n                );\n            });\n    }\n);\n\nfunction isUnaryOutputOk(\n    value: grpc.UnaryOutput<grpc.ProtobufMessage>\n): value is grpc.UnaryOutput<grpc.ProtobufMessage> & { status: grpc.Code.OK } {\n    return value.status === grpc.Code.OK;\n}\n"]}